---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
title: "중첩 된 데이터 웹 컨트롤 (VB) | Microsoft Docs"
author: rick-anderson
description: "이 자습서를 살펴볼 것입니다는 반복기를 사용 하는 방법을 다른 반복기 내에 중첩 합니다. 이 예에서는 두 d 내부 반복을 채우는 방법을 설명 합니다..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 09/13/2006
ms.topic: article
ms.assetid: 8b7fcf7b-722b-498d-a4e4-7c93701e0c95
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
msc.type: authoredcontent
ms.openlocfilehash: 944f208d6fe4f9fde13b530fb236ecc69ff5e9cd
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/10/2017
---
<a name="nested-data-web-controls-vb"></a><span data-ttu-id="0b950-104">중첩 된 데이터 웹 컨트롤 (VB)</span><span class="sxs-lookup"><span data-stu-id="0b950-104">Nested Data Web Controls (VB)</span></span>
====================
<span data-ttu-id="0b950-105">으로 [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0b950-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0b950-106">[샘플 앱을 다운로드](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) 또는 [PDF 다운로드](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0b950-106">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) or [Download PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span></span>

> <span data-ttu-id="0b950-107">이 자습서를 살펴볼 것입니다는 반복기를 사용 하는 방법을 다른 반복기 내에 중첩 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="0b950-108">예제를 선언적으로 또는 프로그래밍 방식으로 내부 반복을 채우는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


## <a name="introduction"></a><span data-ttu-id="0b950-109">소개</span><span class="sxs-lookup"><span data-stu-id="0b950-109">Introduction</span></span>

<span data-ttu-id="0b950-110">정적 HTML과 구문이 외에도 웹 컨트롤 및 사용자 정의 컨트롤 템플릿이 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="0b950-111">이러한 웹 컨트롤의 속성을 가질 수 있습니다, 선언적 데이터 바인딩 구문을 통해 할당 된 또는 적절 한 서버 쪽 이벤트 처리기에서 프로그래밍 방식으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="0b950-112">템플릿 내에서 컨트롤을 포함 하 여 모양 및 사용자 환경은 수 하 개선.</span><span class="sxs-lookup"><span data-stu-id="0b950-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="0b950-113">예를 들어는 [GridView 컨트롤에 사용 하 여 TemplateFields](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) 직원의 고용 날짜를 표시 하도록 TemplateField;에 있는 Calendar 컨트롤을 추가 하 여 GridView의 표시를 사용자 지정 하는 방법에 살펴보았습니다 자습서는 [추가 유효성 검사 컨트롤을 편집 및 삽입 인터페이스](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) 및 [데이터 수정 인터페이스 사용자 지정](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) 자습서에서 살펴본를 편집 하는 사용자 지정 하는 방법 및 삽입 인터페이스 유효성 검사 추가 컨트롤, 텍스트 상자, dropdownlist 활용, 및 기타 웹 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="0b950-114">서식 파일에서 다른 데이터 웹 컨트롤을 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="0b950-115">즉, 우리 해당 템플릿 내의 다른 DataList (또는 반복기 또는 GridView 또는 DetailsView, 및 등)를 포함 하는 DataList를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="0b950-116">이러한 인터페이스와 챌린지 내부 데이터 웹 컨트롤에 적절 한 데이터 바인딩된 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="0b950-117">프로그래밍 방식으로 프로토콜로 ObjectDataSource를 사용 하 여 선언적 옵션 까지의 사용 가능한 몇 가지 다른 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="0b950-118">이 자습서를 살펴볼 것입니다는 반복기를 사용 하는 방법을 다른 반복기 내에 중첩 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="0b950-119">외부 반복 범주의 이름 및 설명을 표시는 데이터베이스의 각 범주에 대 한 항목이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="0b950-120">각 범주 항목 s 내부 반복기에는 해당 범주에 속하는 각 제품에 대 한 정보가 표시 됩니다 (그림 1 참조) 글머리 기호 목록에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="0b950-121">예제를 선언적으로 또는 프로그래밍 방식으로 내부 반복을 채우는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


<span data-ttu-id="0b950-122">[![해당 제품을 함께 각 범주에 나열 된](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="0b950-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span></span>

<span data-ttu-id="0b950-123">**그림 1**: 각 범주에서 제품을 함께 나열 됩니다 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="0b950-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-vb/_static/image3.png))</span></span>


## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="0b950-124">1 단계: 범주 목록 만들기</span><span class="sxs-lookup"><span data-stu-id="0b950-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="0b950-125">중첩 된 데이터 웹 컨트롤을 사용 하는 페이지를 작성 때 있습니까 디자인에 도움이 될, 작성 및 내부에 중첩된 된 컨트롤에 대 한도 걱정 하지 않고 먼저, 가장 바깥쪽 데이터 웹 컨트롤을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="0b950-126">따라서 이름 및 각 범주에 대 한 설명을 나열 하는 페이지에는 반복기를 추가 하는 데 필요한 단계를 검색 하 여 시작 s 사용 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="0b950-127">열어 시작는 `NestedControls.aspx` 페이지에 `DataListRepeaterBasics` 폴더 설정 페이지에 반복기 컨트롤을 추가 하 고 해당 `ID` 속성을 `CategoryList`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="0b950-128">반복기 s 스마트 태그에서 이라는 새 ObjectDataSource를 만들려고 선택한 `CategoriesDataSource`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>


<span data-ttu-id="0b950-129">[![새 ObjectDataSource CategoriesDataSource 이름](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="0b950-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span></span>

<span data-ttu-id="0b950-130">**그림 2**: 새 ObjectDataSource 이름을 `CategoriesDataSource` ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="0b950-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-vb/_static/image6.png))</span></span>


<span data-ttu-id="0b950-131">해당 데이터를 가져오는 되도록 구성 된 ObjectDataSource는 `CategoriesBLL` s 클래스 `GetCategories` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>


<span data-ttu-id="0b950-132">[![ObjectDataSource CategoriesBLL 클래스의 GetCategories 메서드를 사용 하도록 구성](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0b950-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span></span>

<span data-ttu-id="0b950-133">**그림 3**: 구성에 사용 하 여 ObjectDataSource는 `CategoriesBLL` s 클래스 `GetCategories` 메서드 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="0b950-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-vb/_static/image9.png))</span></span>


<span data-ttu-id="0b950-134">반복기 s 서식 파일을 지정 하려면 콘텐츠 해야 소스 보기로 이동 하 고 선언적 구문 직접 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="0b950-135">추가 `ItemTemplate` 에서 s 범주 이름을 표시 하는 `<h4>` 요소와 단락 요소에 있는 범주의 설명을 (`<p>`).</span><span class="sxs-lookup"><span data-stu-id="0b950-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="0b950-136">Let s 단락 구분선을 사용 하 여 각 범주를 구분 하는 또한 (`<hr>`).</span><span class="sxs-lookup"><span data-stu-id="0b950-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="0b950-137">이러한 변경을 수행한 후 페이지 반복기 및 ObjectDataSource 다음과 유사한 선언적 구문 형식으로 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample1.aspx)]

<span data-ttu-id="0b950-138">그림 4는 브라우저를 통해 볼 때 진행률을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-138">Figure 4 shows our progress when viewed through a browser.</span></span>


<span data-ttu-id="0b950-139">[![각 범주의 이름 및 설명을 나열 되어 구분 하 여 단락 구분선](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="0b950-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span></span>

<span data-ttu-id="0b950-140">**그림 4**: 각 범주 이름 및 설명을 나열 되어 단락 구분선으로 구분 된 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="0b950-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-vb/_static/image12.png))</span></span>


## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="0b950-141">2 단계: 중첩 된 제품 반복 추가</span><span class="sxs-lookup"><span data-stu-id="0b950-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="0b950-142">우리의 다음 작업은 완료 나열 범주와에 반복기를 추가 하는 `CategoryList` s `ItemTemplate` 적절 한 범주에 속한 제품에 대 한 정보를 표시 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="0b950-143">다양 한 방법으로이 내부 반복 곧 살펴보겠습니다 2 개에 대 한 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="0b950-144">지금은 let s 만들기만 반복기 제품 내에서 `CategoryList` 반복기의 `ItemTemplate`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="0b950-145">특히 사용 제품이 각 글머리 기호 목록에서 각 제품 목록 항목 가격과 s 제품 이름을 포함 하 여 반복기 표시 되어 s를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="0b950-146">내부 반복기 s 선언적 구문 및 서식 파일에 수동으로 입력 해야이 반복기를 만들려면는 `CategoryList` s `ItemTemplate`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="0b950-147">내에서 다음 태그를 추가 `CategoryList` 반복기의 `ItemTemplate`:</span><span class="sxs-lookup"><span data-stu-id="0b950-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="0b950-148">3 단계: ProductsByCategoryList 반복기에는 범주별 제품 바인딩</span><span class="sxs-lookup"><span data-stu-id="0b950-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="0b950-149">이 시점에서 브라우저를 통해 페이지를 방문 하면 화면이 표시 됩니다. 그림 4에서와 동일 하기 때문에 여기서 아직 모든 데이터에 바인딩할 반복기 했습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="0b950-150">적절 한 제품 레코드를 클릭 하 고 다른 항목 보다 좀 더 효율적으로 반복기에 바인딩할 수 있습니다는 몇 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="0b950-151">여기의 가장 큰 문제 발생 지정한 범주에 대 한 적절 한 제품입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="0b950-152">반복기 컨트롤 내부에 바인딩할 데이터 하거나 통해 액세스할 수 있습니다, 선언적에 ObjectDataSource는 `CategoryList` 반복기의 `ItemTemplate`, 또는 ASP.NET 페이지의 코드 숨김 페이지에서 프로그래밍 방식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="0b950-153">마찬가지로,이 데이터에 바인딩될 수 내부 반복 하거나 선언적으로-s 내부 반복을 통해 `DataSourceID` 속성 또는 선언적 데이터 바인딩의 구문을 사용 하거나 프로그래밍 방식으로 내부 반복기에서 참조 하 여는 `CategoryList` 반복기 s `ItemDataBound` 프로그래밍 방식으로 설정 하는 이벤트 처리기의 `DataSource` 속성과 호출 해당 `DataBind()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="0b950-154">이러한 방법 중 한 가지 탐색 s를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="0b950-155">ObjectDataSource 컨트롤을 사용 하 여 선언적으로 데이터에 액세스 하 고`ItemDataBound`이벤트 처리기</span><span class="sxs-lookup"><span data-stu-id="0b950-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="0b950-156">에서는 이후이 자습서 시리즈는 ObjectDataSource를 사용 하는이 예제에 대해 데이터에 액세스 하기 위한 가장 자연 스러운 선택 전체에서 광범위 하 게 ObjectDataSource을 사용한 적입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="0b950-157">`ProductsBLL` 클래스에는 `GetProductsByCategoryID(categoryID)` 지정 된에 속해 있는 해당 제품에 대 한 정보를 반환 하는 메서드  *`categoryID`* 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="0b950-158">따라서에 ObjectDataSource 추가할 수 있습니다는 `CategoryList` 반복기의 `ItemTemplate` 이 s 클래스 메서드에서 해당 데이터에 액세스 하도록 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="0b950-159">안타깝게도, 반복기 대상이 t 디자인 뷰를 통해 편집이 ObjectDataSource 컨트롤에 대 한 선언적 구문 직접 추가 해야 하므로 해당 서식 파일을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="0b950-160">에서는 다음 구문은 `CategoryList` 반복기 s `ItemTemplate` 이 새 ObjectDataSource를 추가한 후 (`ProductsByCategoryDataSource`):</span><span class="sxs-lookup"><span data-stu-id="0b950-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample3.aspx)]

<span data-ttu-id="0b950-161">설정 해야 ObjectDataSource 접근 방식을 사용 하는 경우는 `ProductsByCategoryList` 반복기 s `DataSourceID` 속성을는 `ID` 는 ObjectDataSource의 (`ProductsByCategoryDataSource`).</span><span class="sxs-lookup"><span data-stu-id="0b950-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="0b950-162">또한 구성 요소 개발자는 우리의 ObjectDataSource에는 `<asp:Parameter>` 지정 하는 요소는  *`categoryID`*  에 전달 되는 값은 `GetProductsByCategoryID(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="0b950-163">하지만이 값 어떻게 지정 우리?</span><span class="sxs-lookup"><span data-stu-id="0b950-163">But how do we specify this value?</span></span> <span data-ttu-id="0b950-164">이상적으로 d 것만 설정할 수는 `DefaultValue` 의 속성은 `<asp:Parameter>` databinding 구문을 사용 하 여 요소 같이:</span><span class="sxs-lookup"><span data-stu-id="0b950-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample4.aspx)]

<span data-ttu-id="0b950-165">안타깝게도, 데이터 바인딩 구문이 올바른지만 있는 컨트롤에는 `DataBinding` 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="0b950-166">`Parameter` 클래스에는 이러한 이벤트에 부족 하며 따라서 위의 구문 수행할 수 없습니다 런타임 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="0b950-167">이 값을 설정 하려면에 대 한 이벤트 처리기를 만들고 해야는 `CategoryList` 반복기의 `ItemDataBound` 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="0b950-168">이전에 설명한 대로 `ItemDataBound` 이벤트 반복기에 바인딩된 각 항목에 대해 한 번씩 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="0b950-169">따라서 외부 반복에 대해이 이벤트가 발생 될 때마다 수 지정 현재 `CategoryID` 값을 `ProductsByCategoryDataSource` ObjectDataSource의 `CategoryID` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="0b950-170">에 대 한 이벤트 처리기를 만들고는 `CategoryList` 반복기의 `ItemDataBound` 다음 코드를 사용 하 여 이벤트:</span><span class="sxs-lookup"><span data-stu-id="0b950-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample5.vb)]

<span data-ttu-id="0b950-171">이 이벤트 처리기는 머리글, 바닥글 또는 구분 기호 항목 대신 항목에서는 데이터 처리 다시 확인 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="0b950-172">다음으로 참조 하는 실제 `CategoriesRow` 현재 방금 바인딩된 인스턴스 `RepeaterItem`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="0b950-173">ObjectDataSource에서 참조 하는 마지막으로 `ItemTemplate` 할당 하 고 해당 `CategoryID` 매개 변수 값을는 `CategoryID` 현재 `RepeaterItem`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="0b950-174">이 이벤트 처리기는 `ProductsByCategoryList` 각 반복기 `RepeaterItem` 에서 해당 제품에 바인딩된는 `RepeaterItem`의 범주입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="0b950-175">그림 5는 결과 출력의 스크린샷입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-175">Figure 5 shows a screen shot of the resulting output.</span></span>


<span data-ttu-id="0b950-176">[![외부 반복; 각 범주를 나열합니다. 해당 범주에 대 한 제품을 나열 하는 내부](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="0b950-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span></span>

<span data-ttu-id="0b950-177">**그림 5**: 다음 외부 반복기 나열 각 범주; 내부 하나의 목록을 해당 범주에 대 한 제품 ([전체 크기 이미지를 보려면 클릭](nested-data-web-controls-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="0b950-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-vb/_static/image15.png))</span></span>


## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="0b950-178">제품 범주 데이터를 프로그래밍 방식으로 액세스</span><span class="sxs-lookup"><span data-stu-id="0b950-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="0b950-179">현재 범주에 대 한 제품을 검색 하는 ObjectDataSource를 사용 하는 대신 ASP.NET 페이지의 코드 숨김 클래스에 메서드를 만들 수 (또는 `App_Code` 폴더 또는 별도 클래스 라이브러리 프로젝트)의 적절 한 집합을 반환 하는 에 전달 될 때 제품은 `CategoryID`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="0b950-180">ASP.NET 페이지의 코드 숨김 클래스에서 이러한 메서드를 놓았습니다 한 이름이 였 `GetProductsInCategory(categoryID)`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="0b950-181">위치에서이 방법을 다음과 같은 선언 구문을 사용 하 여 내부 반복기에 현재 범주의 제품을 바인딩한 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="0b950-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample6.aspx)]

<span data-ttu-id="0b950-182">반복기 s `DataSource` 속성 구문이 사용 하 여 해당 데이터에서 제공 됨을 나타냅니다는 `GetProductsInCategory(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="0b950-183">이후 `Eval("CategoryID")` 형식의 값을 반환 `Object`, 개체를 캐스팅 우리는 `Integer` 에 전달 하기 전에 `GetProductsInCategory(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="0b950-184">`CategoryID` 여기에서 데이터 바인딩을 통해 구문은 액세스는 `CategoryID` 에 *외부* 반복기 (`CategoryList`), 한 s의 레코드에 바인딩된는 `Categories` 테이블 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="0b950-185">따라서 알고 있는 `CategoryID` 데이터베이스 일 수 없습니다 `NULL` 값이 때문에 맹목적으로 캐스팅할 수 있습니다는 `Eval` 있는지를 확인 하지 않고 메서드 다루는 다시 우리는 `DBNull`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="0b950-186">이 접근 방식에서는 만들어야 할는 `GetProductsInCategory(categoryID)` 메서드를 적절 한 집합이 제공 된 지정 된 제품 검색  *`categoryID`* 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="0b950-187">단순히 반환 하 여이 작업을 수행할 수 있습니다는 `ProductsDataTable` 에서 반환 되는 `ProductsBLL` s 클래스 `GetProductsByCategoryID(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="0b950-188">만들 s는 `GetProductsInCategory(categoryID)` 에 대 한 코드 숨김 클래스의 메서드에 우리의 `NestedControls.aspx` 페이지.</span><span class="sxs-lookup"><span data-stu-id="0b950-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="0b950-189">다음 코드를 사용 하 여 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-189">Do so using the following code:</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample7.vb)]

<span data-ttu-id="0b950-190">이 메서드는 단순히 인스턴스의 만듭니다는 `ProductsBLL` 메서드의 결과 반환 하 고는 `GetProductsByCategoryID(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="0b950-191">메서드를 표시 되어 수 `Public` 또는 `Protected`메서드가 표시 하는 경우 `Private`, ASP.NET 페이지 s 선언적 태그에서 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="0b950-192">이 새로운 기술을 사용 하려면 이러한 변경 내용을 적용할 후 브라우저를 통해 페이지를 보려면 잠시를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="0b950-193">ObjectDataSource에서 사용 하는 경우 출력을 출력에 동일 해야 하 고 `ItemDataBound` 이벤트 처리기 방법 (그림 5 스크린 샷을 보려면 다시 참조).</span><span class="sxs-lookup"><span data-stu-id="0b950-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="0b950-194">만들려는 busywork 보일 수는 `GetProductsInCategory(categoryID)` ASP.NET 페이지의 코드 숨김 클래스의 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="0b950-195">즉,이 메서드 인스턴스를 만들기만의 `ProductsBLL` 클래스의 결과 반환 하 고 해당 `GetProductsByCategoryID(categoryID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="0b950-196">왜만이 메서드를 호출 구문이 내부 반복기에서에서 직접 같은: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span><span class="sxs-lookup"><span data-stu-id="0b950-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span></span> <span data-ttu-id="0b950-197">이 구문은 성공한 t 작업의 현재 구현 하지만 `ProductsBLL` 클래스 (이후는 `GetProductsByCategoryID(categoryID)` 메서드는 인스턴스 메서드이므로), 수정할 수 있습니다 `ProductsBLL` 정적 포함 하도록 `GetProductsByCategoryID(categoryID)` 메서드 또는 정적 를포함하는클래스`Instance()` 의 새 인스턴스를 반환 하는 메서드는 `ProductsBLL` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-197">Although this syntax won t work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>


<span data-ttu-id="0b950-198">이러한 수정에 필요 하지는 동안는 `GetProductsInCategory(categoryID)` ASP.NET 페이지의 코드 숨김 클래스의 메서드를 코드 숨김 클래스의 메서드 있도록 보다 다양 하 게 볼 수 있겠지만, 곧 검색 데이터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="0b950-199">모든 제품 정보를 한 번에 검색</span><span class="sxs-lookup"><span data-stu-id="0b950-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="0b950-200">다음 두 가지 이전 기술에서는 검사 했습니다 호출 하 여 현재 범주에 대 한 해당 제품을 잡고는 `ProductsBLL` s 클래스 `GetProductsByCategoryID(categoryID)` 메서드 (첫 번째 방법인 것 이기 때문 ObjectDataSource를 통해 두 번째는 `GetProductsInCategory(categoryID)` 에서 메서드는 코드 숨김 클래스)입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="0b950-201">이 메서드를 호출할 때마다, 데이터 액세스 계층, 비즈니스 논리 계층 호출에서 행을 반환 하는 SQL 문 사용 하 여 데이터베이스 쿼리는 `Products` 갖는 테이블 `CategoryID` 필드에 제공 된 입력된 매개 변수와 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="0b950-202">지정 된 *N* 범주 시스템에이 방법은 네트워크 *N* + 모든 범주를 가져오려는 쿼리 한 데이터베이스에 대 한 1 호출 차례로 *N* 제품을 가져올 호출 각 범주 레이블을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="0b950-203">그러나 두 데이터베이스 호출 한 번의 호출 범주 및 제품을 모두 가져오려면 다른 모두 가져오려면 모든 필요한 데이터를 검색할 수, 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="0b950-204">이러한 제품 이므로 필터링 할 수 있는 모든 제품, 현재 일치 하는 제품에만 `CategoryID` s 해당 범주에 바인딩된 내부 반복기입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="0b950-205">이 기능을 제공 하려면만 하면 약간의 수정 된 `GetProductsInCategory(categoryID)` ASP.NET 페이지의 코드 숨김 클래스의 메서드.</span><span class="sxs-lookup"><span data-stu-id="0b950-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="0b950-206">맹목적으로의 결과 반환 하는 대신는 `ProductsBLL` s 클래스 `GetProductsByCategoryID(categoryID)` 메서드를 활용해 서 대신 처음으로 액세스 *모든* 제품 (t를 않은 경우 되었습니다 이미 액세스)의 필터링된 된 보기에만 다음 다시 돌아와 전달 된 기능에 제품 기반 `CategoryID`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven t been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample8.vb)]

<span data-ttu-id="0b950-207">페이지 수준 변수 추가 `allProducts`합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="0b950-208">모든 제품에 대 한 정보를 보유 하며, 처음으로 채워진는 `GetProductsInCategory(categoryID)` 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="0b950-209">확인 한 후의 `allProducts` 를 갖는 행만 DataTable의 결과 필터링 하는 메서드, 개체를 만들고 채울 `CategoryID` 지정 된 일치 `CategoryID` 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="0b950-210">이 방법은 데이터베이스에서 액세스 하는 횟수를 줄여 *N* 두 아래쪽으로 1을 더한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="0b950-211">이 향상 된이 기능 페이지의 렌더링 된 태그에 모든 변경 내용이 발생 하지 않도록 하거나 다른 방식에 비해 다시 더 적은 레코드 가져오기.</span><span class="sxs-lookup"><span data-stu-id="0b950-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="0b950-212">단순히 데이터베이스에 대 한 호출 수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="0b950-213">데이터베이스 액세스의 수를 줄이면 성능이 향상 제어 됩니다 직관적으로 이유 수 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="0b950-214">그러나이 아닐 경우.</span><span class="sxs-lookup"><span data-stu-id="0b950-214">However, this might not be the case.</span></span> <span data-ttu-id="0b950-215">제품의 많은 수 있는 경우 해당 `CategoryID` 은 `NULL`, 예, 다음에 대 한 호출에 대 한는 `GetProducts` 메서드 막대가 표시 되지 제품의 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="0b950-216">또한 모든 제품이 반환 될 수 있습니다 불필요 하는 경우만 페이징을 구현 하는 경우 대/소문자를 될 수 있는 범주의 하위 집합을 표시 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>


<span data-ttu-id="0b950-217">항상 그렇지는 있는 경우 두 가지 방법의 성능 분석, 제어 된 응용 프로그램 s 일반적인 사례 시나리오에 맞게 테스트를 실행 해만 surefire 측정값이입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="0b950-218">요약</span><span class="sxs-lookup"><span data-stu-id="0b950-218">Summary</span></span>

<span data-ttu-id="0b950-219">이 자습서에서는 살펴본 하나의 데이터 다른 내에서 웹 컨트롤을 중첩 하는 방법을 구체적으로 외부 반복기 글머리 기호 목록에서 각 범주에 대 한 제품을 나열 하는 내부 반복기와 각 범주에 대 한 항목을 표시 하는 방법을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="0b950-220">중첩 된 사용자 인터페이스를 빌드하는 가장 큰 문제에 액세스 하 고 내부 데이터 웹 컨트롤에 올바른 데이터를 바인딩 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="0b950-221">다양 한 방법 사용할 수 있는,이 자습서에서는 검사 했습니다 중 다음 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="0b950-222">검사 하는 첫 번째 방법은 웹 컨트롤 s 외부 데이터에는 ObjectDataSource를는 `ItemTemplate` 를 통해 내부 데이터 웹 컨트롤에 바인딩된 해당 `DataSourceID` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="0b950-223">ASP.NET 페이지의 코드 숨김 클래스의 메서드를 통해 데이터를 액세스 하는 두 번째 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="0b950-224">이 메서드는 내부 데이터의 웹 컨트롤에 바인딩할 수 다음 `DataSource` databinding 구문을 통해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="0b950-225">이 자습서에서 검사 하는 중첩 된 사용자 인터페이스는 반복기 내에 중첩 된 반복으로 사용 되지만 이러한 기술은 다른 데이터 웹 컨트롤을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="0b950-226">GridView 또는 DataList 내에서 GridView 내에서 반복기를 중첩할 수 있으며 등 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="0b950-227">만족도 매우 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="0b950-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="0b950-228">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="0b950-228">About the Author</span></span>

<span data-ttu-id="0b950-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적과의 창립자의 작성자 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 이후 Microsoft 웹 기술과 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0b950-230">Scott 독립 컨설턴트, 강사, 기술 및 작성기 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0b950-231">그의 최신 서적은 [ *Sam 업무량이 직접 ASP.NET 2.0 24 시간 동안에서*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0b950-232">에 연결할 수 그 [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) 에서 찾을 수 있는 그의 블로그를 통해 또는 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="0b950-233">특별히 감사</span><span class="sxs-lookup"><span data-stu-id="0b950-233">Special Thanks To</span></span>

<span data-ttu-id="0b950-234">이 자습서 시리즈 많은 유용한 검토자가 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-234">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0b950-235">이 자습서에 대 한 선행 검토자 Zack Jones 및 Liz Shulok 했습니다.</span><span class="sxs-lookup"><span data-stu-id="0b950-235">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="0b950-236">향후 내 MSDN 문서를 검토에 관심이 있으십니까?</span><span class="sxs-lookup"><span data-stu-id="0b950-236">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0b950-237">이 경우 drop me에 한 줄씩 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0b950-237">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
[<span data-ttu-id="0b950-238">이전</span><span class="sxs-lookup"><span data-stu-id="0b950-238">Previous</span></span>](showing-multiple-records-per-row-with-the-datalist-control-vb.md)
