---
title: gRPC 서비스와 HTTP API 비교
author: jamesnk
description: 시나리오는 gRPC 비교와 HTTP Api가 무엇을 권장 하는 방법에 대해 알아봅니다.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 03/31/2019
uid: grpc/comparison
ms.openlocfilehash: 0e9ef0e7ca8fb6d847b45f6dd7bd0aaa35fd149f
ms.sourcegitcommit: 948e533e02c2a7cb6175ada20b2c9cabb7786d0b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/10/2019
ms.locfileid: "59515671"
---
# <a name="comparing-grpc-services-with-http-apis"></a><span data-ttu-id="56c06-103">gRPC 서비스와 HTTP API 비교</span><span class="sxs-lookup"><span data-stu-id="56c06-103">Comparing gRPC services with HTTP APIs</span></span>

<span data-ttu-id="56c06-104">[James 뉴턴 King](https://twitter.com/jamesnk)</span><span class="sxs-lookup"><span data-stu-id="56c06-104">By [James Newton-King](https://twitter.com/jamesnk)</span></span>

<span data-ttu-id="56c06-105">이 문서에서는 설명 하는 방법 [gRPC services](https://grpc.io/docs/guides/) HTTP Api 비교할 (ASP.NET Core를 포함 하 여 [Web Api](xref: web-api/index)).</span><span class="sxs-lookup"><span data-stu-id="56c06-105">This article explains how [gRPC services](https://grpc.io/docs/guides/) compare to HTTP APIs (including ASP.NET Core [Web APIs](xref: web-api/index)).</span></span> <span data-ttu-id="56c06-106">앱에 대 한 API를 제공 하는 데 기술 중요 한 옵션 및 gRPC HTTP Api에 비해 특유의 이점을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-106">The technology used to provide an API for your app is an important choice, and gRPC offers unique benefits compared to HTTP APIs.</span></span> <span data-ttu-id="56c06-107">이 문서는 gRPC의 장단점을 설명 하 고 다른 기술을 통해 gRPC를 사용 하는 시나리오를 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-107">This article discusses the strengths and weaknesses of gRPC and recommends scenarios for using gRPC over other technologies.</span></span>

#### <a name="overview"></a><span data-ttu-id="56c06-108">개요</span><span class="sxs-lookup"><span data-stu-id="56c06-108">Overview</span></span>

|    <span data-ttu-id="56c06-109">기능</span><span class="sxs-lookup"><span data-stu-id="56c06-109">Feature</span></span>             |    <span data-ttu-id="56c06-110">gRPC</span><span class="sxs-lookup"><span data-stu-id="56c06-110">gRPC</span></span>                                                 |    <span data-ttu-id="56c06-111">JSON 사용 하 여 HTTP Api</span><span class="sxs-lookup"><span data-stu-id="56c06-111">HTTP APIs with JSON</span></span>                       |
|------------------------|---------------------------------------------------------|----------------------------------------------|
|    <span data-ttu-id="56c06-112">계약</span><span class="sxs-lookup"><span data-stu-id="56c06-112">Contract</span></span>            |    <span data-ttu-id="56c06-113">필요한 (`*.proto`)</span><span class="sxs-lookup"><span data-stu-id="56c06-113">Required (`*.proto`)</span></span>                                 |    <span data-ttu-id="56c06-114">선택 사항 (OpenAPI)</span><span class="sxs-lookup"><span data-stu-id="56c06-114">Optional (OpenAPI)</span></span>                        |
|    <span data-ttu-id="56c06-115">전송</span><span class="sxs-lookup"><span data-stu-id="56c06-115">Transport</span></span>           |    <span data-ttu-id="56c06-116">HTTP/2</span><span class="sxs-lookup"><span data-stu-id="56c06-116">HTTP/2</span></span>                                               |    <span data-ttu-id="56c06-117">HTTP</span><span class="sxs-lookup"><span data-stu-id="56c06-117">HTTP</span></span>                                      |
|    <span data-ttu-id="56c06-118">Payload</span><span class="sxs-lookup"><span data-stu-id="56c06-118">Payload</span></span>             |    [<span data-ttu-id="56c06-119">Protobuf (작은 이진)</span><span class="sxs-lookup"><span data-stu-id="56c06-119">Protobuf (small, binary)</span></span>](#performance)             |    <span data-ttu-id="56c06-120">JSON (대형 사람이 읽을 수 있음)</span><span class="sxs-lookup"><span data-stu-id="56c06-120">JSON (large, human readable)</span></span>              |
|    <span data-ttu-id="56c06-121">Prescriptiveness</span><span class="sxs-lookup"><span data-stu-id="56c06-121">Prescriptiveness</span></span>    |    [<span data-ttu-id="56c06-122">엄격한 사양</span><span class="sxs-lookup"><span data-stu-id="56c06-122">Strict specification</span></span>](#strict-specification)        |    <span data-ttu-id="56c06-123">사용 완화 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-123">Loose.</span></span> <span data-ttu-id="56c06-124">모든 HTTP 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-124">Any HTTP is valid</span></span>                  |
|    <span data-ttu-id="56c06-125">스트리밍</span><span class="sxs-lookup"><span data-stu-id="56c06-125">Streaming</span></span>           |    [<span data-ttu-id="56c06-126">클라이언트, 서버, 양방향</span><span class="sxs-lookup"><span data-stu-id="56c06-126">Client, server, bi-directional</span></span>](#streaming)         |    <span data-ttu-id="56c06-127">클라이언트, 서버</span><span class="sxs-lookup"><span data-stu-id="56c06-127">Client, server</span></span>                            |
|    <span data-ttu-id="56c06-128">브라우저 지원</span><span class="sxs-lookup"><span data-stu-id="56c06-128">Browser support</span></span>     |    [<span data-ttu-id="56c06-129">아니요 (grpc 웹 필요)</span><span class="sxs-lookup"><span data-stu-id="56c06-129">No (requires grpc-web)</span></span>](#limited-browser-support)   |    <span data-ttu-id="56c06-130">예</span><span class="sxs-lookup"><span data-stu-id="56c06-130">Yes</span></span>                                       |
|    <span data-ttu-id="56c06-131">보안</span><span class="sxs-lookup"><span data-stu-id="56c06-131">Security</span></span>            |    <span data-ttu-id="56c06-132">전송 (HTTPS)</span><span class="sxs-lookup"><span data-stu-id="56c06-132">Transport (HTTPS)</span></span>                                    |    <span data-ttu-id="56c06-133">전송 (HTTPS)</span><span class="sxs-lookup"><span data-stu-id="56c06-133">Transport (HTTPS)</span></span>                         |
|    <span data-ttu-id="56c06-134">클라이언트 코드 생성</span><span class="sxs-lookup"><span data-stu-id="56c06-134">Client code-gen</span></span>     |    [<span data-ttu-id="56c06-135">예</span><span class="sxs-lookup"><span data-stu-id="56c06-135">Yes</span></span>](#code-generation)                              |    <span data-ttu-id="56c06-136">OpenAPI + 타사 도구</span><span class="sxs-lookup"><span data-stu-id="56c06-136">OpenAPI + third-party tooling</span></span>             |

## <a name="grpc-strengths"></a><span data-ttu-id="56c06-137">gRPC 장점</span><span class="sxs-lookup"><span data-stu-id="56c06-137">gRPC strengths</span></span>

### <a name="performance"></a><span data-ttu-id="56c06-138">성능</span><span class="sxs-lookup"><span data-stu-id="56c06-138">Performance</span></span>

<span data-ttu-id="56c06-139">gRPC 메시지를 사용 하 여 serialize 할 [Protobuf](https://developers.google.com/protocol-buffers/docs/overview)는 효율적인 이진 메시지 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-139">gRPC messages are serialized using [Protobuf](https://developers.google.com/protocol-buffers/docs/overview), an efficient binary message format.</span></span> <span data-ttu-id="56c06-140">서버와 클라이언트에서 Protobuf를 매우 신속 하 게 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-140">Protobuf serializes very quickly on the server and client.</span></span> <span data-ttu-id="56c06-141">Protobuf serialization을 대역폭이 제한 된 시나리오에서 중요 한 작은 메시지 페이로드를 사용 하면 모바일 앱을 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-141">Protobuf serialization results in small message payloads, important in limited bandwidth scenarios like mobile apps.</span></span>

<span data-ttu-id="56c06-142">gRPC는 HTTP/2, HTTP를 통해 뛰어난 성능을 제공 하는 HTTP의 주요 수정 버전을 위한 1.x:</span><span class="sxs-lookup"><span data-stu-id="56c06-142">gRPC is designed for HTTP/2, a major revision of HTTP that provides significant performance benefits over HTTP 1.x:</span></span>

* <span data-ttu-id="56c06-143">이진 프레이밍 및 압축 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-143">Binary framing and compression.</span></span> <span data-ttu-id="56c06-144">HTTP/2 프로토콜은 간단 하 고 보내기 및 받기 모두 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-144">HTTP/2 protocol is compact and efficient both in sending and receiving.</span></span>
* <span data-ttu-id="56c06-145">여러 HTTP/2 호출의 단일 TCP 연결을 통해 멀티플렉싱 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-145">Multiplexing of multiple HTTP/2 calls over a single TCP connection.</span></span> <span data-ttu-id="56c06-146">제거 멀티플렉싱 [head 아웃오브 라인 차단](https://en.wikipedia.org/wiki/Head-of-line_blocking)합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-146">Multiplexing eliminates [head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking).</span></span>

### <a name="code-generation"></a><span data-ttu-id="56c06-147">코드 생성</span><span class="sxs-lookup"><span data-stu-id="56c06-147">Code generation</span></span>

<span data-ttu-id="56c06-148">모든 gRPC 프레임 워크에는 코드 생성에 대 한 최고 수준의 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-148">All gRPC frameworks provide first-class support for code generation.</span></span> <span data-ttu-id="56c06-149">GRPC 개발 하는 핵심 파일은는 [ `*.proto` 파일](https://developers.google.com/protocol-buffers/docs/proto3), gRPC 서비스 및 메시지 계약을 정의 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-149">A core file to gRPC development is the [`*.proto` file](https://developers.google.com/protocol-buffers/docs/proto3), which defines the contract of gRPC services and messages.</span></span> <span data-ttu-id="56c06-150">프레임 워크 코드는이 파일 gRPC에서 서비스 기본 클래스, 메시지 및 전체 클라이언트를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-150">From this file gRPC frameworks will code generate a service base class, messages, and a complete client.</span></span>

<span data-ttu-id="56c06-151">공유는 `*.proto` 간 끝에서 서버 및 클라이언트, 메시지 및 클라이언트 코드 간에 파일을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-151">By sharing the `*.proto` file between the server and client, messages and client code can be generated from end to end.</span></span> <span data-ttu-id="56c06-152">클라이언트의 코드 생성 클라이언트와 서버에서 메시지 중복 제거 및 수에 대 한 강력한 형식의 클라이언트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-152">Code generation of the client eliminates duplication of messages on the client and server, and creates a strongly-typed client for you.</span></span> <span data-ttu-id="56c06-153">클라이언트를 작성 하지 않아도 많은 서비스를 사용 하 여 응용 프로그램에서 상당한 개발 시간을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-153">Not having to write a client saves significant development time in applications with many services.</span></span>

### <a name="strict-specification"></a><span data-ttu-id="56c06-154">엄격한 사양</span><span class="sxs-lookup"><span data-stu-id="56c06-154">Strict specification</span></span>

<span data-ttu-id="56c06-155">JSON 사용 하 여 HTTP API에 대 한 공식 사양 존재 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-155">A formal specification for HTTP API with JSON doesn't exist.</span></span> <span data-ttu-id="56c06-156">개발자가 Url 중 가장 적절 한 형식을 논의 HTTP 동사와 응답 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-156">Developers debate the best format of URLs, HTTP verbs, and response codes.</span></span>

<span data-ttu-id="56c06-157">합니다 [gRPC 사양](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) gRPC 서비스 따라야 하는 형식에 대 한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-157">The [gRPC specification](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) is prescriptive about the format a gRPC service must follow.</span></span> <span data-ttu-id="56c06-158">gRPC는 논쟁을 제거 하 고 gPRC 플랫폼 구현 간에 일관 된 이므로 개발자 시간을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-158">gRPC eliminates debate and saves developer time because gPRC is consistent across platforms and implementations.</span></span>

### <a name="streaming"></a><span data-ttu-id="56c06-159">스트리밍</span><span class="sxs-lookup"><span data-stu-id="56c06-159">Streaming</span></span>

<span data-ttu-id="56c06-160">HTTP/2 오랫동안 지속 되는 실시간 통신 스트림을 위한 기초를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-160">HTTP/2 provides a foundation for long-lived, real-time communication streams.</span></span> <span data-ttu-id="56c06-161">gRPC는 HTTP/2를 통해 스트리밍에 대 한 최고 수준의 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-161">gRPC provides first-class support for streaming through HTTP/2.</span></span>

<span data-ttu-id="56c06-162">GRPC 서비스에서는 모든 스트리밍 조합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-162">A gRPC service supports all streaming combinations:</span></span>

* <span data-ttu-id="56c06-163">단항 (스트리밍 없음)</span><span class="sxs-lookup"><span data-stu-id="56c06-163">Unary (no streaming)</span></span>
* <span data-ttu-id="56c06-164">서버에서 클라이언트로 스트리밍</span><span class="sxs-lookup"><span data-stu-id="56c06-164">Server to client streaming</span></span>
* <span data-ttu-id="56c06-165">스트리밍 서버는 클라이언트</span><span class="sxs-lookup"><span data-stu-id="56c06-165">Client to server streaming</span></span>
* <span data-ttu-id="56c06-166">양방향 스트리밍</span><span class="sxs-lookup"><span data-stu-id="56c06-166">Bi-directional streaming</span></span>

### <a name="deadlinetimeouts-and-cancellation"></a><span data-ttu-id="56c06-167">마감 날짜/시간 제한 및 취소</span><span class="sxs-lookup"><span data-stu-id="56c06-167">Deadline/timeouts and cancellation</span></span>

<span data-ttu-id="56c06-168">gRPC 기간는 완료 하는 RPC 대기를 지정 하는 클라이언트를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-168">gRPC allows clients to specify how long they are willing to wait for an RPC to complete.</span></span> <span data-ttu-id="56c06-169">합니다 [최종 기한](https://grpc.io/blog/deadlines) 서버로 보내지는 서버 최종 기한 초과 하는 경우에 수행할 동작을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-169">The [deadline](https://grpc.io/blog/deadlines) is sent to the server, and the server can decide what action to take if it exceeds the deadline.</span></span> <span data-ttu-id="56c06-170">예를 들어 서버 진행 gRPC/HTTP/데이터베이스 요청 시간 초과 시 취소 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-170">For example, the server might cancel in-progress gRPC/HTTP/database requests on timeout.</span></span>

<span data-ttu-id="56c06-171">호출을 마감일 및 자식 gRPC 통해 취소 전파 리소스 사용량 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-171">Propagating the deadline and cancellation through child gRPC calls helps enforce resource usage limits.</span></span>

## <a name="grpc-recommended-scenarios"></a><span data-ttu-id="56c06-172">gRPC 시나리오를 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-172">gRPC recommended scenarios</span></span>

<span data-ttu-id="56c06-173">gRPC는 다음과 같은 시나리오에 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-173">gRPC is well suited to the following scenarios:</span></span>

* <span data-ttu-id="56c06-174">**마이크로 서비스** &ndash; gRPC가 설계 된 짧은 대기 시간과 높은 처리량의 통신이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-174">**Microservices** &ndash; gRPC is designed low latency and high throughput communication.</span></span> <span data-ttu-id="56c06-175">gRPC는 간단한 마이크로 서비스에 대 한 훌륭한 효율성 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-175">gRPC is great for lightweight microservices where efficiency is critical.</span></span>
* <span data-ttu-id="56c06-176">**실시간 간 통신과** &ndash; gRPC가 양방향 스트리밍에 대 한 지원.</span><span class="sxs-lookup"><span data-stu-id="56c06-176">**Point-to-point real-time communication** &ndash; gRPC has excellent support for bi-directional streaming.</span></span> <span data-ttu-id="56c06-177">gRPC 서비스에 푸시할 수 메시지 폴링 없이 실시간.</span><span class="sxs-lookup"><span data-stu-id="56c06-177">gRPC services can push messages in real-time without polling.</span></span>
* <span data-ttu-id="56c06-178">**Polygot 환경** &ndash; gRPC 도구에서 만드는 gRPC 다중 언어 환경에 적합 한 모든 주요 개발 언어를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-178">**Polygot environments** &ndash; gRPC tooling supports all popular development languages, making gRPC a good choice for multi-language environments.</span></span>
* <span data-ttu-id="56c06-179">**네트워크 제한 된 환경** &ndash; gRPC 메시지 Protobuf를 간단한 메시지 형식으로 serialize 됩니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-179">**Network constrained environments** &ndash; gRPC messages are serialized with Protobuf, a lightweight message format.</span></span> <span data-ttu-id="56c06-180">GRPC 메시지에 해당 하는 JSON 메시지 보다 항상 작습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-180">A gRPC message is always smaller than an equivalent JSON message.</span></span>

## <a name="grpc-weaknesses"></a><span data-ttu-id="56c06-181">gRPC 단점</span><span class="sxs-lookup"><span data-stu-id="56c06-181">gRPC weaknesses</span></span>

### <a name="limited-browser-support"></a><span data-ttu-id="56c06-182">제한 된 브라우저 지원</span><span class="sxs-lookup"><span data-stu-id="56c06-182">Limited browser support</span></span>

<span data-ttu-id="56c06-183">현재 브라우저에서 gRPC 서비스를 직접 호출 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-183">It's impossible to directly call a gRPC service from a browser today.</span></span> <span data-ttu-id="56c06-184">gRPC HTTP/2 기능을 많이 사용 하 고 브라우저 없음 수준의 gRPC 클라이언트를 지원 하기 위해 웹 요청 동안 필요한 제어를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-184">gRPC heavily uses HTTP/2 features and no browser provides the level of control required over web requests to support a gRPC client.</span></span> <span data-ttu-id="56c06-185">예를 들어 브라우저 허용 하거나 하지 않으면 호출자는 HTTP/2 사용할 필요에 기본 HTTP/2 프레임에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-185">For example, browsers do not allow a caller to require that HTTP/2 be used, or provide access to underlying HTTP/2 frames.</span></span>

<span data-ttu-id="56c06-186">[gRPC 웹](https://grpc.io/docs/tutorials/basic/web.html) 는 브라우저에서 제한 된 gRPC 지원을 제공 하는 gRPC 팀에서 추가 기술 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-186">[gRPC-Web](https://grpc.io/docs/tutorials/basic/web.html) is an additional technology from the gRPC team that provides limited gRPC support in the browser.</span></span> <span data-ttu-id="56c06-187">gRPC 웹 두 부분으로 구성 됩니다: 모든 최신 브라우저 및 gRPC 웹 프록시 서버에서 지 원하는 JavaScript 클라이언트입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-187">gRPC-Web consists of two parts: a JavaScript client that supports all modern browsers, and a gRPC-Web proxy on the server.</span></span> <span data-ttu-id="56c06-188">GRPC 웹 클라이언트 프록시를 호출 하 고 프록시 gRPC 서버로 gRPC 요청에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-188">The gRPC-Web client calls the proxy and the proxy will forward on the gRPC requests to the gRPC server.</span></span>

<span data-ttu-id="56c06-189">GRPC의 기능 중 일부만 gRPC 웹에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-189">Not all of gRPC's features are supported by gRPC-Web.</span></span> <span data-ttu-id="56c06-190">클라이언트와 양방향 스트리밍 지원 되지 않습니다 및 스트리밍 서버에 대 한 지원은 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-190">Client and bi-directional streaming isn't supported, and there is limited support for server streaming.</span></span>

### <a name="not-human-readable"></a><span data-ttu-id="56c06-191">하지 사람이 읽을 수 있음</span><span class="sxs-lookup"><span data-stu-id="56c06-191">Not human readable</span></span>

<span data-ttu-id="56c06-192">HTTP API 요청 텍스트로 전송 됩니다 및 읽고 사람이 만든 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-192">HTTP API requests are sent as text and can be read and created by humans.</span></span>

<span data-ttu-id="56c06-193">기본적으로 gRPC 메시지 Protobuf를 사용 하 여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-193">gRPC messages are encoded with Protobuf by default.</span></span> <span data-ttu-id="56c06-194">Protobuf를 받고 보내는 데 효율적인 이진 형식으로 아닙니다 사람이 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-194">While Protobuf is efficient to send and receive, its binary format isn't human readable.</span></span> <span data-ttu-id="56c06-195">Protobuf에 지정 된 메시지의 인터페이스 설명이 필요 합니다 `*.proto` 파일을 제대로 deserialize 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-195">Protobuf requires the message's interface description specified in the `*.proto` file to properly deserialize.</span></span> <span data-ttu-id="56c06-196">추가 도구는 통신 중에 Protobuf 페이로드를 분석 하 고 요청을 직접 작성할 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-196">Additional tooling is required to analyze Protobuf payloads on the wire and to compose requests by hand.</span></span>

<span data-ttu-id="56c06-197">같은 기능 [server 리플렉션](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md) 하며 [gRPC 명령줄 도구](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md) 이진 Protobuf 메시지 지원 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-197">Features such as [server reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md) and the [gRPC command line tool](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md) exist to assist with binary Protobuf messages.</span></span> <span data-ttu-id="56c06-198">또한 Protobuf 메시지 지원 [JSON 변환을](https://developers.google.com/protocol-buffers/docs/proto3#json)입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-198">Also, Protobuf messages support [conversion to and from JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).</span></span> <span data-ttu-id="56c06-199">기본 제공 JSON 변환을 디버깅할 때와 사람이 읽을 수 있는 형식에서 Protobuf 메시지를 변환 하는 효율적인 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-199">The built-in JSON conversion provides an efficient way to convert Protobuf messages to and from human readable form when debugging.</span></span>

## <a name="alternative-framework-scenarios"></a><span data-ttu-id="56c06-200">대체 framework 시나리오</span><span class="sxs-lookup"><span data-stu-id="56c06-200">Alternative framework scenarios</span></span>

<span data-ttu-id="56c06-201">다음 시나리오에서 gRPC를 통해 다른 프레임 워크를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-201">Other frameworks are recommended over gRPC in the following scenarios:</span></span>

* <span data-ttu-id="56c06-202">**액세스할 Api 브라우저** &ndash; gRPC 브라우저에서 완전히 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-202">**Browser accessible APIs** &ndash; gRPC isn't fully supported in the browser.</span></span> <span data-ttu-id="56c06-203">gRPC 웹 브라우저 지원에 제공할 수 있지만 제한이 서버 프록시를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-203">gRPC-Web can offer browser support, but it has limitations and introduces a server proxy.</span></span>
* <span data-ttu-id="56c06-204">**실시간 통신 브로드캐스트** &ndash; gRPC, 스트리밍을 통해 실시간 통신을 지원 하지만 등록 된 연결에 out 메시지를 브로드캐스팅하 개념이 존재 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-204">**Broadcast real-time communication** &ndash; gRPC supports real-time communication via streaming, but the concept of broadcasting a message out to registered connections doesn't exist.</span></span> <span data-ttu-id="56c06-205">예를 들어 대화방의 모든 클라이언트에 새 채팅 메시지를 보낼 위치 대화방 시나리오에서는 각 gRPC 호출 해야 클라이언트에 새 채팅 메시지를 개별적으로 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-205">For example in a chat room scenario where new chat messages should be sent to all clients in the chat room, each gRPC call is required to individually stream new chat messages to the client.</span></span> <span data-ttu-id="56c06-206">[SignalR](xref:signalr/introduction) 은이 시나리오에 대 한 유용한 프레임 워크입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-206">[SignalR](xref:signalr/introduction) is a useful framework for this scenario.</span></span> <span data-ttu-id="56c06-207">SignalR 영구 연결 및 브로드캐스트 메시지에 대 한 기본 제공 지원의 개념을 있습니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-207">SignalR has the concept of persistent connections and built-in support for broadcasting messages.</span></span>
* <span data-ttu-id="56c06-208">**프로세스 간 통신** &ndash; 프로세스 들어오는 gRPC 호출을 수락 하기 위해 HTTP/2 서버를 호스트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-208">**Inter-process communication** &ndash; A process must host an HTTP/2 server to accept incoming gRPC calls.</span></span> <span data-ttu-id="56c06-209">Windows에 대 한 프로세스 간 통신 [파이프](/dotnet/standard/io/pipe-operations) 통신의 빠르고 간단한 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="56c06-209">For Windows, inter-process communication [pipes](/dotnet/standard/io/pipe-operations) is a fast, lightweight method of communication.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="56c06-210">추가 자료</span><span class="sxs-lookup"><span data-stu-id="56c06-210">Additional resources</span></span>

* <xref:tutorials/grpc/grpc-start>
* <xref:grpc/index>
* <xref:grpc/basics>
* <xref:grpc/migration>
