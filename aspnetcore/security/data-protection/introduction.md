---
title: ASP.NET Core 데이터 보호
author: rick-anderson
description: 데이터 보호의 개념 및 ASP.NET Core 데이터 보호 Api의 디자인 원칙을 알아봅니다.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/introduction
ms.openlocfilehash: a49eee89e8c11b26c76ba167215c141482159933
ms.sourcegitcommit: c684eb6c0999d11d19e15e65939e5c7f99ba47df
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/19/2018
ms.locfileid: "46292299"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="f563c-103">ASP.NET Core 데이터 보호</span><span class="sxs-lookup"><span data-stu-id="f563c-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="f563c-104">종종 웹 응용 프로그램 보안에 민감한 데이터를 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="f563c-105">Windows 데스크톱 응용 프로그램에 대 한 DPAPI를 제공 하지만이 웹 응용 프로그램에 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="f563c-106">ASP.NET Core 데이터 보호 스택이 개발자 키 관리 등 회전 하는 데이터를 보호 하 여 간단 하 고 사용 하기 쉬운 암호화 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="f563c-107">ASP.NET Core 데이터 보호 스택이을 장기 대체 제공 하도록 설계 되었기 합니다 &lt;machineKey&gt; 요소 asp.net에서 1.x-4.x 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="f563c-108">기존 암호화 스택의 많은 단점을 해결하는 한편, 현대적인 응용 프로그램에서 접할 수 있는 대부분의 사용 사례에 즉각적으로 대응할 수 있는 솔루션을 제공하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="f563c-109">문제 설명</span><span class="sxs-lookup"><span data-stu-id="f563c-109">Problem statement</span></span>

<span data-ttu-id="f563c-110">전체적인 문제를 다음 한 문장으로 간단 명료하게 정리할 수 있습니다: 나중에 검색에 대 한 신뢰할 수 있는 정보를 유지 해야 하지만 지 속성 메커니즘이 신뢰 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="f563c-111">웹의 관점에서 다시 말하자면 "신뢰할 수 있는 상태를 신뢰할 수 없는 클라이언트를 통해서 왕복해야(Round-Trip) 한다"고 할 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="f563c-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="f563c-112">대표적인 사례가 인증 쿠키나 전달자 토큰(Bearer Token)의 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="f563c-113">서버가 "나는 Groot고 xyz 권한을 갖고 있다"라는 토큰을 생성해서 클라이언트로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="f563c-114">이후 특정 시점에 클라이언트가 다시 서버로 해당 토큰을 제출하지만 서버로서는 클라이언트가 해당 토큰을 변조하지 않았다는 어떤한 보장이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="f563c-115">따라서 필요한 첫 번째 요건은 신뢰성(Authenticity)입니다(무결성(Integrity)</span><span class="sxs-lookup"><span data-stu-id="f563c-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="f563c-116">또는 변조 방지(Tamper-Proofing)하고도 합니다).</span><span class="sxs-lookup"><span data-stu-id="f563c-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="f563c-117">그리고 저장된 상태(정보)를 신뢰하는 주체는 서버이므로, 이 상태에 운영 환경 고유의 정보가 포함되어 있을 수도 있음을 예상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="f563c-118">이 정보는 파일 경로, 권한, 핸들 혹은 그 밖의 간접 참조, 또는 서버 고유의 데이터 중 일부 같은 형태를 갖출 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="f563c-119">일반적으로 이런 정보들은 신뢰할 수 없는 클라이언트에게는 공개되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="f563c-120">따라서 필요한 두 번째 요건은 기밀성(Confidentiality)입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="f563c-121">마지막으로 현대적 응용 프로그램은 구성 요소를 기반으로 구축되므로 각 개별 구성 요소는 시스템의 다른 구성 요소들과 관계없이 이 시스템(데이터 보호 스택)을 활용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="f563c-122">예를 들어, 전달자 토큰 구성 요소가 데이터 보호 스택을 사용한다면 역시 같은 스택을 사용하는 CSRF 방지 메커니즘의 간섭없이 동작할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="f563c-123">따라서 필요한 마지막 요건은 격리(Isolation)입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="f563c-124">더 많은 제약 조건을 규정해서 필요 요건의 범위를 좁힐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="f563c-125">암호화 시스템 내에서 동작하는 모든 서비스를 동등하게 신뢰할 수 있으며, 직접 제어하는 서비스 외부에서 데이터가 생성되거나 사용될 필요가 없다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="f563c-126">또한, 웹 서비스에 대한 각 요청이 암호화 시스템을 여러 번 거칠 수도 있기 때문에 최대한 빠르게 작업을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="f563c-127">결론적으로 이런 시나리오에는 대칭 암호화가 적합하며, 필요해질 때까지 비대칭 암호화에 대해서는 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="f563c-128">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="f563c-128">Design philosophy</span></span>

<span data-ttu-id="f563c-129">먼저 우리는 기존 스택과 관련된 문제점을 확인하는 작업에 착수했습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="f563c-130">이 작업을 마치고 기존 솔루션의 현황을 조사해본 결과, 기존 솔루션에는 원하는 기능들이 전혀 존재하지 않는다는 결론을 내렸습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="f563c-131">이후, 다음과 같은 몇 가지 기본 원칙에 따라 솔루션을 설계했습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="f563c-132">시스템 구성 방식이 간단해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="f563c-133">이상적으로는 특별히 시스템을 구성하지 않고도(Zero-Configuration) 개발자들이 작업하는 데 전혀 지장이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="f563c-134">개발자가 특정 측면(예: 키 저장소)을 구성해야 할 경우, 해당 특정 구성을 간단히 처리할 수 있는 방법이 제공되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="f563c-135">간단한 소비자 지향적인 API를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="f563c-136">이 API는 올바르게 사용하기는 쉽고 잘못 사용하기는 어려워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="f563c-137">개발자는 키 관리 하기 위한 원칙을 알아봅니다 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="f563c-138">알고리즘 선택 및 개발자를 대신해 키 수명 시스템 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="f563c-139">이상적으로 개발자 원시 키 자료에 액세스를 해야 적입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="f563c-140">가능한 경우 미사용 키를 보호 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="f563c-141">시스템에서는 적절 한 기본 보호 메커니즘을 파악 하 고 자동으로 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="f563c-142">단순 하 고 염두에서 이러한 원칙을 사용 하 여 개발할 [사용 하기 쉬운](xref:security/data-protection/using-data-protection) 데이터 보호 스택이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="f563c-143">ASP.NET Core 데이터 보호 Api는 하지 주로 기밀 페이로드 무기한 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="f563c-144">와 같은 다른 기술이 [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) 하 고 [Azure Rights Management](https://docs.microsoft.com/rights-management/) 무기한 저장 하는 시나리오에 보다 적합 한 마찬가지로 강력한 키 관리 기능을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](https://docs.microsoft.com/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="f563c-145">즉, ASP.NET Core 데이터 보호 Api를 사용 하 여 기밀 데이터의 장기 보호에 대 한 개발자를 금지 하는 항목이 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="f563c-146">대상 사용자</span><span class="sxs-lookup"><span data-stu-id="f563c-146">Audience</span></span>

<span data-ttu-id="f563c-147">데이터 보호 시스템 5 주 패키지도 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="f563c-148">이러한 Api의 다양 한 측면에는 세 가지 주요 대상; 대상</span><span class="sxs-lookup"><span data-stu-id="f563c-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="f563c-149">합니다 [소비자 Api 개요](xref:security/data-protection/consumer-apis/overview) 응용 프로그램 및 프레임 워크 개발자 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="f563c-150">"스택에서 작동 하는 방법에 대 한 또는 구성 하는 방법에 대 한 자세한 내용을 알아보려면 원하는 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="f563c-151">간단히 수행 하려는 일부 작업에서 간단한 방식으로 최대한 성공적으로 Api를 사용 하 여 높은 확률을 사용 하 여. "</span><span class="sxs-lookup"><span data-stu-id="f563c-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="f563c-152">합니다 [구성 Api](xref:security/data-protection/configuration/overview) 응용 프로그램 개발자 및 시스템 관리자를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="f563c-153">"내 환경에 필요한 기본이 아닌 경로 또는 설정을 데이터 보호 시스템에 알릴 하고자 합니다."</span><span class="sxs-lookup"><span data-stu-id="f563c-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="f563c-154">확장성 Api 대상 개발자가 사용자 지정 정책을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="f563c-155">이러한 Api에 드문 경우로 제한 되 고 보안 인식 개발자가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="f563c-156">"해야 진정으로 고유한 동작 요구 사항 때문에 시스템 내에서 전체 구성 요소를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="f563c-157">의사가 내 요구 사항을 충족 하는 플러그 인을 빌드하려면 드물게 사용 되는 부분 API 화면에 알아봅니다. "</span><span class="sxs-lookup"><span data-stu-id="f563c-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="f563c-158">패키지 레이아웃</span><span class="sxs-lookup"><span data-stu-id="f563c-158">Package layout</span></span>

<span data-ttu-id="f563c-159">데이터 보호 스택이 다섯 개의 패키지로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="f563c-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) 포함 된 <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> 및 <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> 데이터 보호 서비스를 만들기 위한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) contains the <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> and <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> interfaces to create data protection services.</span></span> <span data-ttu-id="f563c-161">또한 이러한 형식을 사용 하기 위한 유용한 확장 메서드 포함 (예를 들어 [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span><span class="sxs-lookup"><span data-stu-id="f563c-161">It also contains useful extension methods for working with these types (for example, [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span></span> <span data-ttu-id="f563c-162">데이터 보호 시스템을 다른 곳에서 인스턴스화될 API를 사용 하는 경우 참조 `Microsoft.AspNetCore.DataProtection.Abstractions`합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-162">If the data protection system is instantiated elsewhere and you're consuming the API, reference `Microsoft.AspNetCore.DataProtection.Abstractions`.</span></span>

* <span data-ttu-id="f563c-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) 핵심 암호화 작업, 키 관리, 구성 및 확장성을 포함 하 여 데이터 보호 시스템의 핵심 구현은 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) contains the core implementation of the data protection system, including core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="f563c-164">데이터 보호 시스템을 인스턴스화하기 위해 (예를 들어, 추가 하는 <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) 또는 참조를 수정 하거나 해당 동작 확장 `Microsoft.AspNetCore.DataProtection`합니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-164">To instantiate the data protection system (for example, adding it to an <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) or modifying or extending its behavior, reference `Microsoft.AspNetCore.DataProtection`.</span></span>

* <span data-ttu-id="f563c-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) -개발자가 유용 하지만 코어 패키지에 속하지 않는 추가 Api가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="f563c-166">이 패키지에서 종속성 주입 하지 않고 파일 시스템 위치에 키를 저장 하는 데이터 보호 시스템을 인스턴스화하기 위해 팩터리 메서드를 포함 하는 예를 들어 (참조 <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span><span class="sxs-lookup"><span data-stu-id="f563c-166">For instance, this package contains factory methods to instantiate the data protection system to store keys at a location on the file system without dependency injection (see <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span></span> <span data-ttu-id="f563c-167">또한 보호 된 페이로드의 수명 제한에 대 한 확장 메서드를 포함 (참조 <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span><span class="sxs-lookup"><span data-stu-id="f563c-167">It also contains extension methods for limiting the lifetime of protected payloads (see <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span></span>

* <span data-ttu-id="f563c-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) 리디렉션할 기존 ASP.NET 4.x 앱에 설치할 수 있습니다 해당 `<machineKey>` 새 ASP.NET Core 데이터 보호 스택이 사용 하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) can be installed into an existing ASP.NET 4.x app to redirect its `<machineKey>` operations to use the new ASP.NET Core data protection stack.</span></span> <span data-ttu-id="f563c-169">자세한 내용은 <xref:security/data-protection/compatibility/replacing-machinekey>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f563c-169">For more information, see <xref:security/data-protection/compatibility/replacing-machinekey>.</span></span>

* <span data-ttu-id="f563c-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) 루틴 해시 PBKDF2 암호의 구현을 제공 및 사용자 암호를 안전 하 게 처리 해야 하는 시스템에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f563c-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) provides an implementation of the PBKDF2 password hashing routine and can be used by systems that must handle user passwords securely.</span></span> <span data-ttu-id="f563c-171">자세한 내용은 <xref:security/data-protection/consumer-apis/password-hashing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f563c-171">For more information, see <xref:security/data-protection/consumer-apis/password-hashing>.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="f563c-172">추가 자료</span><span class="sxs-lookup"><span data-stu-id="f563c-172">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
