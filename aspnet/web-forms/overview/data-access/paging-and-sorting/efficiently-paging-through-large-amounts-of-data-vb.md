---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 많은 양의 데이터 (VB)를 효율적으로 페이징 | Microsoft Docs
author: rick-anderson
description: 많은 양의 데이터를 해당 기본 데이터 소스 컨트롤 retriev로 작업할 때 데이터 프레젠테이션 컨트롤의 기본 페이징 옵션이 적합 하지 않습니다...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
ms.technology: dotnet-webforms
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 7d3b9f816e8e940d3ba109aeaf6055616f38d12a
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/03/2018
ms.locfileid: "37382681"
---
<a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="c3926-103">많은 양의 데이터 (VB)를 효율적으로 페이징</span><span class="sxs-lookup"><span data-stu-id="c3926-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>
====================
<span data-ttu-id="c3926-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="c3926-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="c3926-105">[샘플 앱을 다운로드](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) 또는 [PDF 다운로드](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="c3926-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="c3926-106">데이터 프레젠테이션 컨트롤의 기본 페이징 옵션이 아닙니다 적합 한 많은 양의 데이터를 작업할 때 해당 기본 데이터 소스 컨트롤 데이터의 하위 집합만 표시 되는 경우에 모든 레코드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="c3926-107">이러한 상황에서는 설정 해야 합니다에 사용자 지정 페이징 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="c3926-108">소개</span><span class="sxs-lookup"><span data-stu-id="c3926-108">Introduction</span></span>

<span data-ttu-id="c3926-109">이전 자습서에서 설명한 대로 두 가지 방법 중 하나에서 페이징을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="c3926-110">**기본 페이징은** 페이징 사용 옵션을 선택 하면 구현할 수 있습니다 데이터 웹 컨트롤 s의에서 스마트 태그, 단, 데이터 페이지를 볼 때마다 ObjectDataSource 검색 *모든* 레코드의도 페이지에서의 하위 집합만 표시는 되지만</span><span class="sxs-lookup"><span data-stu-id="c3926-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="c3926-111">**그러나 사용자 지정 페이징을** 기본 성능이 개선 되는 사용자에 의해 요청 된 데이터의 특정 페이지를 표시 해야 하는 데이터베이스에서 레코드를 검색 하 여 페이징 사용자 지정 페이징을 포함을 구현 하는 약간 더 많은 노력이 기본 페이징은 보다</span><span class="sxs-lookup"><span data-stu-id="c3926-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="c3926-112">구현만 확인 확인란 다시 용이성으로 인해 완료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="c3926-113">기본 페이징은 매력적인 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-113">default paging is an attractive option.</span></span> <span data-ttu-id="c3926-114">레코드의 모든 검색은 na ve 접근 방식을 사용 두고 선택 하는 많은 동시 사용자를 사용 하 여 충분히 대용량 데이터 또는 사이트에 대 한 페이징 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="c3926-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="c3926-115">이러한 상황에서는 페이징 응답 시스템을 제공 하기 위해 사용자 지정으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="c3926-116">사용자 지정 페이징의 과제 레코드 데이터의 특정 페이지에 필요한 정확한 집합을 반환 하는 쿼리를 작성할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="c3926-117">다행 스럽게도 Microsoft SQL Server 2005 제공 새 키워드 순위 결과 대 한 적절 한 레코드 하위 집합을 효율적으로 검색할 수는 쿼리를 작성할 수 있게 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="c3926-118">이 자습서에서는이 새 SQL Server 2005 키워드를 사용 하 여 GridView 컨트롤의 사용자 지정 페이징을 구현 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="c3926-119">사용자 지정 페이징에 대 한 사용자 인터페이스는 기본 페이징, 한 페이지에서 사용 하 여 다음 단계별 실행에 대 한 동일한 사용자 지정 페이징을 몇 배 많은 규모로 기본 페이징보다 더 빠르게 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="c3926-120">사용자 지정 페이징을 수행 하는 정확한 성능 향상을 통해 페이징 되 고 레코드와 데이터베이스 서버에 적용 되는 부하의 총에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="c3926-121">이 자습서의 끝에 사용자 지정 페이징을 수집한 성능 이점을 보여 주는 몇 가지 대략적인 메트릭을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="c3926-122">1 단계: 사용자 지정 페이징 프로세스 이해</span><span class="sxs-lookup"><span data-stu-id="c3926-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="c3926-123">데이터를 페이징 하는 경우 페이지에 표시 되는 정확한 레코드 요청 되는 데이터 페이지 및 페이지당 표시 되는 레코드의 수에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="c3926-124">예를 들어 하 려 81 제품을 통해 페이지 페이지당 10 개 제품을 표시 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="c3926-125">첫 번째 페이지를 볼 때 d 원하는 제품 1부터 10; 두 번째 페이지를 볼 때 제품 11 통해 20, 및 등 수 d 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="c3926-126">검색 해야 하는 레코드 및 페이징 인터페이스 렌더링 되는 방식을 지정 하는 세 개의 변수는</span><span class="sxs-lookup"><span data-stu-id="c3926-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="c3926-127">**행 인덱스 시작** 페이지에 표시할 데이터의 첫 번째 행의 인덱스; 인덱스 페이지 인덱스를 한 페이지에 표시할 레코드를 곱하여 하나를 추가 하 여 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="c3926-128">예를 들어, 첫 번째 페이지 (페이지 인덱스는 0)에 대해 한 번에 10 레코드를 페이징 하는 경우 시작 행 인덱스는 0 \* 10 + 1 또는 1입니다; 두 번째 페이지 (페이지 인덱스는 1)에 대 한 시작 행 인덱스는 1 \* 10 + 1 또는 11입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="c3926-129">**최대 행** 페이지당 표시할 레코드의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="c3926-130">이 변수는 마지막에 대 한 페이지 반환 페이지 크기 보다 적은 수의 레코드 수 있으므로 최대 행 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="c3926-131">예를 들어 페이지당 10 81 제품 레코드를 통해 페이징 하는 경우 아홉 번째 및 마지막 페이지에 레코드를 하나만 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="c3926-132">그러나 페이지가 없습니다. 최대 행 수 값 보다 더 많은 레코드를 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="c3926-133">**총 레코드 수** 통해 페이징 되 고 레코드의 총 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="c3926-134">이 변수 올바르지 t 필요한 지정된 된 페이지를 검색 하기 위해 레코드를 결정 하는 동안에서 페이징 인터페이스를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="c3926-135">예를 들어, 81 제품을 통해 페이징 되 고 있으면 페이징 인터페이스 페이징 UI에서에서 9 페이지 번호 표시를 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="c3926-136">기본 페이징을 사용 하 여 시작 하는 행 인덱스는 최대 행은 단순히 페이지 크기 페이지 인덱스 및 페이지 크기 1을 더한 값의 곱으로 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="c3926-137">기본 페이징은에서 레코드를 모두 검색 하므로 데이터를 각 행에 대 한 인덱스의 페이지를 렌더링 하는 경우 데이터베이스 라고 용이해 간단한 작업이 시작 행 인덱스 행으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="c3926-138">총 레코드 수를 손쉽게 사용할 수 있으므로 또한 s DataTable (또는 데이터베이스 결과 포함 하 되 어떤 개체)의 레코드 수가 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="c3926-139">사용자 지정 페이징 구현을 시작 하는 행 인덱스 및 최대 행 변수를 지정 하 그 후 레코드의 최대 행 수가 최대 행 시작 인덱스에서 시작 하는 레코드의 정확한 하위 집합을만 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="c3926-140">사용자 지정 페이징을 두 가지 과제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="c3926-141">지정된 된 시작 행 인덱스에 대 한 레코드를 반환 합니다. 시작할 수 있습니다 있도록 통해 페이징 되 고 전체 데이터의 각 행과 행 인덱스를 효율적으로 연결할 수 있어야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="c3926-142">통해 페이징 되 고 레코드의 총 수를 제공 해야</span><span class="sxs-lookup"><span data-stu-id="c3926-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="c3926-143">다음 두 단계에서 이러한 두 가지 과제에 응답 하는 데 필요한 SQL 스크립트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="c3926-144">SQL 스크립트를 외에도 BLL 및 DAL에서 메서드를 구현 해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="c3926-145">2 단계를 통해 페이징 되 고 레코드의 총 수를 반환</span><span class="sxs-lookup"><span data-stu-id="c3926-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="c3926-146">정확 하 게 표시 되는 페이지에 대 한 레코드 하위 집합을 검색 하는 방법을 살펴보기 전에 수 s를 통해 페이징 되 고 레코드의 총 수를 반환 하는 방법을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="c3926-147">페이징 사용자 인터페이스를 제대로 구성 하기 위해이 정보가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="c3926-148">사용 하 여 특정 SQL 쿼리에서 반환 된 레코드의 총 수를 가져올 수 있습니다 합니다 [ `COUNT` 집계 함수](https://msdn.microsoft.com/library/ms175997.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="c3926-149">예를 들어, 레코드의 총 수를 확인 하는 `Products` 테이블 다음 쿼리에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="c3926-150">이 정보를 반환 하는 DAL에 메서드를 추가 하는 s 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="c3926-151">특히 라는 DAL 메서드를 만들겠습니다 `TotalNumberOfProducts()` 를 실행 하는 `SELECT` 위에 표시 된 문.</span><span class="sxs-lookup"><span data-stu-id="c3926-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="c3926-152">열어서 시작 합니다 `Northwind.xsd` 형식화 된 데이터 집합 파일에는 `App_Code/DAL` 폴더.</span><span class="sxs-lookup"><span data-stu-id="c3926-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="c3926-153">그런 다음 마우스 오른쪽 단추로 클릭는 `ProductsTableAdapter` 디자이너에서 쿼리 추가 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="c3926-154">대로 ve 이전 자습서에서는 표시 이렇게는 DAL에 새 메서드를 추가할 수는 특정 SQL 문이나 저장된 프로시저를 호출 하면 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="c3926-155">TableAdapter 메서드는 이전 자습서에서와 마찬가지로이 하나에 대 한 하기로 임시 SQL 문을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![임시 SQL 문을 사용 하 여](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="c3926-157">**그림 1**: 특별 SQL 문을 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="c3926-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="c3926-158">다음 화면에서 만들 쿼리의 형식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="c3926-159">이 쿼리는 반환 된 단일 스칼라 값을 레코드의 총 수 있으므로 합니다 `Products` 테이블 선택는 `SELECT` 단일 값 옵션을 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![단일 값을 반환 하는 SELECT 문을 사용 하 여 쿼리를 구성 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="c3926-161">**그림 2**: 단일 값을 반환 하는 SELECT 문을 사용 하 여 쿼리를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="c3926-162">사용 하 여 쿼리의 형식을 나타내는, 후 다음 쿼리가 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-162">After indicating the type of query to use, we must next specify the query.</span></span>


![제품 쿼리에서 선택 그룹 사용](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="c3926-164">**그림 3**: SELECT COUNT를 사용 하 여 (\*) FROM 제품 쿼리</span><span class="sxs-lookup"><span data-stu-id="c3926-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="c3926-165">마지막으로, 메서드에 대 한 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="c3926-166">앞서 언급 한, s를 사용 하 여 `TotalNumberOfProducts`입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![DAL 메서드 TotalNumberOfProducts 이름](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="c3926-168">**그림 4**: DAL 메서드 TotalNumberOfProducts 이름</span><span class="sxs-lookup"><span data-stu-id="c3926-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="c3926-169">완료를 클릭 하면 마법사가 추가 된 `TotalNumberOfProducts` DAL 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="c3926-170">SQL 쿼리에서 결과 경우 DAL에서 스칼라 반환 메서드 반환 nullable 형식 `NULL`합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="c3926-171">그러나 우리의 `COUNT` 쿼리,는 항상 반환 이외`NULL` DAL 메서드가 null을 허용 하는 정수를 반환 하는 하지만; 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="c3926-172">DAL 메서드 외에도 BLL에 메서드도 필요 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="c3926-173">엽니다는 `ProductsBLL` 추가한 클래스 파일을 `TotalNumberOfProducts` DAL s에을 호출 하는 메서드 `TotalNumberOfProducts` 메서드:</span><span class="sxs-lookup"><span data-stu-id="c3926-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="c3926-174">DAL s `TotalNumberOfProducts` 메서드가 null을 허용 하는 정수를 반환 하지만에서는 만든 ve 합니다 `ProductsBLL` s 클래스 `TotalNumberOfProducts` 표준 정수를 반환 하도록 메서드.</span><span class="sxs-lookup"><span data-stu-id="c3926-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="c3926-175">따라서 하도록 해야 합니다 `ProductsBLL` s 클래스 `TotalNumberOfProducts` DAL s에 의해 반환 된 null 허용 정수 값 부분을 반환 하는 메서드 `TotalNumberOfProducts` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c3926-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="c3926-176">하지만에 대 한 호출 `GetValueOrDefault()` nullable 정수 이면이 있으면; null 허용 정수 값을 반환 합니다 `null`, 기본 정수 값 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="c3926-177">3 단계: 정확한 레코드 하위 집합 반환</span><span class="sxs-lookup"><span data-stu-id="c3926-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="c3926-178">다음 태스크를 시작 하는 행 인덱스를 허용 하는 BLL 및 DAL 메서드를 만들 때 및 최대 행 변수 앞에서 설명한 및 적절 한 레코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="c3926-179">작업을 수행 하기 전에 let s 필요한 SQL 스크립트를 먼저 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="c3926-180">Us의 당면 과제는 우리가 시작 행 인덱스 (및 레코드의 최대 레코드 수까지)를 시작 하는 해당 레코드를 반환할 수 있습니다 있도록 통해 페이징 되 고 전체 결과의 각 행에 인덱스를 효율적으로 할당할 수 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="c3926-181">이미 있으면 열 행 인덱스로 사용 되는 데이터베이스 테이블의 문제가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="c3926-182">얼핏 보기에 우리가 생각 하는 합니다 `Products` 테이블 s `ProductID` 필드 충분할 첫 번째 제품에 `ProductID` 1, 2는 두 번째 등.</span><span class="sxs-lookup"><span data-stu-id="c3926-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="c3926-183">그러나 제품을 삭제 하면이 방법을 실행 하는 시퀀스에서 간격이 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="c3926-184">두 가지 일반 기술을 효율적으로 데이터를 통해 페이지를 사용 하 여 행 인덱스를 연결 하는 데 검색할 레코드의 정확한 하위 집합을 사용할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="c3926-185">**SQL Server 2005를 사용 하 `ROW_NUMBER()` 키워드** SQL Server 2005로 새는 `ROW_NUMBER()` 키워드 순위를 일정 한 순서에 따라 반환 된 각 레코드를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="c3926-186">이 순위는 각 행에 대해 행 인덱스로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="c3926-187">**테이블 변수를 사용 하 고 `SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT` 문](https://msdn.microsoft.com/library/ms188774.aspx) ; 종료 하기 전에 쿼리를 처리 해야 하는 총 레코드 수를 지정 하려면 사용할 수 있습니다 [테이블 변수와](http://www.sqlteam.com/item.asp?ItemID=9454) akin를 표 형식 데이터를 보유할 수 있는 T-SQL 변수가 로컬 [임시 테이블](http://www.sqlteam.com/item.asp?ItemID=2029)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="c3926-188">이 방법은 동일 하 게 Microsoft SQL Server 2005 및 SQL Server 2000 잘 (반면는 `ROW_NUMBER()` 방법은 SQL Server 2005 에서만 작동).</span><span class="sxs-lookup"><span data-stu-id="c3926-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="c3926-189">여기서 테이블 변수를 만드는 것을 `IDENTITY` 열과 해당 데이터를 통해 페이징 될 테이블의 기본 키 열입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="c3926-190">순차 행 인덱스를 연결 하므로 테이블 변수로 데이터를 통해 페이징 될 테이블의 내용을 덤프 어 (통해를 `IDENTITY` 열) 테이블의 각 레코드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="c3926-191">테이블 변수의 채워진 후는 `SELECT` 문은 테이블 변수를 기본 테이블과 조인, 특정 레코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="c3926-192">`SET ROWCOUNT` 문을 지능적으로 테이블 변수를 덤프할 수 해야 하는 레코드의 수를 제한 하려면 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="c3926-193">이 방법은의 효율성 요청 된 페이지 번호를 기반으로 `SET ROWCOUNT` 값 행 인덱스 시작 최대 행 수를 더한 값이 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="c3926-194">데이터의 후속 페이지를 첫 번째 페이지 낮은 번호가 매겨진 페이징할 때는이 방법은 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="c3926-195">그러나 끝 페이지를 검색 하는 경우 기본 페이징와 비슷한 성능이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="c3926-196">이 자습서를 사용 하 여 사용자 지정 페이징을 구현 된 `ROW_NUMBER()` 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="c3926-197">테이블 변수를 사용 하 여 대 한 자세한 내용은 및 `SET ROWCOUNT` 기법을 참조 하세요 [는 큰 결과 집합을 통해 페이징에 대 한 자세한 효율적인 방법은](http://www.4guysfromrolla.com/webtech/042606-1.shtml)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="c3926-198">`ROW_NUMBER()` 키워드는 다음 구문을 사용 하 여 특정 순서를 통해 반환 된 각 레코드를 사용 하 여 순위를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="c3926-199">`ROW_NUMBER()` 표시 된 순서와 관련 하 여 각 레코드에 대 한 순위를 지정 하는 숫자 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="c3926-200">예를 들어, 가장에서 순서가 지정 된 각 제품에 대 한 순위를 가장 적은 비용이에서는 사용할 수 다음 쿼리.</span><span class="sxs-lookup"><span data-stu-id="c3926-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="c3926-201">그림 5의 결과 Visual Studio에서 쿼리 창을 통해 실행 하는 경우이 쿼리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="c3926-202">각 행에 대 한 가격 순위를 함께 가격으로 제품으로 정렬 됨을 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![가격 등급에 포함 된 각 반환 된 레코드](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="c3926-204">**그림 5**: The 가격 등급에 포함 된 각 반환 된 레코드</span><span class="sxs-lookup"><span data-stu-id="c3926-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="c3926-205">`ROW_NUMBER()` SQL Server 2005에서 사용할 수 있는 많은 새 순위 함수 중 하나일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="c3926-206">에 대 한 자세한 설명은 `ROW_NUMBER()`, 다른 순위 함수를 함께 읽을 [Microsoft SQL Server 2005를 사용 하 여 순위 결과 반환](http://www.4guysfromrolla.com/webtech/010406-1.shtml)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="c3926-207">지정 된 결과 순위 지정 하는 경우 `ORDER BY` 열에는 `OVER` 절 (`UnitPrice`, 위의 예에서), SQL Server에서 결과 정렬 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="c3926-208">이 빠른 작업에서 결과 정렬 열 위에 클러스터형 인덱스가 있는 경우를 다루는 경우 인덱스를 이지만 그렇지 않은 경우 더 높은 비용이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="c3926-209">성능 향상을 위해 충분히 큰 쿼리에 대 한, 사용 되는 결과으로 정렬 열에 대 한 비클러스터형 인덱스를 추가 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="c3926-210">참조 [SQL Server 2005의 성능과 순위 함수](http://www.sql-server-performance.com/ak_ranking_functions.asp) 더 자세히 살펴보고 성능 고려 사항에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="c3926-211">반환 된 순위 정보 `ROW_NUMBER()` 에서 직접 사용할 수는 `WHERE` 절.</span><span class="sxs-lookup"><span data-stu-id="c3926-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="c3926-212">하지만 파생된 테이블을 반환 사용할 수는 `ROW_NUMBER()` 한 다음에 나타날 수 있는 결과 `WHERE` 절.</span><span class="sxs-lookup"><span data-stu-id="c3926-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="c3926-213">예를 들어 다음 쿼리를 사용 하 여 파생된 테이블 UnitPrice 및 ProductName 열에 반환 된 `ROW_NUMBER()` 결과 사용 하 여 다음을 `WHERE` 만 가격 차수가 해당 제품을 반환 하는 절은 11 ~ 20 개 사이로:</span><span class="sxs-lookup"><span data-stu-id="c3926-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="c3926-214">이 개념을 좀 더 확장을 원하는 시작 행 인덱스 및 최대 행 값이 지정 된 데이터의 특정 페이지를 검색 하려면이 방법을 이용 하면:</span><span class="sxs-lookup"><span data-stu-id="c3926-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="c3926-215">이 자습서에서는 나중에 살펴볼 합니다 *`StartRowIndex`* 제공한 ObjectDataSource 인덱싱된 0부터 시작 하는 반면는 `ROW_NUMBER()` SQL Server 2005에서 반환 된 값은 1부터 인덱싱됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="c3926-216">따라서 합니다 `WHERE` 절 해당 레코드를 반환 합니다. 여기서 `PriceRank` 보다 엄격 하 게 크면 *`StartRowIndex`* 보다 작거나 같음 *`StartRowIndex`*  +  *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="c3926-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="c3926-217">이제는 우리 하는 방법을 설명 하는 ve `ROW_NUMBER()` 수 시작 행 인덱스 및 최대 행 값이 지정 된 데이터의 특정 페이지를 검색 하는 데, 이제 해야 BLL 및 DAL 메서드로이 논리를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="c3926-218">순서를 결정 해야 합니다이 쿼리를 만들 때 사용 되는 결과 순위를 지정할; s를 제품 이름별 사전순으로 정렬할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="c3926-219">이이 자습서에서는 사용자 지정 페이징 구현에서는 됩니다 정렬할 수도 있습니다 보다는 사용자 지정 페이지 매김된 된 보고서를 만들 수 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="c3926-220">다음 자습서에서는 그러나 살펴보겠습니다 어떻게 이러한 기능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="c3926-221">이전 섹션에서 임시 SQL 문 처럼 DAL 메서드를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="c3926-222">아쉽게도 같은 TableAdapter 마법사 만들어지고 t에서 사용 하는 Visual Studio에서 T-SQL 파서를 `OVER` 구문에서 사용 하는 `ROW_NUMBER()` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="c3926-223">따라서이 DAL 메서드는 저장된 프로시저를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="c3926-224">보기 메뉴 (또는 적중된 Ctrl + Alt + S)에서 서버 탐색기를 선택 하 고 확장 된 `NORTHWND.MDF` 노드.</span><span class="sxs-lookup"><span data-stu-id="c3926-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="c3926-225">새 저장된 프로시저를 추가 하려면 저장 프로시저 노드를 마우스 오른쪽 단추로 클릭 하 고 새 저장 프로시저 추가 선택 (그림 6 참조).</span><span class="sxs-lookup"><span data-stu-id="c3926-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![새 저장된 프로시저는 제품을 통해 페이징에 대 한 추가](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="c3926-227">**그림 6**: 페이징 제품에 대 한 새 저장된 프로시저 추가</span><span class="sxs-lookup"><span data-stu-id="c3926-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="c3926-228">이 저장된 프로시저 두 정수 입력된 매개 변수를 수락 해야 `@startRowIndex` 및 `@maximumRows` 사용 하 여를 `ROW_NUMBER()` 함수 기준으로 정렬 합니다 `ProductName` 필드에 지정 된 것 보다 큰 행만을 반환 `@startRowIndex` 및 미만 또는 같음 `@startRowIndex`  +  `@maximumRow` s입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="c3926-229">새 저장된 프로시저에 다음 스크립트를 입력 하 고 데이터베이스에 저장된 프로시저를 추가 하려면 저장 아이콘을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="c3926-230">저장된 프로시저를 만든 후이 테스트 하려면 잠시 시간이 소요 됩니다. 마우스 오른쪽 단추로 클릭는 `GetProductsPaged` 저장된 프로시저는 서버 탐색기에서 이름을 지정 하 고 실행 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="c3926-231">Visual Studio 다음 묻는 입력된 매개 변수의 `@startRowIndex` 고 `@maximumRow` s (그림 7 참조).</span><span class="sxs-lookup"><span data-stu-id="c3926-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="c3926-232">다른 값을 사용 하 고 결과 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-232">Try different values and examine the results.</span></span>


![에 대 한 값을 입력 합니다 @startRowIndex 고 @maximumRows 매개 변수](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="c3926-234"><strong>그림 7</strong>:의 값을 입력 합니다 @startRowIndex 고 @maximumRows 매개 변수</span><span class="sxs-lookup"><span data-stu-id="c3926-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="c3926-235">이후에 이러한 선택 매개 변수 값을 입력, 출력 창에 결과가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="c3926-236">그림 8 둘 다에 대해 10에서 전달 하는 경우 결과 표시 합니다 `@startRowIndex` 및 `@maximumRows` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="c3926-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="c3926-237">[![반환 되는 레코드는에 표시 되는지 두 번째 데이터 페이지](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="c3926-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="c3926-238">**그림 8**: 반환 되는 레코드는 표시 되도록 데이터의 두 번째 페이지 ([큰 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="c3926-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>


<span data-ttu-id="c3926-239">이 사용 하 여 만든 저장 프로시저를 만들려면 준비 된 것을 `ProductsTableAdapter` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c3926-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="c3926-240">엽니다는 `Northwind.xsd` 형식화 된 데이터 집합을 오른쪽 단추로 클릭은 `ProductsTableAdapter`, 추가 쿼리 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="c3926-241">임시 SQL 문을 사용 하 여 쿼리를 만드는 대신 기존 저장된 프로시저를 사용 하 여 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![기존 저장된 프로시저를 사용 하는 DAL 메서드 만들기](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="c3926-243">**그림 9**: 기존 저장된 프로시저를 사용 하는 DAL 메서드 만들기</span><span class="sxs-lookup"><span data-stu-id="c3926-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="c3926-244">다음으로, 하 라는 프롬프트가 호출할 저장된 프로시저를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="c3926-245">선택 된 `GetProductsPaged` 드롭 다운 목록에서 프로시저를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![GetProductsPaged 선택 드롭다운 목록에서 프로시저를 저장 합니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="c3926-247">**그림 10**:는 GetProductsPaged 선택 드롭다운 목록에서 프로시저를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="c3926-248">다음 화면에서 다음 묻는 어떤 종류의 데이터는 저장된 프로시저에서 반환 됩니다: 테이블 형식 데이터, 단일 값 또는 값이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="c3926-249">이후를 `GetProductsPaged` 저장된 프로시저가 여러 레코드를 반환을 나타내는 표 형식 데이터를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![저장된 프로시저가 반환 테이블 형식 데이터를 나타냅니다.](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="c3926-251">**그림 11**: 저장된 프로시저가 반환 테이블 형식 데이터를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="c3926-252">마지막으로 생성 하려는 메서드의 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="c3926-253">이전 자습서에서와 마찬가지로 계속 해 서 DataTable 채우기 모두를 사용 하 여 메서드를 만듭니다 및 DataTable을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="c3926-254">첫 번째 메서드 이름을 `FillPaged` 하 고 두 번째 `GetProductsPaged`입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![메서드 FillPaged 이름과 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="c3926-256">**그림 12**: 메서드 FillPaged 이름과 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="c3926-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="c3926-257">또한 제품의 특정 페이지를 반환 하는 DAL 메서드 생성 해야 BLL에 이러한 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="c3926-258">DAL 메서드처럼 BLL의 GetProductsPaged 메서드 시작 행 인덱스 및 최대 행 수를 지정 하는 것에 대 한 두 개의 정수 입력을 수락 해야 하 고 지정된 된 범위 내에 있는 레코드만 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="c3926-259">단순히에 대 한 호출은 아래로 DAL의 GetProductsPaged 메서드를 다음과 같이 ProductsBLL 클래스에는 이러한 BLL 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="c3926-260">모든 이름을 사용할 수 있습니다 BLL의 메서드에 입력된 매개 변수를 사용 하도록 선택 하지만, 곧 알 수 있듯이 `startRowIndex` 고 `maximumRows` 추가에서 덕분 약간의 작업이이 메서드를 사용 하는 ObjectDataSource를 구성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="c3926-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="c3926-261">4 단계: 사용자 지정 페이징을 사용 하 여 ObjectDataSource 구성</span><span class="sxs-lookup"><span data-stu-id="c3926-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="c3926-262">전체 레코드의 특정 하위 집합에 액세스 하기 위한 BLL 및 DAL 메서드를 사용 하 여 사용자 지정 페이징을 사용 하 여 해당 기본 레코드를 통해 해당 페이지 제어 준비 된 GridView를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="c3926-263">열어서 시작 합니다 `EfficientPaging.aspx` 페이지에 `PagingAndSorting` 폴더 페이지에 GridView를 추가 하 고 새 ObjectDataSource 컨트롤을 사용 하도록 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="c3926-264">이전 자습서에서는 종종 있었습니다 ObjectDataSource를 사용 하도록 구성 합니다 `ProductsBLL` s 클래스 `GetProducts` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c3926-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="c3926-265">이 이때 단, 사용 하려는 합니다 `GetProductsPaged` 메서드 대신 이후 합니다 `GetProducts` 메서드가 반환 되는 *모든* 데이터베이스에서 제품의 반면 `GetProductsPaged` 레코드의 특정 하위 집합만 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![S ProductsBLL 클래스 GetProductsPaged 메서드를 사용 하는 ObjectDataSource 구성](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="c3926-267">**그림 13**: ProductsBLL 클래스의 GetProductsPaged 메서드를 사용 하는 ObjectDataSource 구성</span><span class="sxs-lookup"><span data-stu-id="c3926-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="c3926-268">읽기 전용 GridView를 만들어 다시 우리 이후로 잠시 메서드 드롭 다운 목록에서 INSERT, UPDATE, 설정 하 고 탭 (없음)를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="c3926-269">다음으로 ObjectDataSource 마법사 묻는의 소스를 `GetProductsPaged` s 메서드에 `startRowIndex` 및 `maximumRows` 매개 변수 값을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="c3926-270">이러한 입력된 매개 변수에 실제로 설정할 GridView에서 자동으로, 따라서 단순히 소스 집합 None으로 두고 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![입력된 매개 변수 원본 None으로 유지](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="c3926-272">**그림 14**: 입력된 매개 변수 원본 None으로 유지</span><span class="sxs-lookup"><span data-stu-id="c3926-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="c3926-273">ObjectDataSource 마법사를 완료 한 후 GridView가 BoundField 또는 CheckBoxField 제품 데이터 필드에 대해 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="c3926-274">자유롭게 하다 면 GridView의 모양을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="c3926-275">I ve만 표시 하도록 선택한 합니다 `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, 및 `UnitPrice` BoundFields 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="c3926-276">또한 스마트 태그의 페이징 사용 확인란을 선택 하 여 페이징을 지원 하기 위해 GridView를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="c3926-277">이러한 변경 이후 GridView 및 ObjectDataSource 선언적 태그는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="c3926-278">그러나 브라우저를 통해 페이지를 방문할 경우 GridView 위치가 없습니다 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView가 표시 되지 않음](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="c3926-280">**그림 15**: GridView가 표시 되지 않음</span><span class="sxs-lookup"><span data-stu-id="c3926-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="c3926-281">ObjectDataSource 현재 사용 중 이므로 0 값으로 둘 다에 대해 GridView 없습니다 합니다 `GetProductsPaged` `startRowIndex` 및 `maximumRows` 매개 변수를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="c3926-282">따라서 없는 레코드를 반환 하는 결과 SQL 쿼리 및 따라서 GridView 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="c3926-283">이 해결 하려면 사용자 지정 페이징을 사용 하 여 ObjectDataSource 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="c3926-284">다음 단계에서는이 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="c3926-285">**ObjectDataSource가 설정 `EnablePaging` 속성을 `true`**  이를 통과 해야 하는 ObjectDataSource에 나타냅니다 합니다 `SelectMethod` 두 개의 추가 매개 변수: 시작 하는 행 인덱스를 지정할 수 ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), 최대 행 수를 지정 하 고 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span><span class="sxs-lookup"><span data-stu-id="c3926-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="c3926-286">**ObjectDataSource가 설정 `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 그에 따라 속성** 는 `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 속성에 전달 된 입력된 매개 변수의 이름을 나타냅니다는 `SelectMethod` 사용자 지정 페이징 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="c3926-287">기본적으로 이러한 매개 변수 이름은 `startIndexRow` 및 `maximumRows`, 하는 것을 만들 때는 `GetProductsPaged` 메서드 BLL은 입력된 매개 변수의이 값 사용.</span><span class="sxs-lookup"><span data-stu-id="c3926-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="c3926-288">BLL s에 대해 다른 매개 변수 이름을 사용 하도록 선택한 경우 `GetProductsPaged` 메서드와 같은 `startIndex` 하 고 `maxRows`ObjectDataSource s를 설정 해야 하는 예제에 대 한 `StartRowIndexParameterName` 및 `MaximumRowsParameterName` 속성 적절 하 게 (예:에 대 한 startIndex `StartRowIndexParameterName` 및에 대 한 maxRows `MaximumRowsParameterName`).</span><span class="sxs-lookup"><span data-stu-id="c3926-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="c3926-289">**집합 ObjectDataSource s [ `SelectCountMethod` 속성](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) 의 총 수의 레코드 중 페이징 통해 반환 되는 메서드의 이름 (`TotalNumberOfProducts`)** 이전에 설명한 대로 `ProductsBLL`의 클래스`TotalNumberOfProducts`메서드를 실행 하는 DAL 메서드를 사용 하 여 페이징 되 고 레코드의 총 수를 반환 합니다.는 `SELECT COUNT(*) FROM Products` 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="c3926-290">이 정보는 ObjectDataSource 올바르게 페이징 인터페이스를 렌더링 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="c3926-291">**제거 합니다 `startRowIndex` 하 고 `maximumRows` `<asp:Parameter>` ObjectDataSource가 선언적 태그의에서 요소** ObjectDataSource 마법사를 통해 구성에 Visual Studio 자동으로 추가 두 `<asp:Parameter>` 요소 에 대 한는 `GetProductsPaged`의 메서드 매개 변수를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="c3926-292">설정 하 여 `EnablePaging` 에 `true`, 이러한 매개 변수를 자동으로 전달 됩니다; ObjectDataSource 전달 하려고도 선언적 구문에 표시 된 *4* 매개 변수는 `GetProductsPaged` 메서드 하는 두 매개 변수는 `TotalNumberOfProducts` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c3926-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="c3926-293">이 제거 해야 하는 경우 `<asp:Parameter>` 요소와 같은 오류 메시지를 얻게 되는 브라우저를 통해 페이지를 방문 하는 경우: *ObjectDataSource 'ObjectDataSource1' 찾을 수 없습니다는 제네릭이 아닌 메서드는 ' TotalNumberOfProducts' 매개 변수: startRowIndex, maximumRows*합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="c3926-294">다음과 같이 변경한 후 ObjectDataSource가 선언적 구문을 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="c3926-295">합니다 `EnablePaging` 하 고 `SelectCountMethod` 속성이 설정 되어 있는지 및 `<asp:Parameter>` 요소가 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="c3926-296">그림 16에서는 이러한 변경이 이루어진 후 속성 창의 스크린 샷이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![사용자 지정 페이징을 사용 하려면 ObjectDataSource 컨트롤 구성](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="c3926-298">**그림 16**: 사용자 지정 페이징을 사용 하려면 ObjectDataSource 컨트롤 구성</span><span class="sxs-lookup"><span data-stu-id="c3926-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="c3926-299">다음과 같이 변경한 후 브라우저를 통해이 페이지를 방문 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="c3926-300">10 개의 제품이 나열, 표시 사전순으로 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="c3926-301">시간을 내어 한 번에 데이터 한 페이지를 단계별로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="c3926-302">지정된 된 페이지에 대 한 표시 해야 하는 레코드만 검색으로 visual 차이가 없습니다 최종 사용자가의 관점에서 기본 페이징 및 사용자 지정 페이징을 상태인 동안 많은 양의 데이터를 통해 페이지 보다 효율적으로 사용자 지정 페이징 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="c3926-303">[![데이터, Ordered의 이름, 제품에는 사용 하 여 사용자 지정 페이징 페이징](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="c3926-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="c3926-304">**그림 17**: 데이터, Ordered의 이름, 제품에는 사용 하 여 사용자 지정 페이징 페이징 ([큰 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="c3926-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="c3926-305">사용자 지정 페이징을 사용 하 여 페이지 수는 ObjectDataSource가 반환한 값 `SelectCountMethod` GridView가의 뷰 상태에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="c3926-306">다른 GridView 변수를 `PageIndex`, `EditIndex`를 `SelectedIndex`를 `DataKeys` 등에 컬렉션에 저장 됩니다 *상태를 제어*를 GridView s의 값에 관계 없이 유지 되는 `EnableViewState` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="c3926-307">하므로 `PageCount` 값은 유지 게시할 마지막 페이지로 이동 하는 링크가 포함 된 페이징 인터페이스를 사용 하는 경우에 상태 보기를 사용 하 여 반드시 GridView가의 뷰 상태를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="c3926-308">(페이징 인터페이스에 대 한 직접 링크를 마지막 포함 되지 않은 경우 페이지의 뷰 상태를 비활성화할 수 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="c3926-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="c3926-309">포스트백을 발생 시키는 마지막 페이지 링크를 클릭 하 고 업데이트 GridView 지시 해당 `PageIndex` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="c3926-310">마지막 페이지 링크를 클릭 하면 GridView 할당 해당 `PageIndex` 속성을 하나 값 보다 작은 해당 `PageCount` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="c3926-311">비활성화 상태 보기를 사용 하 여는 `PageCount` 게시할 손실 되는 값 및 `PageIndex` 대신 최대 정수 값이 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="c3926-312">GridView를 곱하여 시작 행 인덱스를 확인 하려고 하는 다음에 `PageSize` 및 `PageCount` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="c3926-313">이 인해는 `OverflowException` 제품 허용 되는 최대 정수 크기를 초과 하므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="c3926-314">구현 사용자 지정 페이징 및 정렬</span><span class="sxs-lookup"><span data-stu-id="c3926-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="c3926-315">현재 사용자 지정 페이징 구현을 통해 데이터 페이징 되는 순서를 만들 때 정적으로 지정할 필요는 `GetProductsPaged` 저장 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="c3926-316">그러나 있습니다 기록한 GridView가 스마트 태그에는 페이징 사용 옵션 외에 정렬 사용 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="c3926-317">아쉽게도 현재 사용자 지정 페이징 구현 GridView에 정렬 지원을 추가 데이터의 현재 표시 된 페이지의 레코드를 정렬만 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="c3926-318">예를 들어, 또한 페이징을 지원 하 여 데이터의 첫 번째 페이지를 볼 때 제품 이름을 내림차순으로 정렬 하는 다음 GridView를 구성 하는 경우 1 페이지에서 제품의 순서를 반대로 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="c3926-319">그림 18에서 볼 수 있듯이 이러한 카 호랑이로 표시 첫 번째 제품 71 다른 제품 다음에 오는 카 호랑이 사전순으로; 무시 하는 역방향 알파벳 순으로 정렬 하는 경우 정렬에서 첫 번째 페이지의 레코드만 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="c3926-320">[![정렬 되는 데이터에만 표시 현재 페이지](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="c3926-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="c3926-321">**그림 18**: 정렬 되는 데이터에만 표시 현재 페이지 ([큰 이미지를 보려면 클릭](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="c3926-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>


<span data-ttu-id="c3926-322">데이터가 BLL s에서 검색 된 후 발생 정렬 하기 때문에 데이터의 현재 페이지에만 적용 정렬 `GetProductsPaged` 메서드와이 메서드가 특정 페이지에 대해 해당 레코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="c3926-323">올바르게 정렬를 구현 하려면 정렬 식을 전달 해야 합니다 `GetProductsPaged` 메서드 데이터의 특정 페이지를 반환 하기 전에 데이터를 적절 하 게 순위 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="c3926-324">다음 자습서에서이 작업을 수행 하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="c3926-325">사용자 지정 페이징 및 삭제를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="c3926-326">마지막 페이지에서 마지막 레코드를 삭제 하는 경우 볼 수 있습니다 하는 사용자 지정 페이징 기술을 사용 하 여 데이터 페이징 되는 GridView에서 삭제 기능을 사용 하도록 설정 하는 GridView 사라집니다 적절 하 게 감소 하는 대신 GridView의 `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="c3926-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="c3926-327">이 버그를 재현 하려면 방금 우리가 방금 전에 만든 자습서에 대 한 삭제를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="c3926-328">81 제품을 한 번에 10 개 제품을 통해 페이징 하는 것 이므로 단일 제품에 표시 됩니다는 여기서 마지막 페이지 (페이지 9)로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="c3926-329">이 제품을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-329">Delete this product.</span></span>

<span data-ttu-id="c3926-330">마지막으로 제품을 GridView를 삭제 하면 *해야* 여덟 번째 페이지로 자동으로 이동 하 고 이러한 기능은 기본 페이징을 사용 하 여 직접 제작한 잠금에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="c3926-331">그러나 사용자 지정 페이징을 사용 하 여 마지막 페이지에서 마지막 제품을 삭제 한 후 GridView 단순히이 화면에서 사라지면 완전히 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="c3926-332">정확한 원인을 *이유* 은이 자습서에서 다루지 bit 이런; 참조 [GridView를 사용 하 여 사용자 지정 페이징의 마지막 페이지에 있는 마지막 레코드를 삭제](http://scottonwriting.net/sowblog/posts/7326.aspx) 의 원본에 대 한 하위 수준 세부 정보에 대 한 이 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="c3926-333">요약 하자면에서이 삭제 단추를 클릭할 때 GridView에서 수행 되는 단계의 다음 시퀀스에서는 인해 s:</span><span class="sxs-lookup"><span data-stu-id="c3926-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="c3926-334">레코드 삭제</span><span class="sxs-lookup"><span data-stu-id="c3926-334">Delete the record</span></span>
2. <span data-ttu-id="c3926-335">지정 된 표시 하려면 적절 한 레코드를 가져올 `PageIndex` 및 `PageSize`</span><span class="sxs-lookup"><span data-stu-id="c3926-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="c3926-336">않았는지 확인 합니다 `PageIndex` GridView가 자동으로 감소 시킵니다 수행 하는 경우 데이터 소스에서 데이터 페이지 수를 넘지 않는 `PageIndex` 속성</span><span class="sxs-lookup"><span data-stu-id="c3926-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="c3926-337">2 단계에서에서 가져온 레코드를 사용 하 여 GridView에 적절 한 데이터 페이지를 바인딩</span><span class="sxs-lookup"><span data-stu-id="c3926-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="c3926-338">2 단계는 사실에서 형태소 분석 문제를 `PageIndex` 때 표시할 레코드를 클릭 한 다음 계속 사용 합니다 `PageIndex` 유일한 레코드 삭제 된 마지막 페이지의 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="c3926-339">2 단계에 따라서 *없습니다* 데이터의 마지막 페이지에는 더 이상 레코드가 포함 되어 있으므로 레코드가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="c3926-340">그런 다음 3 단계에서에서 GridView를 인식 하는 해당 `PageIndex` 속성은 데이터 원본에는 페이지의 총 수보다 큽니다 (이후로 ve 삭제 마지막 페이지에 있는 마지막 레코드) 및 감소 하므로 해당 `PageIndex` 속성.</span><span class="sxs-lookup"><span data-stu-id="c3926-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="c3926-341">4 단계에서에서 2 단계;에서 검색 되는 데이터에 자신을 바인딩하도록 GridView 시도 그러나 반환 된 레코드가 2 단계에서 따라서 그 결과 빈 GridView입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="c3926-342">기본 페이징을 사용 하 여이 문제가 되지 않습니다 t 노출 하기 때문에 2 단계 *모든* 데이터 원본의 레코드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="c3926-343">이 문제를 해결 하는 두 가지 옵션이 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-343">To fix this we have two options.</span></span> <span data-ttu-id="c3926-344">첫 번째는 GridView s에 대 한 이벤트 처리기를 만들려면 `RowDeleted` 만 삭제 된 페이지에 표시 된 레코드 수를 결정 하는 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="c3926-345">했습니다. 하나의 레코드를 삭제 하는 레코드 받아야 마지막 고 GridView가 감소 해야 `PageIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="c3926-346">물론 집합만 업데이트는 `PageIndex` 삭제 작업이 실제로 성공 하면 얻는 없도록 함으로써 합니다 `e.Exception` 속성은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="c3926-347">이 방법은 업데이트 하기 때문에 `PageIndex` 1 단계 후 하지만 2 단계 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="c3926-348">따라서 2 단계에서에서 적절 한 레코드 집합이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="c3926-349">이렇게 하려면 다음과 같은 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-349">To accomplish this, use code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="c3926-350">다른 해결 방법은 ObjectDataSource s에 대 한 이벤트 처리기를 만들려면 `RowDeleted` 이벤트 및 설정 하는 `AffectedRows` 속성 값이 1 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="c3926-351">GridView 업데이트 1 단계에서에서 (하지만 다시 2 단계에서에서 데이터를 검색 하기 전에) 레코드를 삭제 한 후 해당 `PageIndex` 속성 작업에 의해 영향을 받은 하나 이상의 행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="c3926-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="c3926-352">그러나는 `AffectedRows` ObjectDataSource가 속성을 설정 하지 않은 하 고 따라서이 단계를 생략 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="c3926-353">이 단계를 실행 하는 한 가지 방법은 수동으로 설정 하는 것은 `AffectedRows` 삭제 작업이 성공적으로 완료 되 면 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="c3926-354">다음과 같은 코드를 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-354">This can be accomplished using code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="c3926-355">코드 숨김 클래스에서 이러한 이벤트 처리기의 둘 다에 대 한 코드를 찾을 수 있습니다는 `EfficientPaging.aspx` 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="c3926-356">기본 및 사용자 지정 페이징의 성능 비교</span><span class="sxs-lookup"><span data-stu-id="c3926-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="c3926-357">기본 페이징은 반환 하는 반면 에서만 사용자 지정 페이징을 필요한 레코드를 검색 하므로 *모든* 표시 되는 각 페이지에 대 한 레코드의 해당 s 사용자 지정 페이징을 기본 페이징은 보다 더 효율적 임을 선택을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="c3926-358">그러나 훨씬 더 효율적으로 사용자 지정 페이징을?</span><span class="sxs-lookup"><span data-stu-id="c3926-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="c3926-359">사용자 지정 페이징을 기본 페이징에서 이동 하 여 어떤 종류의 성능 향상을 확인할 수 있습니다?</span><span class="sxs-lookup"><span data-stu-id="c3926-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="c3926-360">아쉽게도 있는 s 상황에 맞는 모든 여기에 답변 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="c3926-361">다양 한 요인에 따라 달라 집니다 성능 향상, 웹 서버와 데이터베이스 서버 간의 데이터베이스 서버와 통신 채널을 통해 페이징 되 고 레코드와 로드 기간 두가 배치 가장 두드러진 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="c3926-362">소수의 수십 개의 레코드를 사용 하 여 작은 테이블에 대 한 성능 차이 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="c3926-363">그러나 수천 개의 행을 수백 수천 개의 대형 테이블에 대 한 성능 차이 예입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="c3926-364">필자의 아티클을 [SQL Server 2005를 사용 하 여 ASP.NET 2.0의 사용자 지정 페이징](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), 데이터베이스 테이블에 페이징 하는 경우 이러한 두 페이징 기술 간 성능 차이 보이게 필자는 몇 가지 성능 테스트가 포함 50,000 개의 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="c3926-365">이러한 테스트에서 SQL Server 수준에서 쿼리를 실행 하는 시간이 모두 살펴봤습니다 (사용 하 여 [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) 및 사용 하 여 ASP.NET 페이지 [ASP.NET 추적 기능](https://msdn.microsoft.com/library/y13fw6we.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="c3926-366">이러한 테스트 단일 활성 사용자를 사용 하 여 개발 상자 내에서 실행 된 및 따라서 과학 없는 일반적인 웹 사이트 부하 패턴을 모방 하지 마십시오 염두에서에 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="c3926-367">그럼에도 불구 하 고 결과 충분히 많은 양의 데이터를 사용 하 여 작업 하는 경우 기본 인스턴스 및 사용자 지정 페이징을 실행 시간이 상대 차이점을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="c3926-368">**평균 기간 (초)**</span><span class="sxs-lookup"><span data-stu-id="c3926-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="c3926-369">**읽기**</span><span class="sxs-lookup"><span data-stu-id="c3926-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c3926-370">**기본 SQL Profiler 페이징**</span><span class="sxs-lookup"><span data-stu-id="c3926-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="c3926-371">1.411</span><span class="sxs-lookup"><span data-stu-id="c3926-371">1.411</span></span> | <span data-ttu-id="c3926-372">383</span><span class="sxs-lookup"><span data-stu-id="c3926-372">383</span></span> |
| <span data-ttu-id="c3926-373">**사용자 지정 페이징 SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="c3926-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="c3926-374">0.002</span><span class="sxs-lookup"><span data-stu-id="c3926-374">0.002</span></span> | <span data-ttu-id="c3926-375">29</span><span class="sxs-lookup"><span data-stu-id="c3926-375">29</span></span> |
| <span data-ttu-id="c3926-376">**기본 페이징 ASP.NET 추적**</span><span class="sxs-lookup"><span data-stu-id="c3926-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="c3926-377">2.379</span><span class="sxs-lookup"><span data-stu-id="c3926-377">2.379</span></span> | <span data-ttu-id="c3926-378">*해당 없음*</span><span class="sxs-lookup"><span data-stu-id="c3926-378">*N/A*</span></span> |
| <span data-ttu-id="c3926-379">**사용자 지정 페이징 ASP.NET 추적**</span><span class="sxs-lookup"><span data-stu-id="c3926-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="c3926-380">0.029</span><span class="sxs-lookup"><span data-stu-id="c3926-380">0.029</span></span> | <span data-ttu-id="c3926-381">*해당 없음*</span><span class="sxs-lookup"><span data-stu-id="c3926-381">*N/A*</span></span> |


<span data-ttu-id="c3926-382">알 수 있듯이 평균 읽기 덜 354 필요한 데이터의 특정 페이지를 검색 하 고 시간에 비해 훨씬 빨리 완료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="c3926-383">ASP.NET 페이지에서 사용자 지정 페이지 있었습니다 1/100에 가까우면에 렌더링할<sup>번째</sup> 기본 페이징을 사용 하는 경우 걸린 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="c3926-384">참조 [필자의 기사](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) 코드 및 데이터베이스와 함께 이러한 결과 대 한 자세한 내용은 자신의 환경에서 이러한 테스트를 재현 하는 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="c3926-385">요약</span><span class="sxs-lookup"><span data-stu-id="c3926-385">Summary</span></span>

<span data-ttu-id="c3926-386">기본 페이징은 데이터 웹 컨트롤 s 스마트 태그에만 확인 페이징 사용 확인란을 구현 하기가 매우 쉽습니다 이지만 성능 하더라도 이러한 단순성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="c3926-387">사용자 데이터의 모든 페이지를 요청할 때 기본 페이징을 *모든* 정도의 작은 일부만 표시 될 수 있지만 레코드가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="c3926-388">이 성능 오버 헤드를 방지 하기 위해 ObjectDataSource를 대체 페이징 옵션 사용자 지정 페이징을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="c3926-389">사용자 지정 페이징을 표시 되어야 하는 레코드를 검색 하 여 s 성능 문제를 페이징 하는 기본 특징을 향상 하는 동안 해당 s 사용자 지정 페이징을 구현 하기가 더 복잡된 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="c3926-390">먼저 (올바르고 효율적으로)에 액세스 하는 요청 되는 레코드의 특정 하위 집합 쿼리를 작성 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="c3926-391">다양 한 방법으로;에서이 작업을 수행할 수 있습니다. 새 SQL Server 2005 s를 사용 하는이 자습서에서는 검사할 것 `ROW_NUMBER()` 순위를 매기는 함수 결과 한 다음만 반환할 결과 해당 순위 지정된 된 범위에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="c3926-392">또한를 통해 페이징 되 고 레코드의 총 수를 확인 하는 수단을 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="c3926-393">이러한 BLL 및 DAL 메서드를 만든 후도 총 레코드 수를 통해 페이징 되는 및 BLL에 시작 하는 행 인덱스 및 최대 행 수 값을 전달 올바르게 수를 알 수 있도록 ObjectDataSource를 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="c3926-394">사용자 지정 페이징을 구현 단계 수가 필요가 고 아니더라도 기본 페이징은 하기만 하는 동안 사용자 지정 페이징을 충분히 많은 양의 데이터를 페이징 하는 경우 반드시 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="c3926-395">결과 검사 따르면, 사용자 지정 페이징 ASP.NET 페이지의 렌더링 시간에서 초를 버릴 수 하 고 하나 이상의 엄청나게 데이터베이스 서버의 부하를 옅게 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="c3926-396">즐거운 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="c3926-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="c3926-397">저자 소개</span><span class="sxs-lookup"><span data-stu-id="c3926-397">About the Author</span></span>

<span data-ttu-id="c3926-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적의 저자 이자 설립자입니다 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 Microsoft 웹 기술을 사용 하 여 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="c3926-399">Scott는 독립 컨설턴트, 강사, 그리고 기록기로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="c3926-400">최근 저서는 [ *Sams 설명 직접 ASP.NET 2.0 24 시간 동안의*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="c3926-401">그에 도달할 수 있습니다 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="c3926-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="c3926-402">찾을 수 있는 저자의 블로그를 통해 또는 [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="c3926-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="c3926-403">[이전](paging-and-sorting-report-data-vb.md)
> [다음](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="c3926-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
