---
uid: web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
title: "SqlDataSource (VB)를 사용 하 여 낙관적 동시성 구현 | Microsoft Docs"
author: rick-anderson
description: "이 자습서에서는 낙관적 동시성 제어에 대 한 필수 정보를 검토 한 다음 SqlDataSource 컨트롤을 사용 하 여 구현 하는 방법을 탐색 합니다."
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2007
ms.topic: article
ms.assetid: a8fa72ee-8328-4854-a419-c1b271772303
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
msc.type: authoredcontent
ms.openlocfilehash: 603aaa35a533fc8853ea72fc9be05ca82b213049
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/10/2017
---
<a name="implementing-optimistic-concurrency-with-the-sqldatasource-vb"></a><span data-ttu-id="2a54a-103">SqlDataSource (VB)를 사용 하 여 낙관적 동시성을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-103">Implementing Optimistic Concurrency with the SqlDataSource (VB)</span></span>
====================
<span data-ttu-id="2a54a-104">으로 [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="2a54a-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="2a54a-105">[샘플 앱을 다운로드](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe) 또는 [PDF 다운로드](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="2a54a-105">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe) or [Download PDF](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span></span>

> <span data-ttu-id="2a54a-106">이 자습서에서는 낙관적 동시성 제어에 대 한 필수 정보를 검토 한 다음 SqlDataSource 컨트롤을 사용 하 여 구현 하는 방법을 탐색 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-106">In this tutorial we review the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource control.</span></span>


## <a name="introduction"></a><span data-ttu-id="2a54a-107">소개</span><span class="sxs-lookup"><span data-stu-id="2a54a-107">Introduction</span></span>

<span data-ttu-id="2a54a-108">이전 자습서에서 삽입, 업데이트 및 삭제 기능 SqlDataSource 컨트롤을 추가 하는 방법을 검사 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-108">In the preceding tutorial we examined how to add inserting, updating, and deleting capabilities to the SqlDataSource control.</span></span> <span data-ttu-id="2a54a-109">즉, 이러한 기능을 제공 하려면 म 지정 하도록 필요한 해당 `INSERT`, `UPDATE`, 또는 `DELETE` s 컨트롤에서 SQL 문을 `InsertCommand`, `UpdateCommand`, 또는 `DeleteCommand` 속성을 적절 한 함께 매개 변수는 `InsertParameters`, `UpdateParameters`, 및 `DeleteParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-109">In short, to provide these features we needed to specify the corresponding `INSERT`, `UPDATE`, or `DELETE` SQL statement in the control s `InsertCommand`, `UpdateCommand`, or `DeleteCommand` properties, along with the appropriate parameters in the `InsertParameters`, `UpdateParameters`, and `DeleteParameters` collections.</span></span> <span data-ttu-id="2a54a-110">데이터 소스 구성 마법사 s 고급 단추는 생성을 제공 하는 동안 이러한 속성 및 컬렉션을 지정할 수 수동으로 `INSERT`, `UPDATE`, 및 `DELETE` 자동-만들어집니다 이러한 문은 문을 확인란에 따라는 `SELECT` 문.</span><span class="sxs-lookup"><span data-stu-id="2a54a-110">While these properties and collections can be specified manually, the Configure Data Source wizard s Advanced button offers a Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox that will auto-create these statements based on the `SELECT` statement.</span></span>

<span data-ttu-id="2a54a-111">생성 함께 `INSERT`, `UPDATE`, 및 `DELETE` 사용 하 여 낙관적 동시성 옵션을 포함 하는 문을 확인란, 고급 SQL 생성 옵션 대화 상자 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="2a54a-111">Along with the Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox, the Advanced SQL Generation Options dialog box includes a Use optimistic concurrency option (see Figure 1).</span></span> <span data-ttu-id="2a54a-112">옵션을 선택 하면는 `WHERE` 절에는 자동으로 생성 된 `UPDATE` 및 `DELETE` delete 기본 데이터베이스 데이터 않았음을 t 사용자 이후 수정 된 경우 마지막 데이터를 로드할 ड आ 또는 문은 업데이트를 수행 하도록 수정 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-112">When checked, the `WHERE` clauses in the autogenerated `UPDATE` and `DELETE` statements are modified to only perform the update or delete if the underlying database data hasn t been modified since the user last loaded the data into the grid.</span></span>


![지원을 추가 하는 낙관적 동시성에서 고급 SQL 생성 옵션 대화 상자](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.gif)

<span data-ttu-id="2a54a-114">**그림 1**: 지원을 추가 하는 낙관적 동시성에서 고급 SQL 생성 옵션 대화 상자</span><span class="sxs-lookup"><span data-stu-id="2a54a-114">**Figure 1**: You Can Add Optimistic Concurrency Support from the Advanced SQL Generation Options Dialog Box</span></span>


<span data-ttu-id="2a54a-115">에 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 자습서는 ObjectDataSource에 추가 하는 방법과 낙관적 동시성 제어에 대 한 기본적인 검사 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-115">Back in the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial we examined the fundamentals of optimistic concurrency control and how to add it to the ObjectDataSource.</span></span> <span data-ttu-id="2a54a-116">이 자습서에서는 낙관적 동시성 제어 essentials 재손질 알아보고 SqlDataSource를 사용 하 여 구현 하는 방법을 탐색 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-116">In this tutorial we'll retouch on the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource.</span></span>

## <a name="a-recap-of-optimistic-concurrency"></a><span data-ttu-id="2a54a-117">낙관적 동시성에 대해 간략하게 설명</span><span class="sxs-lookup"><span data-stu-id="2a54a-117">A Recap of Optimistic Concurrency</span></span>

<span data-ttu-id="2a54a-118">여러 명의 웹 응용 프로그램에 대 한 동시 사용자가 편집 하거나 동일한 데이터를 삭제할 수 있을 가능성이 사용자 다른 s 변경 내용을 실수로 덮어쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-118">For web applications that allow multiple, simultaneous users to edit or delete the same data, there exists a possibility that one user may accidentally overwrite another s changes.</span></span> <span data-ttu-id="2a54a-119">에 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 다음 예제를 제공 하려면 자습서:</span><span class="sxs-lookup"><span data-stu-id="2a54a-119">In the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial I provided the following example:</span></span>

<span data-ttu-id="2a54a-120">사용자 이영희, Jisun 및 Sam을 둘 다 방문 페이지를 업데이트 하는 GridView 컨트롤을 통해 제품 삭제 방문자를 허용 하는 응용 프로그램에 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-120">Imagine that two users, Jisun and Sam, were both visiting a page in an application that allowed visitors to update and delete products through a GridView control.</span></span> <span data-ttu-id="2a54a-121">Chai 편집 단추를 클릭 둘 다에서 같은 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-121">Both click the Edit button for Chai around the same time.</span></span> <span data-ttu-id="2a54a-122">Jisun 제품 이름을 Chai 찻잔으로 변경 하 고 업데이트 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-122">Jisun changes the product name to Chai Tea and clicks the Update button.</span></span> <span data-ttu-id="2a54a-123">결과는 `UPDATE` 설정 하는 데이터베이스에 전송 되는 문을 *모든* 제품 s 업데이트할 수 있는 필드 (Jisun만 한 필드를 업데이트 하는 경우에 `ProductName`).</span><span class="sxs-lookup"><span data-stu-id="2a54a-123">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product s updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="2a54a-124">이 시점에서, 데이터베이스에는 공급 업체 삼 화 음료,이 특정 제품에 대해 Chai 차를 음료, 범주 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-124">At this point in time, the database has the values Chai Tea, the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="2a54a-125">그러나 Sam의 화면에 GridView 여전히 표시 제품 이름을 편집 가능한 GridView 행에서 Chai로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-125">However, the GridView on Sam s screen still shows the product name in the editable GridView row as Chai.</span></span> <span data-ttu-id="2a54a-126">몇 초 후 Jisun의 변경 사항이 커밋되기 Sam 조미료 하는 범주를 업데이트 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-126">A few seconds after Jisun s changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="2a54a-127">이 인해는 `UPDATE` Chai을 제품 이름으로 설정 하는 데이터베이스에 보내는 문은 `CategoryID` 해당 입력 하면 조미료 범주 ID 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-127">This results in an `UPDATE` statement sent to the database that sets the product name to Chai, the `CategoryID` to the corresponding Condiments category ID, and so on.</span></span> <span data-ttu-id="2a54a-128">제품 이름에 대 한 s 변경 Jisun 덮어썼습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-128">Jisun s changes to the product name have been overwritten.</span></span>

<span data-ttu-id="2a54a-129">그림 2에서는이 상호 작용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-129">Figure 2 illustrates this interaction.</span></span>


<span data-ttu-id="2a54a-130">[![두 명의 사용자가 동시에 레코드를 업데이트 하는 경우 있습니다 s 잠재적인 s 한 명의 사용자에 대 한 변경을 다른를 덮어쓰려면](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-130">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span></span>

<span data-ttu-id="2a54a-131">**그림 2**: 다른 s Overwrite로 때 두 사용자가 동시에 업데이트 된 레코드가 있습니다 s 가능성 s 한 명의 사용자에 대 한 변경 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-131">**Figure 2**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span></span>


<span data-ttu-id="2a54a-132">이 시나리오의 형태를 펼치기 하지 않도록 하려면 [동시성 제어](http://en.wikipedia.org/wiki/Concurrency_control) 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-132">To prevent this scenario from unfolding, a form of [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) must be implemented.</span></span> <span data-ttu-id="2a54a-133">[낙관적 동시성](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) 이 자습서의 포커스는 되어 있어도 동시성 충돌 합니다, 대부분의 이러한 충돌 t 성공한 시간 발생 가정 하에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-133">[Optimistic concurrency](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) the focus of this tutorial works on the assumption that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won t arise.</span></span> <span data-ttu-id="2a54a-134">따라서 한 충돌이 발생 하는 경우 낙관적 동시성 제어 단순히 사용자에 게 알려 다른 사용자가 동일한 데이터를 수정 하기 때문에 해당 변경 내용 수 없습니다. 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-134">Therefore, if a conflict does arise, optimistic concurrency control simply informs the user that their changes can t be saved because another user has modified the same data.</span></span>

> [!NOTE]
> <span data-ttu-id="2a54a-135">응용 프로그램의 것 많은 동시성 충돌 하거나 이러한 충돌 지속할 수 없는 경우 가정 있는 경우 다음 비관적 동시성 제어 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-135">For applications where it is assumed that there will be many concurrency conflicts or if such conflicts are not tolerable, then pessimistic concurrency control can be used instead.</span></span> <span data-ttu-id="2a54a-136">다시 참조는 [낙관적 동시성 구현](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) 비관적 동시성 제어에 보다 철저 한 토론에 대 한 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-136">Refer back to the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial for a more thorough discussion on pessimistic concurrency control.</span></span>


<span data-ttu-id="2a54a-137">낙관적 동시성 제어는 업데이트 또는 삭제 프로세스를 시작할 때 업데이트 되거나 삭제 되는 레코드에 동일한 값에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-137">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="2a54a-138">예를 들어 편집 가능한 GridView에 있는 편집 단추를 클릭 하면 s 레코드 값은 데이터베이스에서 읽고 입력란 및 기타 웹 컨트롤에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-138">For example, when clicking the Edit button in an editable GridView, the record s values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="2a54a-139">GridView에서 원래 값이 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-139">These original values are saved by the GridView.</span></span> <span data-ttu-id="2a54a-140">나중에 사용자가 변경 하 고 업데이트 단추를 클릭 한 후의 `UPDATE` 사용 된 문을 원래 값과 새 값을 고려 하 고 원래 값을 사용자가 편집을 시작 하는 경우에 기본 데이터베이스 레코드를 업데이트 해야 데이터베이스에 여전히 값으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-140">Later, after the user makes her changes and clicks the Update button, the `UPDATE` statement used must take into account the original values plus the new values and only update the underlying database record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="2a54a-141">그림 3에서는이 이벤트 시퀀스를를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-141">Figure 3 depicts this sequence of events.</span></span>


<span data-ttu-id="2a54a-142">[![성공 하려면 Update 또는 Delete에 대 한 원래 값을 현재 데이터베이스 값 이어야 합니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-142">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span></span>

<span data-ttu-id="2a54a-143">**그림 3**: For Update 또는 Delete는 원래 값 해야 수와 같으면 현재 데이터베이스 값 Succeed로 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-143">**Figure 3**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span></span>


<span data-ttu-id="2a54a-144">낙관적 동시성을 구현 하는 방법은 여러 가지가 (참조 [Peter A. Bromberg](http://peterbromberg.net/) s [Optmistic 동시성 업데이트 논리](http://www.eggheadcafe.com/articles/20050719.asp) 다양 한 옵션에 대 한 간단한 설명에 대 한).</span><span class="sxs-lookup"><span data-stu-id="2a54a-144">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/) s [Optmistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="2a54a-145">SqlDataSource (뿐만 아니라 ADO.NET 형식화 된 데이터 집합에서 데이터 액세스 계층에서 사용)를 사용 하는 방법 확대는 `WHERE` 절 모든 원래 값의 비교를 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-145">The technique used by the SqlDataSource (as well as by the ADO.NET Typed DataSets used in our Data Access Layer) augments the `WHERE` clause to include a comparison of all of the original values.</span></span> <span data-ttu-id="2a54a-146">다음 `UPDATE` 문, 현재 데이터베이스 값을 GridView에서 레코드를 업데이트할 때 처음 검색 된 값은 경우에 해당 이름 및 제품의 가격을 예를 들어 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-146">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="2a54a-147">`@ProductName` 및 `@UnitPrice` 반면 매개 변수는 사용자가 입력 한 새 값이 들어 `@original_ProductName` 및 `@original_UnitPrice` 편집 단추 클릭 했을 때 GridView에 원래 로드 된 값이 포함:</span><span class="sxs-lookup"><span data-stu-id="2a54a-147">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample1.sql)]

<span data-ttu-id="2a54a-148">이 자습서에서는 볼 수 있겠지만, SqlDataSource로 낙관적 동시성 제어를 사용 하도록 설정 작업은을 확인란을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-148">As we'll see in this tutorial, enabling optimistic concurrency control with the SqlDataSource is as simple as checking a checkbox.</span></span>

## <a name="step-1-creating-a-sqldatasource-that-supports-optimistic-concurrency"></a><span data-ttu-id="2a54a-149">1 단계: 낙관적 동시성을 지원 하는 SqlDataSource 만들기</span><span class="sxs-lookup"><span data-stu-id="2a54a-149">Step 1: Creating a SqlDataSource that Supports Optimistic Concurrency</span></span>

<span data-ttu-id="2a54a-150">열어 시작는 `OptimisticConcurrency.aspx` 에서 페이지는 `SqlDataSource` 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-150">Start by opening the `OptimisticConcurrency.aspx` page from the `SqlDataSource` folder.</span></span> <span data-ttu-id="2a54a-151">설정 디자이너 도구 상자에서 SqlDataSource 컨트롤을 끌어 해당 `ID` 속성을 `ProductsDataSourceWithOptimisticConcurrency`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-151">Drag a SqlDataSource control from the Toolbox onto the Designer, settings its `ID` property to `ProductsDataSourceWithOptimisticConcurrency`.</span></span> <span data-ttu-id="2a54a-152">다음으로, 컨트롤 s 스마트 태그에서 데이터 소스 구성 링크를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-152">Next, click on the Configure Data Source link from the control s smart tag.</span></span> <span data-ttu-id="2a54a-153">마법사의 첫 번째 화면에서 사용 하도록 선택 된 `NORTHWINDConnectionString` 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-153">From the first screen in the wizard, choose to work with the `NORTHWINDConnectionString` and click Next.</span></span>


<span data-ttu-id="2a54a-154">[![위해 작업 선택](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-154">[![Choose to Work with the NORTHWINDConnectionString](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span></span>

<span data-ttu-id="2a54a-155">**그림 4**: 사용 하도록 선택 된 `NORTHWINDConnectionString` ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-155">**Figure 4**: Choose to Work with the `NORTHWINDConnectionString` ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span></span>


<span data-ttu-id="2a54a-156">사용자가을 편집할 수 있도록 하는 GridView 추가 되므로이 예는 `Products` 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-156">For this example we'll be adding a GridView that enables users to edit the `Products` table.</span></span> <span data-ttu-id="2a54a-157">따라서 Select 문 화면 구성에서 선택 된 `Products` 드롭 다운 목록에서 테이블을 선택한는 `ProductID`, `ProductName`, `UnitPrice`, 및 `Discontinued` 그림 5에 표시 된 것 처럼 열.</span><span class="sxs-lookup"><span data-stu-id="2a54a-157">Therefore, from the Configure the Select Statement screen, choose the `Products` table from the drop-down list and select the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` columns, as shown in Figure 5.</span></span>


<span data-ttu-id="2a54a-158">[![Products 테이블에서 ProductID, ProductName, UnitPrice, 및 열에 지원 되지 않는 반환](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-158">[![From the Products Table, Return the ProductID, ProductName, UnitPrice, and Discontinued Columns](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span></span>

<span data-ttu-id="2a54a-159">**그림 5**:에서 `Products` 테이블에서 반환 된 `ProductID`, `ProductName`, `UnitPrice`, 및 `Discontinued` 열 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-159">**Figure 5**: From the `Products` Table, Return the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` Columns ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span></span>


<span data-ttu-id="2a54a-160">열을 선택한 후 고급 SQL 생성 옵션 대화 상자를 표시 하는 고급 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-160">After picking the columns, click the Advanced button to bring up the Advanced SQL Generation Options dialog box.</span></span> <span data-ttu-id="2a54a-161">생성 확인 `INSERT`, `UPDATE`, 및 `DELETE` 문을 낙관적 동시성 확인란 사용 하 여 한 확인을 클릭 하 고 (다시 그림 1 참조 스크린 샷을 대 한).</span><span class="sxs-lookup"><span data-stu-id="2a54a-161">Check the Generate `INSERT`, `UPDATE`, and `DELETE` statements and Use optimistic concurrency checkboxes and click OK (refer back to Figure 1 for a screenshot).</span></span> <span data-ttu-id="2a54a-162">다음을 클릭 하 여 마법사를 완료 한 다음 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-162">Complete the wizard by clicking Next, then Finish.</span></span>

<span data-ttu-id="2a54a-163">데이터 소스 구성 마법사를 완료 한 후 결과 검사 하려면 잠시 시간이 걸릴 `DeleteCommand` 및 `UpdateCommand` 속성 및 `DeleteParameters` 및 `UpdateParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-163">After completing the Configure Data Source wizard, take a moment to examine the resulting `DeleteCommand` and `UpdateCommand` properties and the `DeleteParameters` and `UpdateParameters` collections.</span></span> <span data-ttu-id="2a54a-164">이 작업을 수행 하는 가장 쉬운 방법은 소스 탭 페이지 s 선언적 구문 하단 왼쪽된 모서리 쪽에서 클릭 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-164">The easiest way to do this is to click on the Source tab in the lower left corner to see the page s declarative syntax.</span></span> <span data-ttu-id="2a54a-165">있을 것는 `UpdateCommand` 값:</span><span class="sxs-lookup"><span data-stu-id="2a54a-165">There you will find an `UpdateCommand` value of:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample2.sql)]

<span data-ttu-id="2a54a-166">7 개의 매개 변수를는 `UpdateParameters` 컬렉션:</span><span class="sxs-lookup"><span data-stu-id="2a54a-166">With seven parameters in the `UpdateParameters` collection:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample3.aspx)]

<span data-ttu-id="2a54a-167">마찬가지로,는 `DeleteCommand` 속성 및 `DeleteParameters` 컬렉션은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-167">Similarly, the `DeleteCommand` property and `DeleteParameters` collection should look like the following:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample4.sql)]


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample5.aspx)]

<span data-ttu-id="2a54a-168">보충 하며는 `WHERE` 절은 `UpdateCommand` 및 `DeleteCommand` 속성 (및 해당 매개 변수 컬렉션에 추가 매개 변수를 추가)을 사용 하 여 낙관적 동시성 옵션을 조정 두 개의 다른 선택 하면 속성:</span><span class="sxs-lookup"><span data-stu-id="2a54a-168">In addition to augmenting the `WHERE` clauses of the `UpdateCommand` and `DeleteCommand` properties (and adding the additional parameters to the respective parameter collections), selecting the Use optimistic concurrency option adjusts two other properties:</span></span>

- <span data-ttu-id="2a54a-169">변경 된 [ `ConflictDetection` 속성](https://msdn.microsoft.com/en-US/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) 에서 `OverwriteChanges` (기본값)를`CompareAllValues`</span><span class="sxs-lookup"><span data-stu-id="2a54a-169">Changes the [`ConflictDetection` property](https://msdn.microsoft.com/en-US/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) from `OverwriteChanges` (the default) to `CompareAllValues`</span></span>
- <span data-ttu-id="2a54a-170">변경 된 [ `OldValuesParameterFormatString` 속성](https://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) 원래 (기본값) {0}에서\_{0}.</span><span class="sxs-lookup"><span data-stu-id="2a54a-170">Changes the [`OldValuesParameterFormatString` property](https://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) from {0} (the default) to original\_{0} .</span></span>

<span data-ttu-id="2a54a-171">웹 컨트롤 데이터 SqlDataSource s를 호출 하는 경우 `Update()` 또는 `Delete()` 원래 값 메서드를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-171">When the data Web control invokes the SqlDataSource s `Update()` or `Delete()` method, it passes in the original values.</span></span> <span data-ttu-id="2a54a-172">경우 SqlDataSource s `ConflictDetection` 속성이 `CompareAllValues`, 원래 값이 명령에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-172">If the SqlDataSource s `ConflictDetection` property is set to `CompareAllValues`, these original values are added to the command.</span></span> <span data-ttu-id="2a54a-173">`OldValuesParameterFormatString` 속성은 이러한 원래 값 매개 변수에 대해 사용 되는 명명 패턴을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-173">The `OldValuesParameterFormatString` property provides the naming pattern used for these original value parameters.</span></span> <span data-ttu-id="2a54a-174">데이터 소스 구성 마법사를 사용 하 여 원래\_{0} 각 원래 매개 변수 이름을 지정 하 고는 `UpdateCommand` 및 `DeleteCommand` 속성 및 `UpdateParameters` 및 `DeleteParameters` 컬렉션 적절 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-174">The Configure Data Source wizard uses original\_{0} and names each original parameter in the `UpdateCommand` and `DeleteCommand` properties and `UpdateParameters` and `DeleteParameters` collections accordingly.</span></span>

> [!NOTE]
> <span data-ttu-id="2a54a-175">SqlDataSource 컨트롤 s 삽입 기능을 사용 하지 다시 म 간편 하 게 제거 하므로 `InsertCommand` 속성 및 해당 `InsertParameters` 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-175">Since we re not using the SqlDataSource control s inserting capabilities, feel free to remove the `InsertCommand` property and its `InsertParameters` collection.</span></span>


## <a name="correctly-handlingnullvalues"></a><span data-ttu-id="2a54a-176">올바르게 처리`NULL`값</span><span class="sxs-lookup"><span data-stu-id="2a54a-176">Correctly Handling`NULL`Values</span></span>

<span data-ttu-id="2a54a-177">안타깝게도, 보강 된 `UPDATE` 및 `DELETE` 낙관적 동시성을 사용 하는 경우 데이터 소스 구성 마법사에 의해 자동 생성 된 문을 수행 *하지* 포함 된 레코드는 관련 작업을 수행할 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-177">Unfortunately, the augmented `UPDATE` and `DELETE` statements autogenerated by the Configure Data Source wizard when using optimistic concurrency do *not* work with records that contain `NULL` values.</span></span> <span data-ttu-id="2a54a-178">그 이유를 보려면 우리의 SqlDataSource s 고려 `UpdateCommand`:</span><span class="sxs-lookup"><span data-stu-id="2a54a-178">To see why, consider our SqlDataSource s `UpdateCommand`:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample6.sql)]

<span data-ttu-id="2a54a-179">`UnitPrice` 열에는 `Products` 테이블 있을 수 있습니다 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-179">The `UnitPrice` column in the `Products` table can have `NULL` values.</span></span> <span data-ttu-id="2a54a-180">특정 레코드는 `NULL` 값 `UnitPrice`, `WHERE` 절 부분 `[UnitPrice] = @original_UnitPrice` 됩니다 *항상* 때문에 False로 평가 `NULL = NULL` 항상 False를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-180">If a particular record has a `NULL` value for `UnitPrice`, the `WHERE` clause portion `[UnitPrice] = @original_UnitPrice` will *always* evaluate to False because `NULL = NULL` always returns False.</span></span> <span data-ttu-id="2a54a-181">따라서 레코드 포함 하는 `NULL` 값 편집 또는 삭제 될 수 없습니다로 `UPDATE` 및 `DELETE` 문을 `WHERE` 절이 t 반환 행을 업데이트 하거나 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-181">Therefore, records that contain `NULL` values cannot be edited or deleted, as the `UPDATE` and `DELETE` statements `WHERE` clauses won t return any rows to update or delete.</span></span>

> [!NOTE]
> <span data-ttu-id="2a54a-182">이 버그에 처음 보고 되었지만 Microsoft의 2004 년 6 월에에 [SqlDataSource 생성 된 잘못 된 SQL 문을](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) 않으며 나타내기 ASP.NET의 다음 버전에서 수정 될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-182">This bug was first reported to Microsoft in June of 2004 in [SqlDataSource Generates Incorrect SQL Statements](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) and is reportedly scheduled to be fixed in the next version of ASP.NET.</span></span>


<span data-ttu-id="2a54a-183">이 해결 하려면 수동으로 업데이트 해야는 `WHERE` 절 모두에 `UpdateCommand` 및 `DeleteCommand` 에 대 한 속성 **모든** 가질 수 있는 열 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-183">To fix this, we have to manually update the `WHERE` clauses in both the `UpdateCommand` and `DeleteCommand` properties for **all** columns that can have `NULL` values.</span></span> <span data-ttu-id="2a54a-184">일반적으로 변경 `[ColumnName] = @original_ColumnName` 에:</span><span class="sxs-lookup"><span data-stu-id="2a54a-184">In general, change `[ColumnName] = @original_ColumnName` to:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample7.sql)]

<span data-ttu-id="2a54a-185">이 수정 업데이트 나 속성 창에서 UpdateQuery 또는 DeleteQuery 옵션을 통해 선언적 태그를 통해 직접 구성할 수 있으며 사용자 지정 SQL 문 또는 구성 데이터의 저장된 프로시저 옵션 지정에서 탭을 삭제 소스 마법사입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-185">This modification can be made directly through the declarative markup, via the UpdateQuery or DeleteQuery options from the Properties window, or through the UPDATE and DELETE tabs in the Specify a custom SQL statement or stored procedure option in the Configure Data Source wizard.</span></span> <span data-ttu-id="2a54a-186">이 수정 작업에 대 한 다시 이루어져야 합니다 *모든* 열에는 `UpdateCommand` 및 `DeleteCommand` s `WHERE` 포함 될 수 있는 절 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-186">Again, this modification must be made for *every* column in the `UpdateCommand` and `DeleteCommand` s `WHERE` clause that can contain `NULL` values.</span></span>

<span data-ttu-id="2a54a-187">수정 된 결과이 예제를 적용 `UpdateCommand` 및 `DeleteCommand` 값:</span><span class="sxs-lookup"><span data-stu-id="2a54a-187">Applying this to our example results in the following modified `UpdateCommand` and `DeleteCommand` values:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample8.sql)]

## <a name="step-2-adding-a-gridview-with-edit-and-delete-options"></a><span data-ttu-id="2a54a-188">2 단계: 추가 편집 및 삭제 옵션을 사용 하는 GridView</span><span class="sxs-lookup"><span data-stu-id="2a54a-188">Step 2: Adding a GridView with Edit and Delete Options</span></span>

<span data-ttu-id="2a54a-189">낙관적 동시성을 지원 하도록 구성 된 SqlDataSource를 사용 했으므로 이제 남은 것 데이터 웹 컨트롤이 동시성 제어를 활용 하는 페이지를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-189">With the SqlDataSource configured to support optimistic concurrency, all that remains is to add a data Web control to the page that utilizes this concurrency control.</span></span> <span data-ttu-id="2a54a-190">이 자습서에 대 한 s 두 편집을 제공 하는 GridView 추가 및 삭제 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-190">For this tutorial, let s add a GridView that provides both edit and delete functionality.</span></span> <span data-ttu-id="2a54a-191">이를 위해는 GridView 집합과 디자이너 도구 상자에서 끌어 해당 `ID` 를 `Products`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-191">To accomplish this, drag a GridView from the Toolbox onto the Designer and set its `ID` to `Products`.</span></span> <span data-ttu-id="2a54a-192">GridView s 스마트 태그에서에 연결 하는 `ProductsDataSourceWithOptimisticConcurrency` 1 단계에서에서 추가한 SqlDataSource 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-192">From the GridView s smart tag, bind it to the `ProductsDataSourceWithOptimisticConcurrency` SqlDataSource control added in Step 1.</span></span> <span data-ttu-id="2a54a-193">마지막으로, 스마트 태그에서 사용 하도록 설정 편집 및 삭제 사용 옵션을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-193">Finally, check the Enable Editing and Enable Deleting options from the smart tag.</span></span>


<span data-ttu-id="2a54a-194">[![GridView SqlDataSource에 바인딩하고 편집 및 삭제를 사용 하도록 설정](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-194">[![Bind the GridView to the SqlDataSource and Enable Editing and Deleting](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span></span>

<span data-ttu-id="2a54a-195">**그림 6**: SqlDataSource 및 편집 사용 및 삭제 하는 중에 GridView 바인딩 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-195">**Figure 6**: Bind the GridView to the SqlDataSource and Enable Editing and Deleting ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span></span>


<span data-ttu-id="2a54a-196">GridView를 추가한 후의 모양을 제거 하 여 구성의 `ProductID` 변경 BoundField는 `ProductName` BoundField s `HeaderText` 속성을 제품 및 업데이트는 `UnitPrice` BoundField 되도록 해당 `HeaderText` 속성은 단순히 가격입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-196">After adding the GridView, configure its appearance by removing the `ProductID` BoundField, changing the `ProductName` BoundField s `HeaderText` property to Product, and updating the `UnitPrice` BoundField so that its `HeaderText` property is simply Price.</span></span> <span data-ttu-id="2a54a-197">편집 인터페이스에 대 한 RequiredFieldValidator 포함 하도록 향상 d 우리는 이상적으로 `ProductName` 값과에 대 한 CompareValidator는 `UnitPrice` 값 (s 올바른 형식의 숫자 값으로 확인)입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-197">Ideally, we d enhance the editing interface to include a RequiredFieldValidator for the `ProductName` value and a CompareValidator for the `UnitPrice` value (to ensure it s a properly formatted numeric value).</span></span> <span data-ttu-id="2a54a-198">참조는 [데이터 수정 인터페이스 사용자 지정](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) GridView s 편집 인터페이스를 사용자 지정에 대 한 자세한 설명에 대 한 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-198">Refer to the [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorial for a more in-depth look at customizing the GridView s editing interface.</span></span>

> [!NOTE]
> <span data-ttu-id="2a54a-199">SqlDataSource GridView에서 전달 되는 원래 값은 s 뷰 상태를 사용 해야 하는 GridView 뷰 상태에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-199">The GridView s view state must be enabled since the original values passed from the GridView to the SqlDataSource are stored in view state.</span></span>


<span data-ttu-id="2a54a-200">GridView에 이러한 수정에 확인 한 후 GridView 및 SqlDataSource 선언적 태그는 다음과 비슷하게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-200">After making these modifications to the GridView, the GridView and SqlDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample9.aspx)]

<span data-ttu-id="2a54a-201">작업에서 낙관적 동시성 제어를 보려면 두 개의 브라우저 창을 열고 로드는 `OptimisticConcurrency.aspx` 모두의 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-201">To see the optimistic concurrency control in action, open two browser windows and load the `OptimisticConcurrency.aspx` page in both.</span></span> <span data-ttu-id="2a54a-202">두 브라우저에에서 첫 번째 제품에 대 한 편집 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-202">Click on the Edit buttons for the first product in both browsers.</span></span> <span data-ttu-id="2a54a-203">하나의 브라우저에서 제품 이름을 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-203">In one browser, change the product name and click Update.</span></span> <span data-ttu-id="2a54a-204">브라우저에서 포스트백을 GridView 편집한 레코드에 대 한 새 제품 이름을 표시 하는 미리 편집 모드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-204">The browser will postback and the GridView will return to its pre-editing mode, showing the new product name for the record just edited.</span></span>

<span data-ttu-id="2a54a-205">두 번째 브라우저 창에서 제품 이름 원래 값으로 나감) (않음 가격을 변경 하 고 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-205">In the second browser window, change the price (but leave the product name as its original value) and click Update.</span></span> <span data-ttu-id="2a54a-206">다시 게시 될 눈금의 미리 편집 모드를 반환 하지만 가격에 대 한 변경 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-206">On postback, the grid returns to its pre-editing mode, but the change to the price is not recorded.</span></span> <span data-ttu-id="2a54a-207">두 번째 브라우저 이전 가격이 새 제품 이름 첫 번째 것과 동일한 값을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-207">The second browser shows the same value as the first one the new product name with the old price.</span></span> <span data-ttu-id="2a54a-208">두 번째 브라우저 창에서 변경한 내용을 손실 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-208">The changes made in the second browser window were lost.</span></span> <span data-ttu-id="2a54a-209">또한 변경 내용이 손실 자동 모드로 대신을 예외 또는 동시성 위반을 방금 발생 했음을 나타내는 메시지가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-209">Moreover, the changes were lost rather quietly, as there was no exception or message indicating that a concurrency violation just occurred.</span></span>


<span data-ttu-id="2a54a-210">[![두 번째 브라우저 창에서 변경 내용을 자동으로 손실 되었습니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-210">[![The Changes in the Second Browser Window Were Silently Lost](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span></span>

<span data-ttu-id="2a54a-211">**그림 7**: The 변경에는 두 번째 브라우저 창을 자동으로 손실 된 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-211">**Figure 7**: The Changes in the Second Browser Window Were Silently Lost ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span></span>


<span data-ttu-id="2a54a-212">두 번째 브라우저의 변경 내용이 커밋 이유 이유 때문에는 `UPDATE` 문이의 `WHERE` 절 모든 레코드를 필터링 및 따라서 모든 행에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-212">The reason why the second browser s changes were not committed was because the `UPDATE` statement s `WHERE` clause filtered out all records and therefore did not affect any rows.</span></span> <span data-ttu-id="2a54a-213">살펴보고 s는 `UPDATE` 문을 다시:</span><span class="sxs-lookup"><span data-stu-id="2a54a-213">Let s look at the `UPDATE` statement again:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample10.sql)]

<span data-ttu-id="2a54a-214">별도 브라우저 창이 레코드를 업데이트 하는 경우 원래 제품 이름에서 지정 된 `WHERE` (첫 번째 브라우저에서 변경 된) 이후 기존 제품 이름의 절 대상이 t 일치를 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-214">When the second browser window updates the record, the original product name specified in the `WHERE` clause doesn t match up with the existing product name (since it was changed by the first browser).</span></span> <span data-ttu-id="2a54a-215">따라서 문을 `[ProductName] = @original_ProductName` False를 반환 및 `UPDATE` 모든 레코드는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-215">Therefore, the statement `[ProductName] = @original_ProductName` returns False, and the `UPDATE` does not affect any records.</span></span>

> [!NOTE]
> <span data-ttu-id="2a54a-216">삭제 동일한 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-216">Delete works in the same manner.</span></span> <span data-ttu-id="2a54a-217">두 개의 브라우저 창을 열고, 하나로, 특정된 제품을 편집 하 고 변경 내용을 저장 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-217">With two browser windows open, start by editing a given product with one, and then saving its changes.</span></span> <span data-ttu-id="2a54a-218">변경 내용을 하나의 브라우저에을 저장 한 후 다른 동일한 제품에 대 한 삭제 단추를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-218">After saving the changes in the one browser, click the Delete button for the same product in the other.</span></span> <span data-ttu-id="2a54a-219">원래 값 don t와 일치 하므로 `DELETE` 문이의 `WHERE` 절을 delete 자동으로 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-219">Since the original values don t match up in the `DELETE` statement s `WHERE` clause, the delete silently fails.</span></span>


<span data-ttu-id="2a54a-220">두 번째 브라우저 창에서 최종 사용자의 관점에서 업데이트 단추를 클릭 한 후 모눈 미리 편집 모드를 반환 하지만 해당 변경 내용이 손실 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-220">From the end user s perspective in the second browser window, after clicking the Update button the grid returns to the pre-editing mode, but their changes were lost.</span></span> <span data-ttu-id="2a54a-221">그러나 여기서 s 자신의 변경 내용을 않았음에도 t 스티커 시각적 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-221">However, there s no visual feedback that their changes didn t stick.</span></span> <span data-ttu-id="2a54a-222">이상적으로 사용자 s 변경이 동시성 위반을 손실 했습니다 d 알려 서 and, 표 편집 모드에 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-222">Ideally, if a user s changes are lost to a concurrency violation, we d notify them and, perhaps, keep the grid in edit mode.</span></span> <span data-ttu-id="2a54a-223">이 수행 하는 방법에 대해 s를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-223">Let s look at how to accomplish this.</span></span>

## <a name="step-3-determining-when-a-concurrency-violation-has-occurred"></a><span data-ttu-id="2a54a-224">3 단계: 동시성 위반이 발생 했을 때 결정</span><span class="sxs-lookup"><span data-stu-id="2a54a-224">Step 3: Determining When a Concurrency Violation Has Occurred</span></span>

<span data-ttu-id="2a54a-225">변경 내용이 하나를 취소 하는 동시성 위반을, 때문에 동시성 위반이 발생 했을 때 사용자에 게 경고할 좋을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-225">Since a concurrency violation rejects the changes one has made, it would be nice to alert the user when a concurrency violation has occurred.</span></span> <span data-ttu-id="2a54a-226">사용자에 게 경고할 let s 라는 페이지의 맨 위에 레이블을 웹 컨트롤을 추가 `ConcurrencyViolationMessage` 인 `Text` 속성에는 다음과 같은 메시지가 표시 됩니다: 업데이트 하거나 다른 사용자가 동시에 업데이트 된 레코드를 삭제 하려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-226">To alert the user, let s add a Label Web control to the top of the page named `ConcurrencyViolationMessage` whose `Text` property displays the following message: You have attempted to update or delete a record that was simultaneously updated by another user.</span></span> <span data-ttu-id="2a54a-227">다른 사용자의 변경 내용을 검토 한 다음 업데이트를 다시 실행 하거나 삭제 하십시오.</span><span class="sxs-lookup"><span data-stu-id="2a54a-227">Please review the other user's changes and then redo your update or delete.</span></span> <span data-ttu-id="2a54a-228">Label 컨트롤 s 설정 `CssClass` 에 정의 된 속성 경고는 CSS 클래스를을 `Styles.css` 빨간색, 기울임꼴, 굵은 글꼴, 및 큰 글꼴로 텍스트를 표시 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-228">Set the Label control s `CssClass` property to Warning, which is a CSS class defined in `Styles.css` that displays text in a red, italic, bold, and large font.</span></span> <span data-ttu-id="2a54a-229">마지막으로, s 레이블 설정 `Visible` 및 `EnableViewState` 속성을 `False`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-229">Finally, set the Label s `Visible` and `EnableViewState` properties to `False`.</span></span> <span data-ttu-id="2a54a-230">이렇게 하면 명시적으로 설정할 포스트백에만 제외 하 고 레이블이 숨겨집니다 해당 `Visible` 속성을 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-230">This will hide the Label except for only those postbacks where we explicitly set its `Visible` property to `True`.</span></span>


<span data-ttu-id="2a54a-231">[![경고를 표시 하려면 페이지에 Label 컨트롤 추가](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-231">[![Add a Label Control to the Page to Display the Warning](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span></span>

<span data-ttu-id="2a54a-232">**그림 8**: 경고를 표시 하려면 페이지에 Label 컨트롤 추가 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-232">**Figure 8**: Add a Label Control to the Page to Display the Warning ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span></span>


<span data-ttu-id="2a54a-233">업데이트 또는 삭제, GridView s 수행할 때 `RowUpdated` 및 `RowDeleted` 이벤트 처리기를 해당 데이터 소스 컨트롤이 요청 된 업데이트 또는 삭제를 수행한 후 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-233">When performing an update or delete, the GridView s `RowUpdated` and `RowDeleted` event handlers fire after its data source control has performed the requested update or delete.</span></span> <span data-ttu-id="2a54a-234">행의 수가 이러한 이벤트 처리기에서 작업에 의해 영향을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-234">We can determine how many rows were affected by the operation from these event handlers.</span></span> <span data-ttu-id="2a54a-235">0 개의 행을 영향을 표시 하려면 원하는 `ConcurrencyViolationMessage` 레이블.</span><span class="sxs-lookup"><span data-stu-id="2a54a-235">If zero rows were affected, we want to display the `ConcurrencyViolationMessage` Label.</span></span>

<span data-ttu-id="2a54a-236">모두에 대 한 이벤트 처리기를 만들고는 `RowUpdated` 및 `RowDeleted` 이벤트를 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-236">Create an event handler for both the `RowUpdated` and `RowDeleted` events and add the following code:</span></span>


[!code-vb[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample11.vb)]

<span data-ttu-id="2a54a-237">두 이벤트 처리기에서 확인는 `e.AffectedRows` 속성 및 0 이면 설정는 `ConcurrencyViolationMessage` 레이블 s `Visible` 속성을 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-237">In both event handlers we check the `e.AffectedRows` property and, if it equals 0, set the `ConcurrencyViolationMessage` Label s `Visible` property to `True`.</span></span> <span data-ttu-id="2a54a-238">에 `RowUpdated` 이벤트 처리기도 하도록 지시를 설정 하 여 편집 모드에 유지 GridView는 `KeepInEditMode` 속성을 true로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-238">In the `RowUpdated` event handler, we also instruct the GridView to stay in edit mode by setting the `KeepInEditMode` property to true.</span></span> <span data-ttu-id="2a54a-239">이 과정에서 다른 s 사용자 데이터를 편집 하는 인터페이스에 로드 되도록 표에 데이터를 다시 바인딩할 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-239">In doing so, we need to rebind the data to the grid so that the other user s data is loaded into the editing interface.</span></span> <span data-ttu-id="2a54a-240">GridView s 호출 하 여 이렇게 `DataBind()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="2a54a-240">This is accomplished by calling the GridView s `DataBind()` method.</span></span>

<span data-ttu-id="2a54a-241">그림 9와 같이 이러한 두 개의 이벤트 처리기와 동시성 위반이 발생할 때마다 증가 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-241">As Figure 9 shows, with these two event handlers, a very noticeable message is displayed whenever a concurrency violation occurs.</span></span>


<span data-ttu-id="2a54a-242">[![동시성 위반을 한 경우에도 메시지가 표시 됩니다.](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="2a54a-242">[![A Message is Displayed in the Face of a Concurrency Violation](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span></span>

<span data-ttu-id="2a54a-243">**그림 9**: A 메시지가 동시성 위반이 발생 한 경우에도 표시 됩니다 ([전체 크기 이미지를 보려면 클릭](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span><span class="sxs-lookup"><span data-stu-id="2a54a-243">**Figure 9**: A Message is Displayed in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span></span>


## <a name="summary"></a><span data-ttu-id="2a54a-244">요약</span><span class="sxs-lookup"><span data-stu-id="2a54a-244">Summary</span></span>

<span data-ttu-id="2a54a-245">웹 응용 프로그램을 만들 때 위치, 여러 동시 사용자가 편집 하 고 동일한 데이터를 반드시 동시성 제어 옵션을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-245">When creating a web application where multiple, concurrent users may be editing the same data, it is important to consider concurrency control options.</span></span> <span data-ttu-id="2a54a-246">기본적으로 웹을 제어 하는 ASP.NET 데이터 및 데이터 소스 제어를 사용 하지 않는 모든 동시성 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-246">By default, the ASP.NET data Web controls and data source controls do not employ any concurrency control.</span></span> <span data-ttu-id="2a54a-247">이 자습서에서 살펴본 것 처럼 SqlDataSource로 낙관적 동시성 제어를 구현는 비교적 빠르고 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-247">As we saw in this tutorial, implementing optimistic concurrency control with the SqlDataSource is relatively quick and easy.</span></span> <span data-ttu-id="2a54a-248">SqlDataSource augmented 사용자 추가 대 한는 legwork 대부분 처리 `WHERE` 는 자동으로 생성 하는 절 `UPDATE` 및 `DELETE` 했지만 문은 처리에 몇 가지 미묘한 `NULL` 에 설명 된 대로 열을 값의 올바르게 처리 `NULL` 섹션 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-248">The SqlDataSource handles most of the legwork for your adding augmented `WHERE` clauses to the autogenerated `UPDATE` and `DELETE` statements but there are a few subtleties in handling `NULL` value columns, as discussed in the Correctly Handling `NULL` Values section.</span></span>

<span data-ttu-id="2a54a-249">SqlDataSource 검사 하 여으로이 자습서를 마칩니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-249">This tutorial concludes our examination of the SqlDataSource.</span></span> <span data-ttu-id="2a54a-250">나머지 자습서 우리의 ObjectDataSource 및 계층화 된 아키텍처를 사용 하 여 데이터 작업을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-250">Our remaining tutorials will return to working with data using the ObjectDataSource and tiered architecture.</span></span>

<span data-ttu-id="2a54a-251">만족도 매우 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="2a54a-251">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="2a54a-252">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="2a54a-252">About the Author</span></span>

<span data-ttu-id="2a54a-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적과의 창립자의 작성자 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 이후 Microsoft 웹 기술과 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="2a54a-254">Scott 독립 컨설턴트, 강사, 기술 및 작성기 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-254">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="2a54a-255">그의 최신 서적은 [ *Sam 업무량이 직접 ASP.NET 2.0 24 시간 동안에서*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-255">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="2a54a-256">에 연결할 수 그 [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) 에서 찾을 수 있는 그의 블로그를 통해 또는 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="2a54a-256">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

>[!div class="step-by-step"]
[<span data-ttu-id="2a54a-257">이전</span><span class="sxs-lookup"><span data-stu-id="2a54a-257">Previous</span></span>](inserting-updating-and-deleting-data-with-the-sqldatasource-vb.md)
