---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-vb
title: 사용 하도록 TableAdapter 업데이트 (VB)를 조인 | Microsoft Docs
author: rick-anderson
description: 데이터베이스를 사용 하 여 작업 하는 경우 여러 테이블에 걸쳐 요청 데이터에 공통적으로 적용 됩니다. 서로 다른 두 테이블에서 데이터를 검색 하거나 사용할 수 있습니다...
ms.author: riande
ms.date: 07/18/2007
ms.assetid: e624a3e0-061b-4efc-8b0e-5877f9ff6714
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-vb
msc.type: authoredcontent
ms.openlocfilehash: d5a7b61d447631f5e65ca8a3dfac9c58c108643f
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/16/2018
ms.locfileid: "41829910"
---
<a name="updating-the-tableadapter-to-use-joins-vb"></a><span data-ttu-id="ea414-104">사용 하도록 TableAdapter 업데이트 (VB)를 조인</span><span class="sxs-lookup"><span data-stu-id="ea414-104">Updating the TableAdapter to Use JOINs (VB)</span></span>
====================
<span data-ttu-id="ea414-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="ea414-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="ea414-106">[코드를 다운로드](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_VB.zip) 또는 [PDF 다운로드](updating-the-tableadapter-to-use-joins-vb/_static/datatutorial69vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="ea414-106">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_VB.zip) or [Download PDF](updating-the-tableadapter-to-use-joins-vb/_static/datatutorial69vb1.pdf)</span></span>

> <span data-ttu-id="ea414-107">데이터베이스를 사용 하 여 작업 하는 경우 여러 테이블에 걸쳐 요청 데이터에 공통적으로 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-107">When working with a database it is common to request data that is spread across multiple tables.</span></span> <span data-ttu-id="ea414-108">서로 다른 두 테이블에서 데이터를 검색할 상관된 하위 쿼리 또는 조인 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-108">To retrieve data from two different tables we can use either a correlated subquery or a JOIN operation.</span></span> <span data-ttu-id="ea414-109">이 자습서에서는 해당 기본 쿼리에서 조인을 포함 하는 TableAdapter를 만드는 방법을 살펴보기 전에 상관된 하위 쿼리 및 조인 구문을 비교 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-109">In this tutorial we compare correlated subqueries and the JOIN syntax before looking at how to create a TableAdapter that includes a JOIN in its main query.</span></span>


## <a name="introduction"></a><span data-ttu-id="ea414-110">소개</span><span class="sxs-lookup"><span data-stu-id="ea414-110">Introduction</span></span>

<span data-ttu-id="ea414-111">관계형 데이터베이스를 사용 하 여 사용에 관심이 데이터는 종종 여러 테이블 간에 분산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-111">With relational databases the data we are interested in working with is often spread across multiple tables.</span></span> <span data-ttu-id="ea414-112">예를 들어 제품 정보를 표시할 때 가능성이 하려는 각 product s 해당 category 및 supplier s 이름 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-112">For example, when displaying product information we likely want to list each product s corresponding category and supplier s names.</span></span> <span data-ttu-id="ea414-113">`Products` 테이블에 `CategoryID` 하 고 `SupplierID` 값 이지만 실제 category와 supplier 이름에는 `Categories` 및 `Suppliers` 테이블 각각.</span><span class="sxs-lookup"><span data-stu-id="ea414-113">The `Products` table has `CategoryID` and `SupplierID` values, but the actual category and supplier names are in the `Categories` and `Suppliers` tables, respectively.</span></span>

<span data-ttu-id="ea414-114">사용할 수 있습니다 다른, 관련 테이블에서 정보를 검색할 *상관 하위 쿼리* 하거나 `JOIN` *s*입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-114">To retrieve information from another, related table, we can either use *correlated subqueries* or `JOIN`*s*.</span></span> <span data-ttu-id="ea414-115">상관된 하위 쿼리 중첩 된 `SELECT` 외부 쿼리의 열을 참조 하는 쿼리.</span><span class="sxs-lookup"><span data-stu-id="ea414-115">A correlated subquery is a nested `SELECT` query that references columns in the outer query.</span></span> <span data-ttu-id="ea414-116">예를 들어,를 [데이터 액세스 레이어 만들기](../introduction/creating-a-data-access-layer-vb.md) 자습서에서 두 개의 상관된 하위 쿼리를 사용 했습니다를 `ProductsTableAdapter` s 주 쿼리의 각 제품에 대 한 category와 supplier 이름을 반환할 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-116">For example, in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-vb.md) tutorial we used two correlated subqueries in the `ProductsTableAdapter` s main query to return the category and supplier names for each product.</span></span> <span data-ttu-id="ea414-117">`JOIN` 는 서로 다른 두 테이블의 관련된 행을 병합 하는 SQL 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-117">A `JOIN` is a SQL construct that merges related rows from two different tables.</span></span> <span data-ttu-id="ea414-118">사용을 `JOIN` 에 [SqlDataSource 컨트롤을 사용 하 여 데이터 쿼리](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-vb.md) 함께 각 제품 범주 정보를 표시 하는 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-118">We used a `JOIN` in the [Querying Data with the SqlDataSource Control](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-vb.md) tutorial to display category information alongside each product.</span></span>

<span data-ttu-id="ea414-119">우리가 사용 하 여 abstained 있는 이유 `JOIN` Tableadapter 사용 하 여가 해당 자동으로 생성할 TableAdapter가의 마법사에서 제한으로 인해 `INSERT`를 `UPDATE`, 및 `DELETE` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-119">The reason we have abstained from using `JOIN` s with the TableAdapters is because of limitations in the TableAdapter s wizard to auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span> <span data-ttu-id="ea414-120">구체적으로 말하면, TableAdapter가 기본 쿼리 하나가 포함 된 경우 `JOIN` 개이면 TableAdapter 수 없습니다. 자동 생성 임시 SQL 문 또는 저장된 프로시저에 대 한 해당 `InsertCommand`를 `UpdateCommand`, 및 `DeleteCommand` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-120">More specifically, if the TableAdapter s main query contains any `JOIN` s, the TableAdapter cannot auto-create the ad-hoc SQL statements or stored procedures for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span>

<span data-ttu-id="ea414-121">이 자습서에서는 간단 하 게 비교 및 대비 상관 하위 쿼리 및 `JOIN` s를 포함 하는 TableAdapter를 만드는 방법을 살펴보기 전에 `JOIN` s의 기본 쿼리에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-121">In this tutorial we will briefly compare and contrast correlated subqueries and `JOIN` s before exploring how to create a TableAdapter that includes `JOIN` s in its main query.</span></span>

## <a name="comparing-and-contrasting-correlated-subqueries-andjoin-s"></a><span data-ttu-id="ea414-122">비교 및 대조 상관 하위 쿼리 및`JOIN` s</span><span class="sxs-lookup"><span data-stu-id="ea414-122">Comparing and Contrasting Correlated Subqueries and`JOIN` s</span></span>

<span data-ttu-id="ea414-123">이전에 설명한 대로 합니다 `ProductsTableAdapter` 의 첫 번째 자습서에서 만든는 `Northwind` 데이터 집합은 각 제품 s 해당 category와 supplier name을 제공 하도록 상관된 하위 쿼리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-123">Recall that the `ProductsTableAdapter` created in the first tutorial in the `Northwind` DataSet uses correlated subqueries to bring back each product s corresponding category and supplier name.</span></span> <span data-ttu-id="ea414-124">`ProductsTableAdapter` s 주 쿼리 아래에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-124">The `ProductsTableAdapter` s main query is shown below.</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample1.sql)]

<span data-ttu-id="ea414-125">두 개의 상관 하위 쿼리- `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` 및 `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` -됩니다 `SELECT` 외부에서 추가 열으로 제품당 하나의 값을 반환 하는 쿼리 `SELECT`의 문 열 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-125">The two correlated subqueries - `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` and `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` - are `SELECT` queries that return a single value per product as an additional column in the outer `SELECT` statement s column list.</span></span>

<span data-ttu-id="ea414-126">또는 `JOIN` 각 s 제품 공급 업체와 범주 이름을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-126">Alternatively, a `JOIN` can be used to return each product s supplier and category name.</span></span> <span data-ttu-id="ea414-127">다음 쿼리는 위와 동일한 출력이 반환 하지만 사용 `JOIN` 하위 쿼리 대신 s:</span><span class="sxs-lookup"><span data-stu-id="ea414-127">The following query returns the same output as the above one, but uses `JOIN` s in place of subqueries:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample2.sql)]

<span data-ttu-id="ea414-128">`JOIN` 일부 조건에 따라 다른 테이블에서 레코드를 사용 하 여 한 테이블에서 레코드를 병합 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-128">A `JOIN` merges the records from one table with records from another table based on some criteria.</span></span> <span data-ttu-id="ea414-129">예를 들어, 위의 쿼리에서 `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` 사용 하면 병합 하는 각 SQL Server 해당 범주를 사용 하 여 제품 레코드 기록 `CategoryID` 값과 s 제품 일치 `CategoryID` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-129">In the above query, for example, the `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` instructs SQL Server to merge each product record with the category record whose `CategoryID` value matches the product s `CategoryID` value.</span></span> <span data-ttu-id="ea414-130">병합 된 결과 사용 하면 각 제품에 대해 해당 범주 필드를 사용 하려면 (같은 `CategoryName`).</span><span class="sxs-lookup"><span data-stu-id="ea414-130">The merged result allows us to work with the corresponding category fields for each product (such as `CategoryName`).</span></span>

> [!NOTE]
> <span data-ttu-id="ea414-131">`JOIN` s는 관계형 데이터베이스에서 데이터를 쿼리 하는 경우에 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-131">`JOIN` s are commonly used when querying data from relational databases.</span></span> <span data-ttu-id="ea414-132">처음 접하는 경우 합니다 `JOIN` 구문, 사용법에 따라 약간 브러시 필요가 d 것이 좋습니다는 [자습서 SQL Join](http://www.w3schools.com/sql/sql_join.asp) 에서 [W3 학교](http://www.w3schools.com/)합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-132">If you are new to the `JOIN` syntax or need to brush up a bit on its usage, I d recommend the [SQL Join tutorial](http://www.w3schools.com/sql/sql_join.asp) at [W3 Schools](http://www.w3schools.com/).</span></span> <span data-ttu-id="ea414-133">또한 읽어 볼 가치가는 [ `JOIN` 기본 사항](https://msdn.microsoft.com/library/ms191517.aspx) 및 [하위 쿼리 기본 사항](https://msdn.microsoft.com/library/ms189575.aspx) 부분을 [SQL 온라인 설명서](https://msdn.microsoft.com/library/ms130214.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-133">Also worth reading are the [`JOIN` Fundamentals](https://msdn.microsoft.com/library/ms191517.aspx) and [Subquery Fundamentals](https://msdn.microsoft.com/library/ms189575.aspx) sections of the [SQL Books Online](https://msdn.microsoft.com/library/ms130214.aspx).</span></span>


<span data-ttu-id="ea414-134">이후 `JOIN` 및 상관 관계가 지정 된 하위 쿼리 둘 다 수 다른 테이블의 관련된 데이터를 검색, 대부분의 개발자는 왼쪽 겨누는 사실일 뿐 및 사용 하는 방법을 궁금해 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-134">Since `JOIN` s and correlated subqueries can both be used to retrieve related data from other tables, many developers are left scratching their heads and wondering which approach to use.</span></span> <span data-ttu-id="ea414-135">모든 SQL 출력량이 있습니까 동일한 작업을 대략 있다고 이야기 ve 한다는 만들어지고 t 실제로 문제가 성능 관점에서 보면 SQL Server는 거의 동일한 실행 계획을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-135">All of the SQL gurus I ve talked to have said roughly the same thing, that it doesn t really matter performance-wise as SQL Server will produce roughly identical execution plans.</span></span> <span data-ttu-id="ea414-136">그런 다음 해당 조언 여러분과 팀 가장 익숙한 기술을 사용 하 여 방법은입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-136">Their advice, then, is to use the technique that you and your team are most comfortable with.</span></span> <span data-ttu-id="ea414-137">부분 것에이 통지를 전달 하는 후 이러한 전문가 즉시 express의 기본 설정 주목할 `JOIN` 상관된 하위 쿼리 동안.</span><span class="sxs-lookup"><span data-stu-id="ea414-137">It merits noting that after imparting this advice these experts immediately express their preference of `JOIN` s over correlated subqueries.</span></span>

<span data-ttu-id="ea414-138">형식화 된 데이터 집합을 사용 하 여 데이터 액세스 계층을 빌드하는 경우 도구는 하위 쿼리를 사용 하는 경우에 더 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-138">When building a Data Access Layer using Typed DataSets, the tools work better when using subqueries.</span></span> <span data-ttu-id="ea414-139">특히 TableAdapter가의 마법사에서 하지 자동 생성에 해당 `INSERT`, `UPDATE`, 및 `DELETE` 주 쿼리 하나가 포함 된 경우 문을 `JOIN` s, 하지만 생성 합니다. 자동-상관 관계가 지정 된 경우 이러한 문은 하위 쿼리 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-139">In particular, the TableAdapter s wizard will not auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements if the main query contains any `JOIN` s, but will auto-generate these statements when correlated subqueries are used.</span></span>

<span data-ttu-id="ea414-140">이러한 단점을 탐색 하려면 임시 형식화 된 데이터 집합을 만드는 `~/App_Code/DAL` 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-140">To explore this shortcoming, create a temporary Typed DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="ea414-141">TableAdapter 구성 마법사를 하는 동안 임시 SQL 문을 사용 하 여 다음을 입력 하 선택 `SELECT` 쿼리 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="ea414-141">During the TableAdapter Configuration wizard, choose to use ad-hoc SQL statements and enter the following `SELECT` query (see Figure 1):</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample3.sql)]


<span data-ttu-id="ea414-142">[![조인을 포함 하는 기본 쿼리를 입력 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image2.png)](updating-the-tableadapter-to-use-joins-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-142">[![Enter a Main Query that Contains JOINs](updating-the-tableadapter-to-use-joins-vb/_static/image2.png)](updating-the-tableadapter-to-use-joins-vb/_static/image1.png)</span></span>

<span data-ttu-id="ea414-143">**그림 1**: 포함 된 기본 쿼리를 입력 `JOIN` s ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-143">**Figure 1**: Enter a Main Query that Contains `JOIN` s ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image3.png))</span></span>


<span data-ttu-id="ea414-144">TableAdapter 기본적으로 자동으로 만들어집니다 `INSERT`, `UPDATE`, 및 `DELETE` 주 쿼리를 기반으로 한 문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-144">By default, the TableAdapter will automatically create `INSERT`, `UPDATE`, and `DELETE` statements based on the main query.</span></span> <span data-ttu-id="ea414-145">고급 단추를 클릭 하면이 기능을 사용할 수 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-145">If you click the Advanced button you can see that this feature is enabled.</span></span> <span data-ttu-id="ea414-146">이 설정에도 불구 하 고 TableAdapter 됩니다 만들 수는 `INSERT`, `UPDATE`, 및 `DELETE` 문 기본 쿼리에 포함 되어 있으므로 `JOIN`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-146">Despite this setting, the TableAdapter will not be able to create the `INSERT`, `UPDATE`, and `DELETE` statements because the main query contains a `JOIN`.</span></span>


![조인을 포함 하는 기본 쿼리를 입력 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image4.png)

<span data-ttu-id="ea414-148">**그림 2**: 포함 하는 기본 쿼리를 입력 `JOIN` s</span><span class="sxs-lookup"><span data-stu-id="ea414-148">**Figure 2**: Enter a Main Query that Contains `JOIN` s</span></span>


<span data-ttu-id="ea414-149">마법사를 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-149">Click Finish to complete the wizard.</span></span> <span data-ttu-id="ea414-150">이 시점에 데이터 집합의 디자이너 포함 될 열이 포함 된 DataTable 사용 하 여 단일 TableAdapter에 반환 하는 필드의 각는 `SELECT`의 쿼리 열 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-150">At this point your DataSet s Designer will include a single TableAdapter with a DataTable with columns for each of the fields returned in the `SELECT` query s column list.</span></span> <span data-ttu-id="ea414-151">여기에 `CategoryName` 고 `SupplierName`그림 3과 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-151">This includes the `CategoryName` and `SupplierName`, as Figure 3 shows.</span></span>


![DataTable 열 목록에 반환 된 각 필드에 대 한 열이 포함](updating-the-tableadapter-to-use-joins-vb/_static/image5.png)

<span data-ttu-id="ea414-153">**그림 3**: DataTable 열 목록에 반환 된 각 필드에 대 한 열이 포함</span><span class="sxs-lookup"><span data-stu-id="ea414-153">**Figure 3**: The DataTable Includes a Column for Each Field Returned in the Column List</span></span>


<span data-ttu-id="ea414-154">TableAdapter에 대 한 값이 부족 DataTable에는 적절 한 열에 있으면 해당 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-154">While the DataTable has the appropriate columns, the TableAdapter lacks values for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span> <span data-ttu-id="ea414-155">이 확인 하려면 디자이너의 TableAdapter에 클릭 한 다음 속성 창으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-155">To confirm this, click on the TableAdapter in the Designer and then go to the Properties window.</span></span> <span data-ttu-id="ea414-156">이 표시 됩니다는 합니다 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 속성 (없음)으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-156">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are set to (None) .</span></span>


<span data-ttu-id="ea414-157">[![InsertCommand, UpdateCommand, 및 DeleteCommand 속성 (없음)으로 설정 됩니다.](updating-the-tableadapter-to-use-joins-vb/_static/image7.png)](updating-the-tableadapter-to-use-joins-vb/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-157">[![The InsertCommand, UpdateCommand, and DeleteCommand Properties are Set to (None)](updating-the-tableadapter-to-use-joins-vb/_static/image7.png)](updating-the-tableadapter-to-use-joins-vb/_static/image6.png)</span></span>

<span data-ttu-id="ea414-158">**그림 4**: 합니다 `InsertCommand`를 `UpdateCommand`, 및 `DeleteCommand` 속성 (없음)으로 설정 됩니다 ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-158">**Figure 4**: The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` Properties are Set to (None) ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image8.png))</span></span>


<span data-ttu-id="ea414-159">이러한 단점을 해결 하려면 수동으로 가능해 집니다 SQL 문 및 매개 변수를 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 속성 창을 통해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-159">To work around this shortcoming, we can manually provide the SQL statements and parameters for the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties via the Properties window.</span></span> <span data-ttu-id="ea414-160">또는 TableAdapter가 기본 쿼리를 구성 하 여 시작할 수 있을 것 *되지* 포함할 `JOIN` s입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-160">Alternatively, we could start by configuring the TableAdapter s main query to *not* include any `JOIN` s.</span></span> <span data-ttu-id="ea414-161">이렇게 하면 합니다 `INSERT`, `UPDATE`, 및 `DELETE` 문을 자동으로 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-161">This will allow the `INSERT`, `UPDATE`, and `DELETE` statements to be auto-generated for us.</span></span> <span data-ttu-id="ea414-162">마법사를 완료 한 후에서는 다음 수동으로 업데이트할 수는 tableadapter `SelectCommand` 을 포함 하도록 속성 창에서를 `JOIN` 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-162">After completing the wizard, we could then manually update the TableAdapter s `SelectCommand` from the Properties window so that it includes the `JOIN` syntax.</span></span>

<span data-ttu-id="ea414-163">이 방법은 것이 매우 불안정 언제 든 지 TableAdapter가 기본 쿼리 때문에 임시 SQL 쿼리를 사용 하 여 자동으로 생성 하 여 마법사를 통해 다시 구성할 때 `INSERT`, `UPDATE`, 및 `DELETE` 문을 다시 작성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-163">While this approach works, it is very brittle when using ad-hoc SQL queries because any time the TableAdapter s main query is re-configured through the wizard, the auto-generated `INSERT`, `UPDATE`, and `DELETE` statements are recreated.</span></span> <span data-ttu-id="ea414-164">즉, 나중에 수행한 사용자 지정을 모두 손실 될 TableAdapter를 마우스 오른쪽 단추로 클릭, 상황에 맞는 메뉴에서 구성 선택 하 고 마법사를 다시 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-164">That means all of the customizations we later made would be lost if we right-clicked on the TableAdapter, chose Configure from the context menu, and completed the wizard again.</span></span>

<span data-ttu-id="ea414-165">자동으로 생성 된 tableadapter의 때 `INSERT`, `UPDATE`, 및 `DELETE` 문을 인 다행 스럽게도 임시 SQL 문이 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-165">The brittleness of the TableAdapter s auto-generated `INSERT`, `UPDATE`, and `DELETE` statements is, fortunately, limited to ad-hoc SQL statements.</span></span> <span data-ttu-id="ea414-166">저장된 프로시저를 사용 하 여 TableAdapter 경우 사용자 지정할 수 있습니다 합니다 `SelectCommand`, `InsertCommand`를 `UpdateCommand`, 또는 `DeleteCommand` 저장 프로시저 및 저장된 프로시저 되도록 걱정 하지 않고 TableAdapter 구성 마법사를 다시 실행 합니다. 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-166">If your TableAdapter uses stored procedures, you can customize the `SelectCommand`, `InsertCommand`, `UpdateCommand`, or `DeleteCommand` stored procedures and re-run the TableAdapter Configuration wizard without having to fear that the stored procedures will be modified.</span></span>

<span data-ttu-id="ea414-167">다음 통해 만들겠습니다 TableAdapter는 처음에 몇 가지 단계는 모든 생략 하는 기본 쿼리를 사용해 `JOIN` s 해당 삽입 되도록 업데이트 및 삭제 저장 프로시저를 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-167">Over the next several steps we will create a TableAdapter that, initially, uses a main query that omits any `JOIN` s so that the corresponding insert, update, and delete stored procedures will be auto-generated.</span></span> <span data-ttu-id="ea414-168">업데이트 될 것을 `SelectCommand` 따라서를 사용 하는 `JOIN` 관련된 테이블에서 추가 열을 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-168">We will then update the `SelectCommand` so that uses a `JOIN` that returns additional columns from related tables.</span></span> <span data-ttu-id="ea414-169">마지막으로, 해당 비즈니스 논리 계층 클래스 만들어 ASP.NET 웹 페이지에서 TableAdapter를 사용 하 여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-169">Finally, we'll create a corresponding Business Logic Layer class and demonstrate using the TableAdapter in an ASP.NET web page.</span></span>

## <a name="step-1-creating-the-tableadapter-using-a-simplified-main-query"></a><span data-ttu-id="ea414-170">1 단계: 간소화 된 기본 쿼리를 사용 하 여 TableAdapter 만들기</span><span class="sxs-lookup"><span data-stu-id="ea414-170">Step 1: Creating the TableAdapter Using a Simplified Main Query</span></span>

<span data-ttu-id="ea414-171">이 자습서에 대 한 추가 대 한 강력한 형식의 DataTable을 TableAdapter 합니다 `Employees` 테이블에 `NorthwindWithSprocs` 데이터 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-171">For this tutorial we will add a TableAdapter and strongly-typed DataTable for the `Employees` table in the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="ea414-172">`Employees` 표에서 `ReportsTo` 지정 된 필드는 `EmployeeID` 직원 s 관리자.</span><span class="sxs-lookup"><span data-stu-id="ea414-172">The `Employees` table contains a `ReportsTo` field that specified the `EmployeeID` of the employee s manager.</span></span> <span data-ttu-id="ea414-173">황 병 우에 직원 예를 들어를 `ReportTo` 인 값 5는 `EmployeeID` 정훈의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-173">For example, employee Anne Dodsworth has a `ReportTo` value of 5, which is the `EmployeeID` of Steven Buchanan.</span></span> <span data-ttu-id="ea414-174">따라서 Anne Steven, 관리자에 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-174">Consequently, Anne reports to Steven, her manager.</span></span> <span data-ttu-id="ea414-175">각 직원 s 보고와 함께 `ReportsTo` 값 하고자 할 수 있습니다도 해당 관리자의 이름을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-175">Along with reporting each employee s `ReportsTo` value, we might also want to retrieve the name of their manager.</span></span> <span data-ttu-id="ea414-176">사용 하 여 수행할 수 있습니다는 `JOIN`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-176">This can be accomplished using a `JOIN`.</span></span> <span data-ttu-id="ea414-177">하지만 사용 하 여는 `JOIN` 때 마법사에서 자동으로 해당 하는 삽입을 생성 하므로 처음에 TableAdapter 만들기, 업데이트 및 삭제 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-177">But using a `JOIN` when initially creating the TableAdapter precludes the wizard from automatically generating the corresponding insert, update, and delete capabilities.</span></span> <span data-ttu-id="ea414-178">따라서 먼저 해당 주 쿼리에 포함 하지 않으면 TableAdapter 만들기 `JOIN` s입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-178">Therefore, we will start by creating a TableAdapter whose main query does not contain any `JOIN` s.</span></span> <span data-ttu-id="ea414-179">그런 다음 2 단계에서에서 업데이트할 것을 통해 관리자가의 이름을 검색 하는 기본 쿼리 저장 절차를 `JOIN`입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-179">Then, in Step 2, we will update the main query stored procedure to retrieve the manager s name via a `JOIN`.</span></span>

<span data-ttu-id="ea414-180">열어서 시작 합니다 `NorthwindWithSprocs` 데이터 집합에는 `~/App_Code/DAL` 폴더.</span><span class="sxs-lookup"><span data-stu-id="ea414-180">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="ea414-181">디자이너에서 마우스 상황에 맞는 메뉴에서 추가 옵션을 선택 합니다. TableAdapter 메뉴 항목을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-181">Right-click on the Designer, select the Add option from the context menu, and pick the TableAdapter menu item.</span></span> <span data-ttu-id="ea414-182">TableAdapter 구성 마법사를 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-182">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="ea414-183">그림 5 보여주고 처럼 새 저장된 프로시저를 만들고 다음을 클릭 하 여 마법사를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-183">As Figure 5 depicts, have the wizard create new stored procedures and click Next.</span></span> <span data-ttu-id="ea414-184">새로 만들기에 리프레셔가 저장 프로시저 TableAdapter가의 마법사에서에 대 한 참조를 [새 저장 프로시저 만들기 형식화 된 데이터 집합의 Tableadapter에 대 한](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-184">For a refresher on creating new stored procedures from the TableAdapter s wizard, consult the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span>


<span data-ttu-id="ea414-185">[![새 저장된 프로시저 만들기 옵션을 선택 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image10.png)](updating-the-tableadapter-to-use-joins-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-185">[![Select the Create new stored procedures Option](updating-the-tableadapter-to-use-joins-vb/_static/image10.png)](updating-the-tableadapter-to-use-joins-vb/_static/image9.png)</span></span>

<span data-ttu-id="ea414-186">**그림 5**: 새 저장 프로시저 옵션 선택 만들기 ([큰 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-186">**Figure 5**: Select the Create new stored procedures Option ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image11.png))</span></span>


<span data-ttu-id="ea414-187">다음 사용 하 여 `SELECT` TableAdapter s 주 쿼리에 대 한 문:</span><span class="sxs-lookup"><span data-stu-id="ea414-187">Use the following `SELECT` statement for the TableAdapter s main query:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample4.sql)]

<span data-ttu-id="ea414-188">이후이 쿼리에 포함 하지 않습니다 `JOIN` 개이면 TableAdapter 마법사가 자동으로 만듭니다. 저장된 프로시저 해당 `INSERT`, `UPDATE`, 및 `DELETE` 문 뿐만 아니라 주를 실행 하기 위한 저장된 프로시저 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-188">Since this query does not include any `JOIN` s, the TableAdapter wizard will automatically create stored procedures with corresponding `INSERT`, `UPDATE`, and `DELETE` statements, as well as a stored procedure for executing the main query.</span></span>

<span data-ttu-id="ea414-189">다음 단계를 사용 하면 TableAdapter 저장 된 프로시저 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-189">The following step allows us to name the TableAdapter s stored procedures.</span></span> <span data-ttu-id="ea414-190">이름을 사용 하 여 `Employees_Select`, `Employees_Insert`를 `Employees_Update`, 및 `Employees_Delete`그림 6 에서처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-190">Use the names `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`, as shown in Figure 6.</span></span>


<span data-ttu-id="ea414-191">[![TableAdapter 저장 된 프로시저 이름](updating-the-tableadapter-to-use-joins-vb/_static/image13.png)](updating-the-tableadapter-to-use-joins-vb/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-191">[![Name the TableAdapter s Stored Procedures](updating-the-tableadapter-to-use-joins-vb/_static/image13.png)](updating-the-tableadapter-to-use-joins-vb/_static/image12.png)</span></span>

<span data-ttu-id="ea414-192">**그림 6**: TableAdapter가 저장 프로시저 이름 ([큰 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-192">**Figure 6**: Name the TableAdapter s Stored Procedures ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image14.png))</span></span>


<span data-ttu-id="ea414-193">마지막 단계 TableAdapter의 메서드 이름을 지정 하 라는 메시지가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-193">The final step prompts us to name the TableAdapter s methods.</span></span> <span data-ttu-id="ea414-194">사용 하 여 `Fill` 고 `GetEmployees` 메서드 이름으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-194">Use `Fill` and `GetEmployees` as the method names.</span></span> <span data-ttu-id="ea414-195">또한 업데이트 데이터베이스 (GenerateDBDirectMethods) 확인란이 선택 되어 직접 보내는 메서드 만들기를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-195">Also be sure to leave the Create methods to send updates directly to the database (GenerateDBDirectMethods) checkbox checked.</span></span>


<span data-ttu-id="ea414-196">[![TableAdapter가의 메서드 채우기 이름과 GetEmployees](updating-the-tableadapter-to-use-joins-vb/_static/image16.png)](updating-the-tableadapter-to-use-joins-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-196">[![Name the TableAdapter s Methods Fill and GetEmployees](updating-the-tableadapter-to-use-joins-vb/_static/image16.png)](updating-the-tableadapter-to-use-joins-vb/_static/image15.png)</span></span>

<span data-ttu-id="ea414-197">**그림 7**: tableadapter 메서드 이름을 `Fill` 하 고 `GetEmployees` ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-197">**Figure 7**: Name the TableAdapter s Methods `Fill` and `GetEmployees` ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image17.png))</span></span>


<span data-ttu-id="ea414-198">마법사를 완료 한 후 시간을 내어 데이터베이스에서 저장된 프로시저를 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-198">After completing the wizard, take a moment to examine the stored procedures in the database.</span></span> <span data-ttu-id="ea414-199">4 개의 새로 표시 됩니다: `Employees_Select`, `Employees_Insert`를 `Employees_Update`, 및 `Employees_Delete`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-199">You should see four new ones: `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`.</span></span> <span data-ttu-id="ea414-200">다음으로 검사 합니다 `EmployeesDataTable` 및 `EmployeesTableAdapter` 방금 만든 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-200">Next, inspect the `EmployeesDataTable` and `EmployeesTableAdapter` just created.</span></span> <span data-ttu-id="ea414-201">DataTable 주 쿼리에서 반환 된 각 필드에 대 한 열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-201">The DataTable contains a column for each field returned by the main query.</span></span> <span data-ttu-id="ea414-202">TableAdapter 클릭 하 고 속성 창으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-202">Click on the TableAdapter and then go to the Properties window.</span></span> <span data-ttu-id="ea414-203">이 표시 됩니다는 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 속성 모두가 해당 저장된 프로시저를 호출 하도록 올바르게 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-203">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are correctly configured to call the corresponding stored procedures.</span></span>


<span data-ttu-id="ea414-204">[![TableAdapter 포함 삽입, 업데이트 및 삭제 기능](updating-the-tableadapter-to-use-joins-vb/_static/image19.png)](updating-the-tableadapter-to-use-joins-vb/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-204">[![The TableAdapter Includes Insert, Update, and Delete Capabilities](updating-the-tableadapter-to-use-joins-vb/_static/image19.png)](updating-the-tableadapter-to-use-joins-vb/_static/image18.png)</span></span>

<span data-ttu-id="ea414-205">**그림 8**: TableAdapter 포함 Insert, Update 및 삭제 기능 ([큰 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image20.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-205">**Figure 8**: The TableAdapter Includes Insert, Update, and Delete Capabilities ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image20.png))</span></span>


<span data-ttu-id="ea414-206">삽입, 업데이트 및 delete 저장된 프로시저를 자동으로 생성 하며 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 을 사용자 지정할 수는 올바르게 구성 하는 속성을는 `SelectCommand` s 저장 프로시저를 추가로 반환할 각 직원의 관리자에 대 한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-206">With the insert, update, and delete stored procedures automatically created and the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties correctly configured, we are ready to customize the `SelectCommand` s stored procedure to return additional information about each employee s manager.</span></span> <span data-ttu-id="ea414-207">구체적으로 업데이트 해야 합니다 `Employees_Select` 저장 프로시저를 사용 하 여는 `JOIN` 관리자가 반환 하 고 `FirstName` 및 `LastName` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-207">Specifically, we need to update the `Employees_Select` stored procedure to use a `JOIN` and return the manager s `FirstName` and `LastName` values.</span></span> <span data-ttu-id="ea414-208">저장된 프로시저를 업데이트 후 이러한 추가 열이 포함 되어 있도록 DataTable을 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-208">After the stored procedure has been updated, we will need to update the DataTable so that it includes these additional columns.</span></span> <span data-ttu-id="ea414-209">에서는 이러한 두 작업 단계 2에서 및 3 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-209">We'll tackle these two tasks in Steps 2 and 3.</span></span>

## <a name="step-2-customizing-the-stored-procedure-to-include-ajoin"></a><span data-ttu-id="ea414-210">2 단계: 포함 하도록 저장된 프로시저를 사용자 지정을`JOIN`</span><span class="sxs-lookup"><span data-stu-id="ea414-210">Step 2: Customizing the Stored Procedure to Include a`JOIN`</span></span>

<span data-ttu-id="ea414-211">서버 탐색기로 이동 하 고, Northwind 데이터베이스 s Stored Procedures 폴더로 드릴 다운, 열어 하 여 시작 된 `Employees_Select` 저장 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-211">Start by going to the Server Explorer, drilling down into the Northwind database s Stored Procedures folder, and opening the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="ea414-212">이 저장된 프로시저 표시 되지 않으면, Stored Procedures 폴더를 마우스 오른쪽 단추로 클릭 하 고 새로 고침을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-212">If you do not see this stored procedure, right-click on the Stored Procedures folder and choose Refresh.</span></span> <span data-ttu-id="ea414-213">사용 하도록 저장된 프로시저를 업데이트 한 `LEFT JOIN`의 관리자를 먼저 반환 하 여 성:</span><span class="sxs-lookup"><span data-stu-id="ea414-213">Update the stored procedure so that it uses a `LEFT JOIN` to return the manager s first and last name:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample5.sql)]

<span data-ttu-id="ea414-214">업데이트 한 후 합니다 `SELECT` 문을 파일 메뉴로 이동 하 고 저장을 선택 하 여 변경 내용 저장할 `Employees_Select`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-214">After updating the `SELECT` statement, save the changes by going to the File menu and choosing Save `Employees_Select`.</span></span> <span data-ttu-id="ea414-215">또는 도구 모음에서 저장 아이콘을 클릭 하거나 Ctrl + S를 누르면 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-215">Alternatively, you can click the Save icon in the toolbar or hit Ctrl+S.</span></span> <span data-ttu-id="ea414-216">변경 내용을 저장 한 후 마우스 오른쪽 단추로 클릭는 `Employees_Select` 서버 탐색기에서 저장 프로시저 및 Execute를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-216">After saving your changes, right-click on the `Employees_Select` stored procedure in the Server Explorer and choose Execute.</span></span> <span data-ttu-id="ea414-217">이 저장된 프로시저를 실행 및 해당 결과 출력 창에 표시 됩니다 (그림 9 참조).</span><span class="sxs-lookup"><span data-stu-id="ea414-217">This will run the stored procedure and show its results in the Output window (see Figure 9).</span></span>


<span data-ttu-id="ea414-218">[![저장 프로시저 결과 출력 창에 표시 됩니다.](updating-the-tableadapter-to-use-joins-vb/_static/image22.png)](updating-the-tableadapter-to-use-joins-vb/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-218">[![The Stored Procedures Results are Displayed in the Output Window](updating-the-tableadapter-to-use-joins-vb/_static/image22.png)](updating-the-tableadapter-to-use-joins-vb/_static/image21.png)</span></span>

<span data-ttu-id="ea414-219">**그림 9**: 저장 프로시저 결과 출력 창에 표시 됩니다 ([큰 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image23.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-219">**Figure 9**: The Stored Procedures Results are Displayed in the Output Window ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image23.png))</span></span>


## <a name="step-3-updating-the-datatable-s-columns"></a><span data-ttu-id="ea414-220">3 단계: DataTable의 열 업데이트</span><span class="sxs-lookup"><span data-stu-id="ea414-220">Step 3: Updating the DataTable s Columns</span></span>

<span data-ttu-id="ea414-221">이 시점에서 합니다 `Employees_Select` 저장 프로시저 반환 `ManagerFirstName` 및 `ManagerLastName` 값 이지만 `EmployeesDataTable` 이러한 열이 누락 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-221">At this point, the `Employees_Select` stored procedure returns `ManagerFirstName` and `ManagerLastName` values, but the `EmployeesDataTable` is missing these columns.</span></span> <span data-ttu-id="ea414-222">이러한 누락 된 열을 두 가지 방법 중 하나에서 DataTable에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-222">These missing columns can be added to the DataTable in one of two ways:</span></span>

- <span data-ttu-id="ea414-223">**수동으로** -데이터 집합 디자이너에서 DataTable을 마우스 오른쪽 단추로 클릭 하 고, 추가 메뉴에서 열을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-223">**Manually** - right-click on the DataTable in the DataSet Designer and, from the Add menu, choose Column.</span></span> <span data-ttu-id="ea414-224">다음 열 이름을 지정 하 고 해당 속성을 적절 하 게 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-224">You can then name the column and set its properties accordingly.</span></span>
- <span data-ttu-id="ea414-225">**자동으로** -TableAdapter 구성 마법사가가 반환한 필드에 맞게 DataTable의 열 업데이트는 `SelectCommand` 저장 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-225">**Automatically** - the TableAdapter Configuration wizard will update the DataTable s columns to reflect the fields returned by the `SelectCommand` stored procedure.</span></span> <span data-ttu-id="ea414-226">임시 SQL 문을 사용 하는 경우 마법사가 제거도 `InsertCommand`, `UpdateCommand`, 및 `DeleteCommand` 속성을 `SelectCommand` 이제 포함을 `JOIN`.</span><span class="sxs-lookup"><span data-stu-id="ea414-226">When using ad-hoc SQL statements, the wizard will also remove the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties since the `SelectCommand` now contains a `JOIN`.</span></span> <span data-ttu-id="ea414-227">하지만 저장된 프로시저를 사용 하는 경우 이러한 명령은 속성 그대로입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-227">But when using stored procedures, these command properties remain intact.</span></span>

<span data-ttu-id="ea414-228">이전 자습서에서는 포함 하 여 수동으로 추가 DataTable 열을 살펴보았습니다 있을 [마스터/세부 정보 DataList와 함께 a 글머리 기호 목록의 마스터 레코드를 사용 하 여 세부 정보](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-vb.md) 하 고 [에 파일 업로드](../working-with-binary-files/uploading-files-vb.md), 드리겠습니다 다음 자습서에서이 프로세스를 다시 자세히 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-228">We have explored manually adding DataTable columns in previous tutorials, including [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-vb.md) and [Uploading Files](../working-with-binary-files/uploading-files-vb.md), and we will look at this process again in more detail in our next tutorial.</span></span> <span data-ttu-id="ea414-229">그러나이 자습서에서는 s TableAdapter 구성 마법사를 통해 자동 방법을 사용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-229">For this tutorial, however, let s use the automatic approach via the TableAdapter Configuration wizard.</span></span>

<span data-ttu-id="ea414-230">마우스 오른쪽 단추로 클릭 하 여 시작 된 `EmployeesTableAdapter` 구성 상황에 맞는 메뉴에서 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-230">Start by right-clicking on the `EmployeesTableAdapter` and selecting Configure from the context menu.</span></span> <span data-ttu-id="ea414-231">그러면 선택, 삽입, 업데이트 및 삭제와 반환 값 및 매개 변수 (있는 경우)에 사용 되는 저장된 프로시저를 나열 하는 TableAdapter 구성 마법사.</span><span class="sxs-lookup"><span data-stu-id="ea414-231">This brings up the TableAdapter Configuration wizard, which lists the stored procedures used for selecting, inserting, updating, and deleting, along with their return values and parameters (if any).</span></span> <span data-ttu-id="ea414-232">그림 10에서는이 마법사를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-232">Figure 10 shows this wizard.</span></span> <span data-ttu-id="ea414-233">여기서 볼 수 있는 하는 합니다 `Employees_Select` 저장 프로시저 반환 합니다 `ManagerFirstName` 및 `ManagerLastName` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-233">Here we can see that the `Employees_Select` stored procedure now returns the `ManagerFirstName` and `ManagerLastName` fields.</span></span>


<span data-ttu-id="ea414-234">[![저장 프로시저는 마법사와 Employees_Select에 대 한 업데이트 된 열 목록](updating-the-tableadapter-to-use-joins-vb/_static/image25.png)](updating-the-tableadapter-to-use-joins-vb/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-234">[![The Wizard Shows the Updated Column List for the Employees_Select Stored Procedure](updating-the-tableadapter-to-use-joins-vb/_static/image25.png)](updating-the-tableadapter-to-use-joins-vb/_static/image24.png)</span></span>

<span data-ttu-id="ea414-235">**그림 10**: 마법사에 대 한 업데이트 된 열 목록을 표시 합니다 `Employees_Select` 저장 프로시저 ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image26.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-235">**Figure 10**: The Wizard Shows the Updated Column List for the `Employees_Select` Stored Procedure ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image26.png))</span></span>


<span data-ttu-id="ea414-236">마침을 클릭 하 여 마법사를 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-236">Complete the wizard by clicking Finish.</span></span> <span data-ttu-id="ea414-237">데이터 집합 디자이너로 돌아가면 합니다 `EmployeesDataTable` 두 개의 추가 열이 포함 됩니다: `ManagerFirstName` 및 `ManagerLastName`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-237">Upon returning to the DataSet Designer, the `EmployeesDataTable` includes two additional columns: `ManagerFirstName` and `ManagerLastName`.</span></span>


<span data-ttu-id="ea414-238">[![EmployeesDataTable 새 열 두 개를 포함합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image28.png)](updating-the-tableadapter-to-use-joins-vb/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-238">[![The EmployeesDataTable Contains Two New Columns](updating-the-tableadapter-to-use-joins-vb/_static/image28.png)](updating-the-tableadapter-to-use-joins-vb/_static/image27.png)</span></span>

<span data-ttu-id="ea414-239">**그림 11**: 합니다 `EmployeesDataTable` 새 열 두 개 포함 되어 있습니다 ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image29.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-239">**Figure 11**: The `EmployeesDataTable` Contains Two New Columns ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image29.png))</span></span>


<span data-ttu-id="ea414-240">설명 하기 위해 업데이트 된 `Employees_Select` s 보고 직원을 삭제 하는 사용자를 허용 하는 웹 페이지 만들기, 저장된 프로시저를 적용 하 고 삽입, 업데이트 하 고이 TableAdapter의 기능을 삭제 하는 문서가 계속 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-240">To illustrate that the updated `Employees_Select` stored procedure is in effect and that the insert, update, and delete capabilities of the TableAdapter are still functional, let s create a web page that allows users to view and delete employees.</span></span> <span data-ttu-id="ea414-241">그러나 이러한 페이지를 만들기 전에 먼저 생성 해야 새 클래스 작업에서 직원을 위한 비즈니스 논리 계층에는 `NorthwindWithSprocs` 데이터 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-241">Before we create such a page, however, we need to first create a new class in the Business Logic Layer for working with employees from the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="ea414-242">4 단계에서에서 만듭니다는 `EmployeesBLLWithSprocs` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-242">In Step 4, we will create an `EmployeesBLLWithSprocs` class.</span></span> <span data-ttu-id="ea414-243">5 단계에서에서이 클래스는 ASP.NET 페이지에서 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-243">In Step 5, we will use this class from an ASP.NET page.</span></span>

## <a name="step-4-implementing-the-business-logic-layer"></a><span data-ttu-id="ea414-244">4 단계: 비즈니스 논리 레이어 구현</span><span class="sxs-lookup"><span data-stu-id="ea414-244">Step 4: Implementing the Business Logic Layer</span></span>

<span data-ttu-id="ea414-245">새 클래스 파일을 만듭니다는 `~/App_Code/BLL` 라는 폴더 `EmployeesBLLWithSprocs.vb`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-245">Create a new class file in the `~/App_Code/BLL` folder named `EmployeesBLLWithSprocs.vb`.</span></span> <span data-ttu-id="ea414-246">이 클래스는 기존의 의미 체계를 모방 `EmployeesBLL` 클래스에만 새로운 하나 적은 메서드를 제공 하 고 사용 합니다 `NorthwindWithSprocs` 데이터 집합 (대신는 `Northwind` 데이터 집합).</span><span class="sxs-lookup"><span data-stu-id="ea414-246">This class mimics the semantics of the existing `EmployeesBLL` class, only this new one provides fewer methods and uses the `NorthwindWithSprocs` DataSet (instead of the `Northwind` DataSet).</span></span> <span data-ttu-id="ea414-247">`EmployeesBLLWithSprocs` 클래스에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-247">Add the following code to the `EmployeesBLLWithSprocs` class.</span></span>


[!code-vb[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample6.vb)]

<span data-ttu-id="ea414-248">`EmployeesBLLWithSprocs` s 클래스 `Adapter` 속성의 인스턴스를 반환 합니다 `NorthwindWithSprocs` dataset `EmployeesTableAdapter`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-248">The `EmployeesBLLWithSprocs` class s `Adapter` property returns an instance of the `NorthwindWithSprocs` DataSet s `EmployeesTableAdapter`.</span></span> <span data-ttu-id="ea414-249">S 클래스에 의해 사용 됩니다 `GetEmployees` 고 `DeleteEmployee` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ea414-249">This is used by the class s `GetEmployees` and `DeleteEmployee` methods.</span></span> <span data-ttu-id="ea414-250">`GetEmployees` 메서드 호출을 `EmployeesTableAdapter` s 해당 `GetEmployees` 메서드를 호출 하는 `Employees_Select` 저장 프로시저 및 그 결과 채웁니다는 `EmployeeDataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-250">The `GetEmployees` method calls the `EmployeesTableAdapter` s corresponding `GetEmployees` method, which invokes the `Employees_Select` stored procedure and populates its results in an `EmployeeDataTable`.</span></span> <span data-ttu-id="ea414-251">합니다 `DeleteEmployee` 마찬가지로 메서드를 호출 합니다 `EmployeesTableAdapter` s `Delete` 메서드를 호출 하는 `Employees_Delete` 저장 프로시저.</span><span class="sxs-lookup"><span data-stu-id="ea414-251">The `DeleteEmployee` method similarly calls the `EmployeesTableAdapter` s `Delete` method, which invokes the `Employees_Delete` stored procedure.</span></span>

## <a name="step-5-working-with-the-data-in-the-presentation-layer"></a><span data-ttu-id="ea414-252">5 단계: 프레젠테이션 계층에서 데이터 작업</span><span class="sxs-lookup"><span data-stu-id="ea414-252">Step 5: Working with the Data in the Presentation Layer</span></span>

<span data-ttu-id="ea414-253">사용 하 여는 `EmployeesBLLWithSprocs` 클래스에서는 ASP.NET 페이지를 통해 직원 데이터를 사용할 준비가 완료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-253">With the `EmployeesBLLWithSprocs` class complete, we re ready to work with employee data through an ASP.NET page.</span></span> <span data-ttu-id="ea414-254">열기는 `JOINs.aspx` 페이지에 `AdvancedDAL` 폴더 및 설정 디자이너 도구 상자에서 GridView 끌어서 해당 `ID` 속성을 `Employees`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-254">Open the `JOINs.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Employees`.</span></span> <span data-ttu-id="ea414-255">그런 다음 GridView가 스마트 태그를 모눈을 라는 새 ObjectDataSource 컨트롤을 바인딩할 `EmployeesDataSource`합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-255">Next, from the GridView s smart tag, bind the grid to a new ObjectDataSource control named `EmployeesDataSource`.</span></span>

<span data-ttu-id="ea414-256">ObjectDataSource를 사용 하 여 구성를 `EmployeesBLLWithSprocs` 클래스를 선택 하 고 삭제 탭에서 있는지를 확인 합니다 `GetEmployees` 및 `DeleteEmployee` 방법이 드롭 다운 목록에서 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-256">Configure the ObjectDataSource to use the `EmployeesBLLWithSprocs` class and, from the SELECT and DELETE tabs, ensure that the `GetEmployees` and `DeleteEmployee` methods are selected from the drop-down lists.</span></span> <span data-ttu-id="ea414-257">ObjectDataSource가의 구성을 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-257">Click Finish to complete the ObjectDataSource s configuration.</span></span>


<span data-ttu-id="ea414-258">[![EmployeesBLLWithSprocs 클래스를 사용 하는 ObjectDataSource 구성](updating-the-tableadapter-to-use-joins-vb/_static/image31.png)](updating-the-tableadapter-to-use-joins-vb/_static/image30.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-258">[![Configure the ObjectDataSource to Use the EmployeesBLLWithSprocs Class](updating-the-tableadapter-to-use-joins-vb/_static/image31.png)](updating-the-tableadapter-to-use-joins-vb/_static/image30.png)</span></span>

<span data-ttu-id="ea414-259">**그림 12**: ObjectDataSource 사용 하도록 구성 된 `EmployeesBLLWithSprocs` 클래스 ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image32.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-259">**Figure 12**: Configure the ObjectDataSource to Use the `EmployeesBLLWithSprocs` Class ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image32.png))</span></span>


<span data-ttu-id="ea414-260">[![ObjectDataSource를 사용 하는 한 GetEmployees 및 종료 되 메서드](updating-the-tableadapter-to-use-joins-vb/_static/image34.png)](updating-the-tableadapter-to-use-joins-vb/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-260">[![Have the ObjectDataSource Use the GetEmployees and DeleteEmployee Methods](updating-the-tableadapter-to-use-joins-vb/_static/image34.png)](updating-the-tableadapter-to-use-joins-vb/_static/image33.png)</span></span>

<span data-ttu-id="ea414-261">**그림 13**: ObjectDataSource 사용 합니다 `GetEmployees` 하 고 `DeleteEmployee` 메서드 ([클릭 하 여 큰 이미지 보기](updating-the-tableadapter-to-use-joins-vb/_static/image35.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-261">**Figure 13**: Have the ObjectDataSource Use the `GetEmployees` and `DeleteEmployee` Methods ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image35.png))</span></span>


<span data-ttu-id="ea414-262">Visual Studio의 각 GridView에는 BoundField에 추가 됩니다는 `EmployeesDataTable`의 열입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-262">Visual Studio will add a BoundField to the GridView for each of the `EmployeesDataTable` s columns.</span></span> <span data-ttu-id="ea414-263">모두 제외 하 고 이러한 BoundFields 제거 `Title`, `LastName`를 `FirstName`를 `ManagerFirstName`, 및 `ManagerLastName` 바꾸고는 `HeaderText` 성, 이름, 이름, 관리자가 마지막 4 BoundFields에 대 한 속성 및 관리자가 성, 각각.</span><span class="sxs-lookup"><span data-stu-id="ea414-263">Remove all of these BoundFields except for `Title`, `LastName`, `FirstName`, `ManagerFirstName`, and `ManagerLastName` and rename the `HeaderText` properties for the last four BoundFields to Last Name, First Name, Manager s First Name, and Manager s Last Name, respectively.</span></span>

<span data-ttu-id="ea414-264">사용자가 직원 들이이 페이지에서 삭제할 수 있도록 두 가지를 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-264">To allow users to delete employees from this page we need to do two things.</span></span> <span data-ttu-id="ea414-265">먼저 스마트 태그에서 삭제 사용 옵션을 확인 하 여 삭제 기능을 제공 하는 GridView를 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-265">First, instruct the GridView to provide deleting capabilities by checking the Enable Deleting option from its smart tag.</span></span> <span data-ttu-id="ea414-266">둘째, ObjectDataSource s를 변경 `OldValuesParameterFormatString` ObjectDataSource 마법사에서 속성 값을 설정 (`original_{0}`)을 기본값으로 (`{0}`).</span><span class="sxs-lookup"><span data-stu-id="ea414-266">Second, change the ObjectDataSource s `OldValuesParameterFormatString` property from the value set by the ObjectDataSource wizard (`original_{0}`) to its default value (`{0}`).</span></span> <span data-ttu-id="ea414-267">다음과 같이 변경한 후 GridView 및 ObjectDataSource가 선언적 태그는 다음과 비슷하게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-267">After making these changes, your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](updating-the-tableadapter-to-use-joins-vb/samples/sample7.aspx)]

<span data-ttu-id="ea414-268">브라우저를 통해이 방문 하 여 페이지를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-268">Test out the page by visiting it through a browser.</span></span> <span data-ttu-id="ea414-269">그림 14에서 볼 수 있듯이 각 직원 및 (있는 경우)가 자신의 관리자의 이름 페이지 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-269">As Figure 14 shows, the page will list each employee and his or her manager s name (assuming they have one).</span></span>


<span data-ttu-id="ea414-270">[![Employees_Select 조인이 저장 프로시저 이름을 반환 합니다 Manager s](updating-the-tableadapter-to-use-joins-vb/_static/image37.png)](updating-the-tableadapter-to-use-joins-vb/_static/image36.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-270">[![The JOIN in the Employees_Select Stored Procedure Returns the Manager s Name](updating-the-tableadapter-to-use-joins-vb/_static/image37.png)](updating-the-tableadapter-to-use-joins-vb/_static/image36.png)</span></span>

<span data-ttu-id="ea414-271">**그림 14**: 합니다 `JOIN` 에 `Employees_Select` 이름이 관리자를 반환 하는 저장 프로시저 ([전체 크기 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image38.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-271">**Figure 14**: The `JOIN` in the `Employees_Select` Stored Procedure Returns the Manager s Name ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image38.png))</span></span>


<span data-ttu-id="ea414-272">실행에서 단계가 삭제 워크플로 시작 삭제 단추를 클릭 하 여 `Employees_Delete` 저장 프로시저.</span><span class="sxs-lookup"><span data-stu-id="ea414-272">Clicking the Delete button starts the deleting workflow, which culminates in the execution of the `Employees_Delete` stored procedure.</span></span> <span data-ttu-id="ea414-273">그러나 시도가 `DELETE` 저장된 프로시저의 문이 foreign key 제약 조건 위반으로 인해 실패 (그림 15 참조).</span><span class="sxs-lookup"><span data-stu-id="ea414-273">However, the attempted `DELETE` statement in the stored procedure fails because of a foreign key constraint violation (see Figure 15).</span></span> <span data-ttu-id="ea414-274">특히, 각 직원에 하나 이상의 레코드를 `Orders` 테이블 삭제가 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-274">Specifically, each employee has one or more records in the `Orders` table, causing the delete to fail.</span></span>


<span data-ttu-id="ea414-275">[![외래 키 제약 조건 위반을 해당 주문을 결과 있는 직원을 삭제 합니다.](updating-the-tableadapter-to-use-joins-vb/_static/image40.png)](updating-the-tableadapter-to-use-joins-vb/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="ea414-275">[![Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation](updating-the-tableadapter-to-use-joins-vb/_static/image40.png)](updating-the-tableadapter-to-use-joins-vb/_static/image39.png)</span></span>

<span data-ttu-id="ea414-276">**그림 15**: 외래 키 제약 조건 위반을 해당 주문을 결과 있는 직원을 삭제 ([큰 이미지를 보려면 클릭](updating-the-tableadapter-to-use-joins-vb/_static/image41.png))</span><span class="sxs-lookup"><span data-stu-id="ea414-276">**Figure 15**: Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation ([Click to view full-size image](updating-the-tableadapter-to-use-joins-vb/_static/image41.png))</span></span>


<span data-ttu-id="ea414-277">직원이 사용할 수 있도록 하면 삭제 수:</span><span class="sxs-lookup"><span data-stu-id="ea414-277">To allow an employee to be deleted you could:</span></span>

- <span data-ttu-id="ea414-278">하위 삭제를 적용 하도록 외래 키 제약 조건 업데이트</span><span class="sxs-lookup"><span data-stu-id="ea414-278">Update the foreign key constraint to cascade deletes,</span></span>
- <span data-ttu-id="ea414-279">기록을 수동으로 삭제할는 `Orders` 삭제 하려는 직원에 대 한 테이블 또는</span><span class="sxs-lookup"><span data-stu-id="ea414-279">Manually delete the records from the `Orders` table for the employee(s) you want to delete, or</span></span>
- <span data-ttu-id="ea414-280">업데이트를 `Employees_Delete` 저장 프로시저를 먼저에서 관련된 레코드를 삭제 합니다 `Orders` 테이블을 삭제 하기 전에 `Employees` 레코드.</span><span class="sxs-lookup"><span data-stu-id="ea414-280">Update the `Employees_Delete` stored procedure to first delete the related records from the `Orders` table before deleting the `Employees` record.</span></span> <span data-ttu-id="ea414-281">이 기법을 설명한 합니다 [를 사용 하 여 기존 저장 프로시저는 입력 데이터 집합의 Tableadapter에 대 한](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-281">We discussed this technique in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span>

<span data-ttu-id="ea414-282">필자는 판독기에 대 한 연습으로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-282">I leave this as an exercise for the reader.</span></span>

## <a name="summary"></a><span data-ttu-id="ea414-283">요약</span><span class="sxs-lookup"><span data-stu-id="ea414-283">Summary</span></span>

<span data-ttu-id="ea414-284">관계형 데이터베이스에서 작업할 때 일반적으로 여러에서 해당 데이터를 가져오는 쿼리는 관련 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-284">When working with relational databases, it is common for queries to pull their data from multiple, related tables.</span></span> <span data-ttu-id="ea414-285">상관 하위 쿼리 및 `JOIN` s 쿼리에서 관련된 테이블에서 데이터를 액세스 하기 위한 두 가지 기법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-285">Correlated subqueries and `JOIN` s provide two different techniques for accessing data from related tables in a query.</span></span> <span data-ttu-id="ea414-286">TableAdapter 생성할 수 없습니다. 자동 때문에 가장 일반적으로 수행 하는 이전 자습서 상관된 하위 쿼리 사용 `INSERT`, `UPDATE`, 및 `DELETE` 관련 쿼리에 대 한 문을 `JOIN` s입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-286">In previous tutorials we most commonly made use of correlated subqueries because the TableAdapter cannot auto-generate `INSERT`, `UPDATE`, and `DELETE` statements for queries involving `JOIN` s.</span></span> <span data-ttu-id="ea414-287">임시 SQL 문을 사용 하는 경우 이러한 값을 수동으로 제공할 수 있습니다 하는 동안에 TableAdapter 구성 마법사를 완료 되 면 모든 사용자 지정 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-287">While these values can be provided manually, when using ad-hoc SQL statements any customizations will be overwritten when the TableAdapter Configuration wizard is completed.</span></span>

<span data-ttu-id="ea414-288">다행 스럽게도 Tableadapter 저장된 프로시저를 사용 하 여 만든 임시 SQL 문을 사용 하 여 만든 것과 동일한 때에서 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-288">Fortunately, TableAdapters created using stored procedures do not suffer from the same brittleness as those created using ad-hoc SQL statements.</span></span> <span data-ttu-id="ea414-289">해당 기본 쿼리에서 사용 하 여 TableAdapter를 만들 것 이므로 `JOIN` 저장된 프로시저를 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ea414-289">Therefore, it is feasible to create a TableAdapter whose main query uses a `JOIN` when using stored procedures.</span></span> <span data-ttu-id="ea414-290">이 자습서에서는 이러한 TableAdapter를 만드는 방법에 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-290">In this tutorial we saw how to create such a TableAdapter.</span></span> <span data-ttu-id="ea414-291">사용 하 여 시작을 `JOIN`-적은 `SELECT` 되도록 해당 되는 삽입, 업데이트 및 삭제 저장 프로시저는 자동 생성 TableAdapter s 주 쿼리에 대해 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-291">We started by using a `JOIN`-less `SELECT` query for the TableAdapter s main query so that the corresponding insert, update, and delete stored procedures would be auto-created.</span></span> <span data-ttu-id="ea414-292">TableAdapter가 초기 구성으로 완료 된 합니다 `SelectCommand` 저장 프로시저를 사용 하 여는 `JOIN` 업데이트 하려면 TableAdapter 구성 마법사를 다시 실행 하 고는 `EmployeesDataTable`의 열.</span><span class="sxs-lookup"><span data-stu-id="ea414-292">With the TableAdapter s initial configuration complete, we augmented the `SelectCommand` stored procedure to use a `JOIN` and re-ran the TableAdapter Configuration wizard to update the `EmployeesDataTable` s columns.</span></span>

<span data-ttu-id="ea414-293">자동으로 업데이트 TableAdapter 구성 마법사를 다시 실행 합니다 `EmployeesDataTable` 열에서 반환 된 데이터 필드를 반영 하도록는 `Employees_Select` 저장 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-293">Re-running the TableAdapter Configuration wizard automatically updated the `EmployeesDataTable` columns to reflect the data fields returned by the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="ea414-294">또는 수에 추가 했습니다 이러한 열 수동으로 DataTable입니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-294">Alternatively, we could have added these columns manually to the DataTable.</span></span> <span data-ttu-id="ea414-295">다음 자습서에서 수동으로 추가 열을 DataTable에 학습 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-295">We will explore manually adding columns to the DataTable in the next tutorial.</span></span>

<span data-ttu-id="ea414-296">즐거운 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="ea414-296">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="ea414-297">저자 소개</span><span class="sxs-lookup"><span data-stu-id="ea414-297">About the Author</span></span>

<span data-ttu-id="ea414-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적의 저자 이자 설립자입니다 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 Microsoft 웹 기술을 사용 하 여 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="ea414-299">Scott는 독립 컨설턴트, 강사, 그리고 기록기로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-299">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="ea414-300">최근 저서는 [ *Sams 설명 직접 ASP.NET 2.0 24 시간 동안의*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-300">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="ea414-301">그에 도달할 수 있습니다 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="ea414-301">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="ea414-302">찾을 수 있는 저자의 블로그를 통해 또는 [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-302">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="ea414-303">특별히 감사</span><span class="sxs-lookup"><span data-stu-id="ea414-303">Special Thanks To</span></span>

<span data-ttu-id="ea414-304">이 자습서 시리즈는 많은 유용한 검토자가 검토 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-304">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="ea414-305">이 자습서에 대 한 선행 검토자 Hilton Geisenow, David Suru 및 Teresa Murphy 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea414-305">Lead reviewers for this tutorial were Hilton Geisenow, David Suru, and Teresa Murphy.</span></span> <span data-ttu-id="ea414-306">내 향후 MSDN 문서를 검토에 관심이 있으십니까?</span><span class="sxs-lookup"><span data-stu-id="ea414-306">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="ea414-307">그렇다면 삭제 나에서 선 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="ea414-307">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="ea414-308">[이전](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)
> [다음](adding-additional-datatable-columns-vb.md)</span><span class="sxs-lookup"><span data-stu-id="ea414-308">[Previous](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)
[Next](adding-additional-datatable-columns-vb.md)</span></span>
