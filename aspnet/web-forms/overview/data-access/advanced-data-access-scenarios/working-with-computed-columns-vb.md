---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
title: "계산된 열 (VB) 작업 | Microsoft Docs"
author: rick-anderson
description: "Microsoft SQL Server 계산된 열 값은 식에서 계산을 정의할 수 있습니다는 데이터베이스 테이블을 만들 때 일반적으로 referen..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/03/2007
ms.topic: article
ms.assetid: 5811b8ff-ed56-40fc-9397-6b69ae09a8f6
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
msc.type: authoredcontent
ms.openlocfilehash: 52fc0b89343236b70f8a2e013ad8a33431ae3d2d
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/24/2018
---
<a name="working-with-computed-columns-vb"></a><span data-ttu-id="334e7-103">계산된 열 (VB) 작업</span><span class="sxs-lookup"><span data-stu-id="334e7-103">Working with Computed Columns (VB)</span></span>
====================
<span data-ttu-id="334e7-104">으로 [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="334e7-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="334e7-105">[코드를 다운로드](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip) 또는 [PDF 다운로드](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="334e7-105">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip) or [Download PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span></span>

> <span data-ttu-id="334e7-106">데이터베이스 테이블을 만들 때 Microsoft SQL Server를 사용 하면 계산된 열 값은 일반적으로 동일한 데이터베이스 레코드의 다른 값을 참조 하는 식에서 계산을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-106">When creating a database table, Microsoft SQL Server allows you to define a computed column whose value is calculated from an expression that usually references other values in the same database record.</span></span> <span data-ttu-id="334e7-107">이러한 값은 Tableadapter를 작업할 때 특별히 고려해 야 할 요구 하 여 데이터베이스에서 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-107">Such values are read-only at the database, which requires special considerations when working with TableAdapters.</span></span> <span data-ttu-id="334e7-108">이 자습서에서는 계산된 열에 의해 제기 되 과제를 충족 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-108">In this tutorial we learn how to meet the challenges posed by computed columns.</span></span>


## <a name="introduction"></a><span data-ttu-id="334e7-109">소개</span><span class="sxs-lookup"><span data-stu-id="334e7-109">Introduction</span></span>

<span data-ttu-id="334e7-110">에 대 한 Microsoft SQL Server에서는  *[계산 열](https://msdn.microsoft.com/library/ms191250.aspx)*, 열 값이 동일한 테이블의 다른 열에서 값을 일반적으로 참조 하는 식에서 계산 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-110">Microsoft SQL Server allows for *[computed columns](https://msdn.microsoft.com/library/ms191250.aspx)*, which are columns whose values are calculated from an expression that usually references the values from other columns in the same table.</span></span> <span data-ttu-id="334e7-111">예를 들어, 데이터 모델을 추적 하는 한 번 라는 테이블이 있을 수 `ServiceLog` 포함 하 여 열이 있는 `ServicePerformed`, `EmployeeID`, `Rate`, 및 `Duration`, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-111">As an example, a time tracking data model might have a table named `ServiceLog` with columns including `ServicePerformed`, `EmployeeID`, `Rate`, and `Duration`, among others.</span></span> <span data-ttu-id="334e7-112">금액 하는 동안 서비스 당 항목 웹 페이지 또는 기타 프로그래밍 인터페이스를 통해 계산할 수 없습니다 (되는 기간을 곱한 속도)는 것이 편리 하 게 포함 된 열에는 `ServiceLog` 라는 테이블 `AmountDue` 이 보고 하는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-112">While the amount due per service item (being the rate multiplied by the duration) could be calculated through a web page or other programmatic interface, it might be handy to include a column in the `ServiceLog` table named `AmountDue` that reported this information.</span></span> <span data-ttu-id="334e7-113">일반 열으로이 열을 만들 수 있지만 언제 든 지 업데이트 해야 합니다는 `Rate` 또는 `Duration` 열 값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-113">This column could be created as a normal column, but it would need to be updated anytime the `Rate` or `Duration` column values changed.</span></span> <span data-ttu-id="334e7-114">더 나은 방법은 만드는 것은 `AmountDue` 열 식을 사용 하는 계산된 열 `Rate * Duration`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-114">A better approach would be to make the `AmountDue` column a computed column using the expression `Rate * Duration`.</span></span> <span data-ttu-id="334e7-115">이렇게 하면 SQL Server를 자동으로 계산 된 `AmountDue` 때마다 쿼리에서 참조 된 열 값입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-115">Doing so would cause SQL Server to automatically calculate the `AmountDue` column value whenever it was referenced in a query.</span></span>

<span data-ttu-id="334e7-116">계산된 열의 값에 식에 의해 결정 됩니다, 이러한 열은 읽기 전용 없습니다가 값에 할당에서 `INSERT` 또는 `UPDATE` 문.</span><span class="sxs-lookup"><span data-stu-id="334e7-116">Since a computed column s value is determined by an expression, such columns are read-only and therefore cannot have values assigned to them in `INSERT` or `UPDATE` statements.</span></span> <span data-ttu-id="334e7-117">그러나 계산된 열에 임시 SQL 문을 사용 하는 TableAdapter에 대 한 기본 쿼리에 포함 된 경우 자동으로에서 다루지 않으므로 자동 생성 `INSERT` 및 `UPDATE` 문.</span><span class="sxs-lookup"><span data-stu-id="334e7-117">However, when computed columns are part of the main query for a TableAdapter that uses ad-hoc SQL statements, they are automatically included in the auto-generated `INSERT` and `UPDATE` statements.</span></span> <span data-ttu-id="334e7-118">Tableadapter 따라서 `INSERT` 및 `UPDATE` 쿼리 및 `InsertCommand` 및 `UpdateCommand` 계산된 열에 대 한 참조를 제거 하려면 속성을 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-118">Consequently, the TableAdapter s `INSERT` and `UPDATE` queries and `InsertCommand` and `UpdateCommand` properties must be updated to remove references to any computed columns.</span></span>

<span data-ttu-id="334e7-119">사용 하 여의 한 가지 문제 계산 임시 SQL 문을 사용 하는 TableAdapter가 포함 된 열은 TableAdapter s `INSERT` 및 `UPDATE` 쿼리 TableAdapter 구성 마법사가 완료 되는 언제 든 지 자동으로 다시 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-119">One challenge of using computed columns with a TableAdapter that uses ad-hoc SQL statements is that the TableAdapter s `INSERT` and `UPDATE` queries are automatically regenerated any time the TableAdapter Configuration wizard is completed.</span></span> <span data-ttu-id="334e7-120">계산된 열에서 수동으로 제거 따라서는 `INSERT` 및 `UPDATE` 마법사 다시 실행 되는 경우 쿼리 다시 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-120">Therefore, the computed columns manually removed from the `INSERT` and `UPDATE` queries will reappear if the wizard is re-run.</span></span> <span data-ttu-id="334e7-121">저장된 프로시저를 사용 하는 Tableadapter 인할이 오류를 발생를 3 단계에서에서 해결 하는 자체 quirks 되어지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-121">Although TableAdapters that use stored procedures don t suffer from this brittleness, they do have their own quirks that we will address in Step 3.</span></span>

<span data-ttu-id="334e7-122">이 자습서에서는 계산된 열을 추가 합니다는 `Suppliers` Northwind 데이터베이스의 테이블을 다음이 테이블의 계산된 열과 작동 하도록 해당 TableAdapter를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-122">In this tutorial we will add a computed column to the `Suppliers` table in the Northwind database and then create a corresponding TableAdapter to work with this table and its computed column.</span></span> <span data-ttu-id="334e7-123">TableAdapter 구성 마법사를 사용 하는 경우이 사용자 지정 클라우드에 없는 t 손실 되도록 임시 SQL 문 대신 저장된 프로시저를 사용 하는 TableAdapter 있다고 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-123">We will have our TableAdapter use stored procedures instead of ad-hoc SQL statements so that our customizations aren t lost when the TableAdapter Configuration wizard is used.</span></span>

<span data-ttu-id="334e7-124">Let s가 시작 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-124">Let s get started!</span></span>

## <a name="step-1-adding-a-computed-column-to-thesupplierstable"></a><span data-ttu-id="334e7-125">1 단계: 계산된 열을 추가`Suppliers`테이블</span><span class="sxs-lookup"><span data-stu-id="334e7-125">Step 1: Adding a Computed Column to the`Suppliers`Table</span></span>

<span data-ttu-id="334e7-126">Northwind 데이터베이스에 없으므로 계산된 열 하나 직접 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-126">The Northwind database does not have any computed columns so we will need to add one ourselves.</span></span> <span data-ttu-id="334e7-127">이 자습서에 계산된 열을 추가 하는 s 사용에 대 한는 `Suppliers` 라는 테이블 `FullContactName` 형식에서 s 연락처 이름, 제목 및에 대해 작동 하는 회사를 반환 하: `ContactName` (`ContactTitle`, `CompanyName`).</span><span class="sxs-lookup"><span data-stu-id="334e7-127">For this tutorial let s add a computed column to the `Suppliers` table called `FullContactName` that returns the contact s name, title, and the company they work for in the following format: `ContactName` (`ContactTitle`, `CompanyName`).</span></span> <span data-ttu-id="334e7-128">이 계산 열 공급자에 대 한 정보를 표시할 때 보고서에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-128">This computed column might be used in reports when displaying information about suppliers.</span></span>

<span data-ttu-id="334e7-129">열어 시작는 `Suppliers` 마우스 오른쪽 단추로 클릭 하 여 테이블 정의 `Suppliers` 서버 탐색기에서 테이블 및 테이블 정의 열기 상황에 맞는 메뉴에서 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-129">Start by opening the `Suppliers` table definition by right-clicking on the `Suppliers` table in the Server Explorer and choosing Open Table Definition from the context-menu.</span></span> <span data-ttu-id="334e7-130">허용 하는지 여부 및 해당 데이터 형식 등의 속성을 테이블의 열이 표시 됩니다 `NULL` s 및 붙습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-130">This will display the columns of the table and their properties, such as their data type, whether they allow `NULL` s, and so forth.</span></span> <span data-ttu-id="334e7-131">계산된 열을 추가 하려면 먼저 테이블 정의에 열 이름을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-131">To add a computed column, start by typing in the name of the column into the table definition.</span></span> <span data-ttu-id="334e7-132">그런 다음 해당 식을 열 속성 창에서 계산 열 사양 섹션 (수식) 텍스트 상자에 입력 (그림 1 참조).</span><span class="sxs-lookup"><span data-stu-id="334e7-132">Next, enter its expression into the (Formula) textbox under the Computed Column Specification section in the Column Properties window (see Figure 1).</span></span> <span data-ttu-id="334e7-133">계산된 열의 이름을 `FullContactName` 다음 식을 사용 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-133">Name the computed column `FullContactName` and use the following expression:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample1.sql)]

<span data-ttu-id="334e7-134">SQL에서 문자열을 연결할 수 있는지 참고를 사용 하는 `+` 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-134">Note that strings can be concatenated in SQL using the `+` operator.</span></span> <span data-ttu-id="334e7-135">`CASE` 기존의 프로그래밍 언어에는 조건부와 같은 문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-135">The `CASE` statement can be used like a conditional in a traditional programming language.</span></span> <span data-ttu-id="334e7-136">위 식에서는 `CASE` 문을로 읽을 수 있습니다: 경우 `ContactTitle` 않습니다 `NULL` 다음 출력 하는 `ContactTitle` 쉼표, 그렇지 않으면 연결 값을 내보낼 nothing입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-136">In the above expression the `CASE` statement can be read as: If `ContactTitle` is not `NULL` then output the `ContactTitle` value concatenated with a comma, otherwise emit nothing.</span></span> <span data-ttu-id="334e7-137">유용성에 대 한 자세한는 `CASE` 문을 참조 [SQL의 전원 `CASE` 문을](http://www.4guysfromrolla.com/webtech/102704-1.shtml)합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-137">For more on the usefulness of the `CASE` statement, see [The Power of SQL `CASE` Statements](http://www.4guysfromrolla.com/webtech/102704-1.shtml).</span></span>

> [!NOTE]
> <span data-ttu-id="334e7-138">사용 하는 대신 한 `CASE` 여기 문, 또는 사용할 수도 `ISNULL(ContactTitle, '')`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-138">Instead of using a `CASE` statement here, we could have alternatively used `ISNULL(ContactTitle, '')`.</span></span> <span data-ttu-id="334e7-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx)반환 *checkExpression* NULL이 아닌 경우, 그렇지 않으면 반환 *replacementValue*합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx) returns *checkExpression* if it is non-NULL, otherwise it returns *replacementValue*.</span></span> <span data-ttu-id="334e7-140">하나는 동안 `ISNULL` 또는 `CASE` 작동이 경우에는 더 복잡 한 시나리오 여기서의 유연성은 `CASE` 문을 일치할 수 없는 `ISNULL`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-140">While either `ISNULL` or `CASE` will work in this instance, there are more intricate scenarios where the flexibility of the `CASE` statement cannot be matched by `ISNULL`.</span></span>


<span data-ttu-id="334e7-141">이 계산된 열을 추가한 후 화면에 나오는 그림 1 스크린 샷의와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-141">After adding this computed column your screen should look like the screen shot in Figure 1.</span></span>


<span data-ttu-id="334e7-142">[![FullContactName Suppliers 테이블에 명명 된 계산된 열 추가](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-142">[![Add a Computed Column Named FullContactName to the Suppliers Table](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span></span>

<span data-ttu-id="334e7-143">**그림 1**: 계산 된 열 라는 추가 `FullContactName` 에 `Suppliers` 테이블 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-143">**Figure 1**: Add a Computed Column Named `FullContactName` to the `Suppliers` Table ([Click to view full-size image](working-with-computed-columns-vb/_static/image3.png))</span></span>


<span data-ttu-id="334e7-144">계산된 된 열 이름을 지정 하 고 해당 식을 입력 한 후 변경 내용을 저장 테이블에는 도구 모음에 저장 아이콘을 클릭 하 여, Ctrl + S를 클릭 하 여 또는 파일 메뉴로 이동 하 고 저장을 선택 하 여 `Suppliers`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-144">After naming the computed column and entering its expression, save the changes to the table by clicking the Save icon in the toolbar, by hitting Ctrl+S, or by going to the File menu and choosing Save `Suppliers`.</span></span>

<span data-ttu-id="334e7-145">방금 추가 된 열을 포함 하는 서버 탐색기를 새로 고쳐야 테이블 저장 하는 `Suppliers`의 테이블 열 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-145">Saving the table should refresh the Server Explorer, including the just-added column in the `Suppliers` table s column list.</span></span> <span data-ttu-id="334e7-146">열 이름을 대괄호로 둘러쌉니다, 불필요 한 공백을 제거 하는 해당 하는 식으로 자동으로 조정 하는 (수식) 텍스트 상자에 입력 된 식 또한 (`[]`)를 더 명시적으로 표시 하려면 괄호를 포함 합니다. 작업 순서:</span><span class="sxs-lookup"><span data-stu-id="334e7-146">Furthermore, the expression entered into the (Formula) textbox will automatically adjust to an equivalent expression that strips unnecessary whitespace, surrounds column names with brackets (`[]`), and includes parentheses to more explicitly show the order of operations:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample2.sql)]

<span data-ttu-id="334e7-147">Microsoft SQL Server에서 계산된 열에 대 한 자세한 내용은 참조는 [기술 문서](https://msdn.microsoft.com/library/ms191250.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-147">For more information on computed columns in Microsoft SQL Server, refer to the [technical documentation](https://msdn.microsoft.com/library/ms191250.aspx).</span></span> <span data-ttu-id="334e7-148">또한 체크 아웃의 [하는 방법: Specify Computed Columns](https://msdn.microsoft.com/library/ms188300.aspx) 계산된 열을 만드는 단계별 연습 과정에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-148">Also check out the [How to: Specify Computed Columns](https://msdn.microsoft.com/library/ms188300.aspx) for a step-by-step walkthrough of creating computed columns.</span></span>

> [!NOTE]
> <span data-ttu-id="334e7-149">기본적으로 계산된 열은 테이블에 물리적으로 저장 되지 않습니다 되지만 대신 쿼리에서 참조 될 때마다 다시 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-149">By default, computed columns are not physically stored in the table but are instead recalculated each time they are referenced in a query.</span></span> <span data-ttu-id="334e7-150">그러나이 확인란은 유지를 선택 하 여 테이블의 계산된 열을 물리적으로 저장 하도록 SQL Server 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-150">By checking the Is Persisted checkbox, however, you can instruct SQL Server to physically store the computed column in the table.</span></span> <span data-ttu-id="334e7-151">이렇게 인덱스에 계산된 열 값을 사용 하는 쿼리의 성능을 향상 시킬 수 있는 계산된 열에 만들 수 있습니다. 해당 `WHERE` 절.</span><span class="sxs-lookup"><span data-stu-id="334e7-151">Doing so allows an index to be created on the computed column, which can improve the performance of queries that use the computed column value in their `WHERE` clauses.</span></span> <span data-ttu-id="334e7-152">참조 [Indexes on Computed Columns](https://msdn.microsoft.com/library/ms189292.aspx) 자세한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-152">See [Creating Indexes on Computed Columns](https://msdn.microsoft.com/library/ms189292.aspx) for more information.</span></span>


## <a name="step-2-viewing-the-computed-column-s-values"></a><span data-ttu-id="334e7-153">2 단계: 계산된 열의 값 보기</span><span class="sxs-lookup"><span data-stu-id="334e7-153">Step 2: Viewing the Computed Column s Values</span></span>

<span data-ttu-id="334e7-154">Let s를 보려면 잠시 데이터 액세스 계층에서 작업을 시작 하기 전에 `FullContactName` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-154">Before we start work on the Data Access Layer, let s take a minute to view the `FullContactName` values.</span></span> <span data-ttu-id="334e7-155">서버 탐색기에서 마우스 오른쪽 단추로 클릭는 `Suppliers` 테이블 이름 하 고 상황에 맞는 메뉴에서 새 쿼리를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-155">From the Server Explorer, right-click on the `Suppliers` table name and choose New Query from the context-menu.</span></span> <span data-ttu-id="334e7-156">테이블의 정의와 쿼리에 포함 하도록 선택 하 라는 메시지가 나타납니다 쿼리 창이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-156">This will bring up a Query window that prompts us to choose what tables to include in the query.</span></span> <span data-ttu-id="334e7-157">추가 `Suppliers` 테이블 한 닫기를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-157">Add the `Suppliers` table and click Close.</span></span> <span data-ttu-id="334e7-158">그런 다음, 확인 된 `CompanyName`, `ContactName`, `ContactTitle`, 및 `FullContactName` Suppliers 테이블의 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-158">Next, check the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` columns from the Suppliers table.</span></span> <span data-ttu-id="334e7-159">마지막으로 쿼리를 실행 하 고 결과 확인 하려면 도구 모음에서 빨강 느낌표 아이콘을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-159">Finally, click the red exclamation point icon in the Toolbar to execute the query and view the results.</span></span>

<span data-ttu-id="334e7-160">결과 포함 하는 그림 2에서 볼 수 있듯이 `FullContactName`, 되는 목록을 `CompanyName`, `ContactName`, 및 `ContactTitle` 형식을 사용 하 여 열 `ContactName` (`ContactTitle`, `CompanyName`).</span><span class="sxs-lookup"><span data-stu-id="334e7-160">As Figure 2 shows, the results include `FullContactName`, which lists the `CompanyName`, `ContactName`, and `ContactTitle` columns using the format `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>


<span data-ttu-id="334e7-161">[![FullContactName 형식 ContactName (ContactTitle, CompanyName)를 사용 하 여](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-161">[![The FullContactName Uses the Format ContactName (ContactTitle, CompanyName)](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span></span>

<span data-ttu-id="334e7-162">**그림 2**:는 `FullContactName` 형식을 사용 하 여 `ContactName` (`ContactTitle`, `CompanyName`) ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-162">**Figure 2**: The `FullContactName` Uses the Format `ContactName` (`ContactTitle`, `CompanyName`) ([Click to view full-size image](working-with-computed-columns-vb/_static/image6.png))</span></span>


## <a name="step-3-adding-thesupplierstableadapterto-the-data-access-layer"></a><span data-ttu-id="334e7-163">3 단계: 추가 된`SuppliersTableAdapter`데이터 액세스 계층</span><span class="sxs-lookup"><span data-stu-id="334e7-163">Step 3: Adding the`SuppliersTableAdapter`to the Data Access Layer</span></span>

<span data-ttu-id="334e7-164">응용 프로그램의 공급 업체 정보를 사용 하려면 우선 우리의 DAL에서 TableAdapter와 DataTable을 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-164">In order to work with the supplier information in our application we need to first create a TableAdapter and DataTable in our DAL.</span></span> <span data-ttu-id="334e7-165">이상적으로 이렇게 이전 자습서에서 검토할 같은 간단한 단계를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-165">Ideally, this would be accomplished using the same straightforward steps examined in earlier tutorials.</span></span> <span data-ttu-id="334e7-166">그러나 계산된 열이 있는 작업 토론 대해서는 몇 가지 주름을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-166">However, working with computed columns introduces a few wrinkles that merit discussion.</span></span>

<span data-ttu-id="334e7-167">임시 SQL 문을 사용 하는 TableAdapter를 사용 하는 경우 TableAdapter s 주 쿼리에서 TableAdapter 구성 마법사를 통해 단순히 계산된 열을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-167">If you are using a TableAdapter that uses ad-hoc SQL statements, you can simply include the computed column in the TableAdapter s main query via the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="334e7-168">그러나이를 자동으로 생성 `INSERT` 및 `UPDATE` 계산된 열을 포함 하는 문입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-168">This, however, will auto-generate `INSERT` and `UPDATE` statements that include the computed column.</span></span> <span data-ttu-id="334e7-169">다음이 방법 중 하나를 실행 하려고 하는 경우는 `SqlException` 열 메시지와 함께 *ColumnName* 은 계산된 열 이거나 UNION 연산자의 결과 throw 됩니다 이므로 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-169">If you attempt to execute one of these methods, a `SqlException` with the message The column *ColumnName* cannot be modified because it is either a computed column or is the result of a UNION operator will be thrown.</span></span> <span data-ttu-id="334e7-170">반면는 `INSERT` 및 `UPDATE` 문은 TableAdapter s 통해 수동으로 조정할 수 있습니다 `InsertCommand` 및 `UpdateCommand` 속성, 이러한 사용자 지정 손실 됩니다 TableAdapter 구성 마법사를 다시 실행 될 때마다 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-170">While the `INSERT` and `UPDATE` statement can be manually adjusted through the TableAdapter s `InsertCommand` and `UpdateCommand` properties, these customizations will be lost whenever the TableAdapter Configuration wizard is re-run.</span></span>

<span data-ttu-id="334e7-171">임시 SQL 문을 사용 하는 Tableadapter의 오류, 인해 것이 좋습니다 계산된 열을 작업할 때 저장된 프로시저를 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-171">Due to the brittleness of TableAdapters that use ad-hoc SQL statements, it is recommended that we use stored procedures when working with computed columns.</span></span> <span data-ttu-id="334e7-172">기존 저장된 프로시저를 사용 하는 경우 단순히 TableAdapter를 구성에 설명 된 대로 [를 사용 하 여 기존 저장 프로시저 형식화 된 데이터 집합의 Tableadapter에 대 한](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-172">If you are using existing stored procedures, simply configure the TableAdapter as discussed in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span> <span data-ttu-id="334e7-173">그러나 저장된 프로시저 만들기 TableAdapter 마법사를 사용 하도록 설정한 경우 되기 처음에 주 쿼리에서 모든 계산된 열을 생략 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-173">If you have the TableAdapter wizard create the stored procedures for you, however, it is important to initially omit any computed columns from the main query.</span></span> <span data-ttu-id="334e7-174">주 쿼리에서 계산된 열을 포함 하는 경우 TableAdapter 구성 마법사는 알립니다, 완료 되 면 해당 저장된 프로시저를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-174">If you include a computed column in the main query, the TableAdapter Configuration wizard will inform you, upon completion, that it cannot create the corresponding stored procedures.</span></span> <span data-ttu-id="334e7-175">처음에 계산된 열 필요 없는 주 쿼리를 사용 하 여 TableAdapter를 구성 하 고 해당 저장된 프로시저 및 TableAdapter s 다음 수동으로 업데이트 해야 간단히 말해서 `SelectCommand` 계산된 열을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-175">In short, we need to initially configure the TableAdapter using a computed column-free main query and then manually update the corresponding stored procedure and the TableAdapter s `SelectCommand` to include the computed column.</span></span> <span data-ttu-id="334e7-176">이 방법은 사용 되는 비슷합니다는 [TableAdapter를 사용 하 여 업데이트](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s* 자습서입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-176">This approach is similar to the one used in the [Updating the TableAdapter to Use](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s* tutorial.</span></span>

<span data-ttu-id="334e7-177">이 자습서에서는 새 TableAdapter를 추가 하 고 us에 대 한 저장된 프로시저를 자동으로 만들 하도록 s가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-177">For this tutorial, let s add a new TableAdapter and have it automatically create the stored procedures for us.</span></span> <span data-ttu-id="334e7-178">따라서 처음 생략 해야 합니다는 `FullContactName` 기본 쿼리에서 계산된 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-178">Consequently, we will need to initially omit the `FullContactName` computed column from the main query.</span></span>

<span data-ttu-id="334e7-179">열어 시작는 `NorthwindWithSprocs` 에서 데이터 집합의 `~/App_Code/DAL` 폴더입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-179">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="334e7-180">디자이너에서 마우스, 상황에 맞는 메뉴에서 새 TableAdapter를 추가 하려면 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-180">Right-click in the Designer and, from the context-menu, choose to add a new TableAdapter.</span></span> <span data-ttu-id="334e7-181">TableAdapter 구성 마법사를 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-181">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="334e7-182">데이터베이스에서 데이터를 쿼리할 수 지정 (`NORTHWNDConnectionString` 에서 `Web.config`) 하 고을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-182">Specify the database to query data from (`NORTHWNDConnectionString` from `Web.config`) and click Next.</span></span> <span data-ttu-id="334e7-183">이후 쿼리 또는 수정에 대 한 모든 저장된 프로시저를 아직 만들지 않은 우리는 `Suppliers` 테이블을 새 저장된 프로시저 옵션을 마법사는 us에 하 고 다음 만들기를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-183">Since we have not yet created any stored procedures for querying or modifying the `Suppliers` table, select the Create new stored procedures option so that the wizard will create them for us and click Next.</span></span>


<span data-ttu-id="334e7-184">[![새 저장된 프로시저 만들기 옵션을 선택 합니다.](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-184">[![Choose the Create new stored procedures Option](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span></span>

<span data-ttu-id="334e7-185">**그림 3**:는 새 저장된 프로시저 만들기 옵션을 선택 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-185">**Figure 3**: Choose the Create new stored procedures Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image9.png))</span></span>


<span data-ttu-id="334e7-186">다음 단계는 기본 쿼리에 라는 메시지가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-186">The subsequent step prompts us for the main query.</span></span> <span data-ttu-id="334e7-187">반환 하는 다음 쿼리를 입력 하 고 `SupplierID`, `CompanyName`, `ContactName`, 및 `ContactTitle` 각 공급 업체에 대 한 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-187">Enter the following query, which returns the `SupplierID`, `CompanyName`, `ContactName`, and `ContactTitle` columns for each supplier.</span></span> <span data-ttu-id="334e7-188">이 쿼리는 계산된 열을 의도적으로 생략 하는 참고 (`FullContactName`); 4 단계에서에서이 열을 포함 하려면 해당 저장된 프로시저가 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-188">Note that this query purposefully omits the computed column (`FullContactName`); we will update the corresponding stored procedure to include this column in Step 4.</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample3.sql)]

<span data-ttu-id="334e7-189">주 쿼리를 입력 하 고 다음을 클릭 한 후 마법사는 이름을 생성 하는 네 개의 저장된 프로시저 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-189">After entering the main query and clicking Next, the wizard allows us to name the four stored procedures it will generate.</span></span> <span data-ttu-id="334e7-190">이러한 저장된 프로시저 이름을 `Suppliers_Select`, `Suppliers_Insert`, `Suppliers_Update`, 및 `Suppliers_Delete`그림 4와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-190">Name these stored procedures `Suppliers_Select`, `Suppliers_Insert`, `Suppliers_Update`, and `Suppliers_Delete`, as Figure 4 illustrates.</span></span>


<span data-ttu-id="334e7-191">[![자동 생성 저장된 프로시저의 이름을 사용자 지정](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-191">[![Customize the Names of the Auto-Generated Stored Procedures](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span></span>

<span data-ttu-id="334e7-192">**그림 4**: Auto-Generated 저장 프로시저의 이름을 사용자 지정 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-192">**Figure 4**: Customize the Names of the Auto-Generated Stored Procedures ([Click to view full-size image](working-with-computed-columns-vb/_static/image12.png))</span></span>


<span data-ttu-id="334e7-193">다음 마법사 단계에는 TableAdapter의 메서드 이름을 지정 하 고 데이터 액세스 및 업데이트에 사용 되는 패턴을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-193">The next wizard step allows us to name the TableAdapter s methods and specify the patterns used to access and update data.</span></span> <span data-ttu-id="334e7-194">이 옵션을 선택 하는 모든 세 확인란 나 가지만 이름 바꾸기는 `GetData` 메서드를 `GetSuppliers`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-194">Leave all three checkboxes checked, but rename the `GetData` method to `GetSuppliers`.</span></span> <span data-ttu-id="334e7-195">마법사를 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-195">Click Finish to complete the wizard.</span></span>


<span data-ttu-id="334e7-196">[![GetData 메서드 GetSuppliers를 이름을 바꿉니다.](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-196">[![Rename the GetData Method to GetSuppliers](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span></span>

<span data-ttu-id="334e7-197">**그림 5**: 이름 바꾸기는 `GetData` 메서드를 `GetSuppliers` ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-197">**Figure 5**: Rename the `GetData` Method to `GetSuppliers` ([Click to view full-size image](working-with-computed-columns-vb/_static/image15.png))</span></span>


<span data-ttu-id="334e7-198">마법사 완료 후를 클릭 하면 4 개의 저장된 프로시저 만들고이 형식화 된 데이터 집합에 TableAdapter 및 해당 DataTable을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-198">Upon clicking Finish, the wizard will create the four stored procedures and add the TableAdapter and corresponding DataTable to the Typed DataSet.</span></span>

## <a name="step-4-including-the-computed-column-in-the-tableadapter-s-main-query"></a><span data-ttu-id="334e7-199">4 단계: 계산된 열을 포함 하 여 TableAdapter s 주 쿼리에서</span><span class="sxs-lookup"><span data-stu-id="334e7-199">Step 4: Including the Computed Column in the TableAdapter s Main Query</span></span>

<span data-ttu-id="334e7-200">이제 TableAdapter를 업데이트 해야 하 고 DataTable 포함 하려면 3 단계에서에서 만든는 `FullContactName` 계산된 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-200">We now need to update the TableAdapter and DataTable created in Step 3 to include the `FullContactName` computed column.</span></span> <span data-ttu-id="334e7-201">이 두 단계로 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-201">This involves two steps:</span></span>

1. <span data-ttu-id="334e7-202">업데이트는 `Suppliers_Select` 저장 프로시저가 반환 하는 `FullContactName` 계산된 열 및</span><span class="sxs-lookup"><span data-stu-id="334e7-202">Updating the `Suppliers_Select` stored procedure to return the `FullContactName` computed column, and</span></span>
2. <span data-ttu-id="334e7-203">업데이트는 해당 포함 하도록 DataTable `FullContactName` 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-203">Updating the DataTable to include a corresponding `FullContactName` column.</span></span>

<span data-ttu-id="334e7-204">서버 탐색기에 이동한 Stored Procedures 폴더에 드릴 다운 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-204">Start by navigating to the Server Explorer and drilling down into the Stored Procedures folder.</span></span> <span data-ttu-id="334e7-205">열기는 `Suppliers_Select` 저장 프로시저 및 업데이트는 `SELECT` 포함 하도록 쿼리는 `FullContactName` 계산된 열:</span><span class="sxs-lookup"><span data-stu-id="334e7-205">Open the `Suppliers_Select` stored procedure and update the `SELECT` query to include the `FullContactName` computed column:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample4.sql)]

<span data-ttu-id="334e7-206">도구 모음에 저장 아이콘을 클릭 하 여, Ctrl + S를 클릭 하 여 또는 저장 선택 하 여 저장된 프로시저의 변경 내용을 저장 `Suppliers_Select` 파일 메뉴에서 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-206">Save the changes to the stored procedure by clicking the Save icon in the Toolbar, by hitting Ctrl+S, or by choosing the Save `Suppliers_Select` option from the File menu.</span></span>

<span data-ttu-id="334e7-207">다음으로, 데이터 집합 디자이너를 반환 하 여 마우스 오른쪽 단추로 클릭는 `SuppliersTableAdapter`, 상황에 맞는 메뉴에서 구성 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-207">Next, return to the DataSet Designer, right-click on the `SuppliersTableAdapter`, and choose Configure from the context-menu.</span></span> <span data-ttu-id="334e7-208">`Suppliers_Select` 열에 포함 되어 이제는 `FullContactName` 해당 데이터 열 컬렉션에 있는 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-208">Note that the `Suppliers_Select` column now includes the `FullContactName` column in its Data Columns collection.</span></span>


<span data-ttu-id="334e7-209">[![DataTable의 열을 업데이트할 TableAdapter의 구성 마법사 실행](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-209">[![Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span></span>

<span data-ttu-id="334e7-210">**그림 6**: TableAdapter의 DataTable의 열을 업데이트 하려면 구성 마법사 실행 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-210">**Figure 6**: Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns ([Click to view full-size image](working-with-computed-columns-vb/_static/image18.png))</span></span>


<span data-ttu-id="334e7-211">마법사를 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-211">Click Finish to complete the wizard.</span></span> <span data-ttu-id="334e7-212">해당 하는 열을 자동으로 추가 됩니다이 `SuppliersDataTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-212">This will automatically add a corresponding column to the `SuppliersDataTable`.</span></span> <span data-ttu-id="334e7-213">TableAdapter 마법사는 점을 감지할 수는 `FullContactName` 열은 계산된 열 및 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-213">The TableAdapter wizard is smart enough to detect that the `FullContactName` column is a computed column and therefore read-only.</span></span> <span data-ttu-id="334e7-214">따라서 열 s 설정 `ReadOnly` 속성을 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-214">Consequently, it sets the column s `ReadOnly` property to `true`.</span></span> <span data-ttu-id="334e7-215">이 확인 하려면에서 열을 선택 된 `SuppliersDataTable` 하 고 속성 창으로 이동 합니다 (그림 7 참조).</span><span class="sxs-lookup"><span data-stu-id="334e7-215">To verify this, select the column from the `SuppliersDataTable` and then go to the Properties window (see Figure 7).</span></span> <span data-ttu-id="334e7-216">`FullContactName` 열 s `DataType` 및 `MaxLength` 속성 적절 하 게 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-216">Note that the `FullContactName` column s `DataType` and `MaxLength` properties are also set accordingly.</span></span>


<span data-ttu-id="334e7-217">[![FullContactName 열이 읽기 전용으로 표시 되어 있습니다.](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-217">[![The FullContactName Column is Marked as Read-Only](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span></span>

<span data-ttu-id="334e7-218">**그림 7**:는 `FullContactName` 열이 읽기 전용으로 표시 되어 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-218">**Figure 7**: The `FullContactName` Column is Marked as Read-Only ([Click to view full-size image](working-with-computed-columns-vb/_static/image21.png))</span></span>


## <a name="step-5-adding-agetsupplierbysupplieridmethod-to-the-tableadapter"></a><span data-ttu-id="334e7-219">5 단계: 추가 된`GetSupplierBySupplierID`TableAdapter에 메서드</span><span class="sxs-lookup"><span data-stu-id="334e7-219">Step 5: Adding a`GetSupplierBySupplierID`Method to the TableAdapter</span></span>

<span data-ttu-id="334e7-220">이 자습서에 대 한 공급 업체는 업데이트 가능한 표로 표시 하는 ASP.NET 페이지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-220">For this tutorial we will create an ASP.NET page that displays the suppliers in an updateable grid.</span></span> <span data-ttu-id="334e7-221">지난 자습서 업데이트 비즈니스 논리 계층에서 단일 레코드에 변경 내용을 전파 하는 dal과 해당 속성을 업데이트 하 고 업데이트 된 DataTable를 보내는 강력한 형식의 DataTable로 DAL에서 특정 레코드 백업는 검색 하 여 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-221">In past tutorials we have updated a single record from the Business Logic Layer by retrieving that particular record from the DAL as a strongly-typed DataTable, updating its properties, and then sending the updated DataTable back to the DAL to propagate the changes to the database.</span></span> <span data-ttu-id="334e7-222">-DAL에서 업데이트 되는 레코드를 검색-이 첫 번째 단계를 수행 하려면 먼저 추가 해야는 `GetSupplierBySupplierID(supplierID)` 에 dal과 메서드.</span><span class="sxs-lookup"><span data-stu-id="334e7-222">To accomplish this first step - retrieving the record being updated from the DAL - we need to first add a `GetSupplierBySupplierID(supplierID)` method to the DAL.</span></span>

<span data-ttu-id="334e7-223">마우스 오른쪽 단추로 클릭는 `SuppliersTableAdapter` 데이터 집합 디자인 하 고 상황에 맞는 메뉴에서 추가 쿼리 옵션을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-223">Right-click on the `SuppliersTableAdapter` in the DataSet Design and choose the Add Query option from the context-menu.</span></span> <span data-ttu-id="334e7-224">3 단계에서에서 했던 것 처럼 새 저장된 프로시저 만들기 옵션을 선택 하 여 새 저장된 프로시저를 위해 생성 마법사를 통해 (참조 다시 그림 3 마법사의 스크린 샷에 대 한).</span><span class="sxs-lookup"><span data-stu-id="334e7-224">As we did in Step 3, let the wizard generate a new stored procedure for us by selecting the Create new stored procedure option (refer back to Figure 3 for a screenshot of this wizard step).</span></span> <span data-ttu-id="334e7-225">이 메서드는 여러 열이 있는 레코드를 반환 하 고는 선택 하는 행을 반환 하는 SQL 쿼리를 사용 하 고 다음을 클릭 하을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-225">Since this method will return a record with multiple columns, indicate that we want to use a SQL query that is a SELECT which returns rows and click Next.</span></span>


<span data-ttu-id="334e7-226">[![선택 옵션 행을 반환 합니다](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-226">[![Choose the SELECT which returns rows Option](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span></span>

<span data-ttu-id="334e7-227">**그림 8**: 선택 옵션 행을 반환 합니다 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-227">**Figure 8**: Choose the SELECT which returns rows Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image24.png))</span></span>


<span data-ttu-id="334e7-228">이후 단계 쿼리에서이 메서드에 대 한 사용 하 라는 메시지가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-228">The subsequent step prompts us for the query to use for this method.</span></span> <span data-ttu-id="334e7-229">주 쿼리에서 동일 하지만 특정 공급 업체에 대 한 동일한 데이터 필드를 반환 하 고 다음을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-229">Enter the following, which returns the same data fields as the main query but for a particular supplier.</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample5.sql)]

<span data-ttu-id="334e7-230">다음 화면에서 자동으로 생성 되는 저장된 프로시저 이름을 묻는 메시지가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-230">The next screen asks us to name the stored procedure that will be auto-generated.</span></span> <span data-ttu-id="334e7-231">이 저장된 프로시저 이름을 `Suppliers_SelectBySupplierID` 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-231">Name this stored procedure `Suppliers_SelectBySupplierID` and click Next.</span></span>


<span data-ttu-id="334e7-232">[![저장된 프로시저 Suppliers_SelectBySupplierID 이름](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-232">[![Name the Stored Procedure Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span></span>

<span data-ttu-id="334e7-233">**그림 9**: 저장 프로시저 이름을 `Suppliers_SelectBySupplierID` ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image27.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-233">**Figure 9**: Name the Stored Procedure `Suppliers_SelectBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image27.png))</span></span>


<span data-ttu-id="334e7-234">마지막으로, 마법사에 나타나는 메시지 패턴 및 메서드 이름을 TableAdapter에 사용할 액세스 하는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-234">Lastly, the wizard prompts us for the data access patterns and method names to use for the TableAdapter.</span></span> <span data-ttu-id="334e7-235">이 옵션을 선택 확인란을 모두 유지 되지만 이름을 바꿀는 `FillBy` 및 `GetDataBy` 메서드를 `FillBySupplierID` 및 `GetSupplierBySupplierID`각각.</span><span class="sxs-lookup"><span data-stu-id="334e7-235">Leave both checkboxes checked, but rename the `FillBy` and `GetDataBy` methods to `FillBySupplierID` and `GetSupplierBySupplierID`, respectively.</span></span>


<span data-ttu-id="334e7-236">[![TableAdapter 메서드 FillBySupplierID 이름과 GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-236">[![Name the TableAdapter Methods FillBySupplierID and GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span></span>

<span data-ttu-id="334e7-237">**그림 10**: TableAdapter 메서드 이름을 `FillBySupplierID` 및 `GetSupplierBySupplierID` ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image30.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-237">**Figure 10**: Name the TableAdapter Methods `FillBySupplierID` and `GetSupplierBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image30.png))</span></span>


<span data-ttu-id="334e7-238">마법사를 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-238">Click Finish to complete the wizard.</span></span>

## <a name="step-6-creating-the-business-logic-layer"></a><span data-ttu-id="334e7-239">6 단계: 비즈니스 논리 계층 만들기</span><span class="sxs-lookup"><span data-stu-id="334e7-239">Step 6: Creating the Business Logic Layer</span></span>

<span data-ttu-id="334e7-240">1 단계에서에서 만든 계산된 열을 사용 하는 ASP.NET 페이지를 만들기 전에 먼저 BLL에 해당 하는 메서드를 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-240">Before we create an ASP.NET page that uses the computed column created in Step 1, we first need to add the corresponding methods in the BLL.</span></span> <span data-ttu-id="334e7-241">7 단계에서에서 만들, 우리의 ASP.NET 페이지를 사용 하면 사용자가 보고 공급 업체를 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-241">Our ASP.NET page, which we will create in Step 7, will allow users to view and edit suppliers.</span></span> <span data-ttu-id="334e7-242">따라서 최소한의 모든 공급 업체 및 다른 특정 공급 업체에 업데이트를 가져올 메서드를 제공 하 여 BLL 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-242">Therefore, we need our BLL to provide, at minimum, a method to get all of the suppliers and another to update a particular supplier.</span></span>

<span data-ttu-id="334e7-243">라는 새 클래스 파일을 만듭니다 `SuppliersBLLWithSprocs` 에 `~/App_Code/BLL` 폴더를 다음 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-243">Create a new class file named `SuppliersBLLWithSprocs` in the `~/App_Code/BLL` folder and add the following code:</span></span>


[!code-vb[Main](working-with-computed-columns-vb/samples/sample6.vb)]

<span data-ttu-id="334e7-244">다른 BLL 클래스와 같은 `SuppliersBLLWithSprocs` 에 `Protected` `Adapter` 속성의 인스턴스를 반환 하는 `SuppliersTableAdapter` 함께 두 개의 클래스 `Public` 메서드: `GetSuppliers` 및 `UpdateSupplier`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-244">Like the other BLL classes, `SuppliersBLLWithSprocs` has a `Protected` `Adapter` property that returns an instance of the `SuppliersTableAdapter` class along with two `Public` methods: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="334e7-245">`GetSuppliers` 호출 하 고 반환 하는 메서드는 `SuppliersDataTable` 해당 반환한 `GetSupplier` 데이터 액세스 계층에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="334e7-245">The `GetSuppliers` method calls and returns the `SuppliersDataTable` returned by the corresponding `GetSupplier` method in the Data Access Layer.</span></span> <span data-ttu-id="334e7-246">`UpdateSupplier` 메서드 DAL s에 대 한 호출을 통해 업데이트 되 고 특정 공급 업체에 대 한 정보를 검색 `GetSupplierBySupplierID(supplierID)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="334e7-246">The `UpdateSupplier` method retrieves information about the particular supplier being updated via a call to the DAL s `GetSupplierBySupplierID(supplierID)` method.</span></span> <span data-ttu-id="334e7-247">그런 다음 업데이트는 `CategoryName`, `ContactName`, 및 `ContactTitle` 속성 데이터 액세스 계층 s 호출 하 여 데이터베이스에 이러한 변경 내용을 커밋합니다 `Update` 전달 수정 된 메서드를 `SuppliersRow` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-247">It then updates the `CategoryName`, `ContactName`, and `ContactTitle` properties and commits these changes to the database by calling the Data Access Layer s `Update` method, passing in the modified `SuppliersRow` object.</span></span>

> [!NOTE]
> <span data-ttu-id="334e7-248">제외 하 고 `SupplierID` 및 `CompanyName`, Suppliers 테이블의 모든 열 허용 `NULL` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-248">Except for `SupplierID` and `CompanyName`, all columns in the Suppliers table allow `NULL` values.</span></span> <span data-ttu-id="334e7-249">따라서 경우에 전달 된 `contactName` 또는 `contactTitle` 매개 변수는 `Nothing` 해당 공간을 `ContactName` 및 `ContactTitle` 속성을는 `NULL` 사용 하 여 데이터베이스 값의 `SetContactNameNull` 및 `SetContactTitleNull`메서드를 각각.</span><span class="sxs-lookup"><span data-stu-id="334e7-249">Therefore, if the passed-in `contactName` or `contactTitle` parameters are `Nothing` we need to set the corresponding `ContactName` and `ContactTitle` properties to a `NULL` database value using the `SetContactNameNull` and `SetContactTitleNull` methods, respectively.</span></span>


## <a name="step-7-working-with-the-computed-column-from-the-presentation-layer"></a><span data-ttu-id="334e7-250">계산 열이 프레젠테이션 계층에서 작업 하는 7 단계:</span><span class="sxs-lookup"><span data-stu-id="334e7-250">Step 7: Working with the Computed Column from the Presentation Layer</span></span>

<span data-ttu-id="334e7-251">계산 열이 추가 `Suppliers` DAL 테이블 및 BLL 적절 하 게 업데이트, ASP.NET 페이지를 사용 하는 구성 준비가 `FullContactName` 계산된 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-251">With the computed column added to the `Suppliers` table and the DAL and BLL updated accordingly, we are ready to build an ASP.NET page that works with the `FullContactName` computed column.</span></span> <span data-ttu-id="334e7-252">열어 시작는 `ComputedColumns.aspx` 페이지에 `AdvancedDAL` 폴더와 디자이너 도구 상자에서 끌어서는 GridView입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-252">Start by opening the `ComputedColumns.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="334e7-253">GridView s 설정 `ID` 속성을 `Suppliers` 및 스마트 태그를 바인딩할 라는 새 ObjectDataSource `SuppliersDataSource`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-253">Set the GridView s `ID` property to `Suppliers` and, from its smart tag, bind it to a new ObjectDataSource named `SuppliersDataSource`.</span></span> <span data-ttu-id="334e7-254">ObjectDataSource 사용 하도록 구성 된 `SuppliersBLLWithSprocs` 추가 클래스 6 단계에서에서 백업 하 고 다음을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-254">Configure the ObjectDataSource to use the `SuppliersBLLWithSprocs` class we added back in Step 6 and click Next.</span></span>


<span data-ttu-id="334e7-255">[![ObjectDataSource SuppliersBLLWithSprocs 클래스를 사용 하도록 구성](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-255">[![Configure the ObjectDataSource to Use the SuppliersBLLWithSprocs Class](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span></span>

<span data-ttu-id="334e7-256">**그림 11**: 구성에 사용 하 여 ObjectDataSource는 `SuppliersBLLWithSprocs` 클래스 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image33.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-256">**Figure 11**: Configure the ObjectDataSource to Use the `SuppliersBLLWithSprocs` Class ([Click to view full-size image](working-with-computed-columns-vb/_static/image33.png))</span></span>


<span data-ttu-id="334e7-257">에 정의 된 두 개의 메서드는는 `SuppliersBLLWithSprocs` 클래스: `GetSuppliers` 및 `UpdateSupplier`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-257">There are only two methods defined in the `SuppliersBLLWithSprocs` class: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="334e7-258">이러한 두 가지 방법 선택에 지정 된 탭 각각 업데이트 및 확인는 ObjectDataSource의 구성을 완료 하려면 마침을 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-258">Ensure that these two methods are specified in the SELECT and UPDATE tabs, respectively, and click Finish to complete the configuration of the ObjectDataSource.</span></span>

<span data-ttu-id="334e7-259">데이터 소스 구성 마법사를 완료 하면 Visual Studio의 각 반환 된 데이터 필드에 대 한 BoundField를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-259">Upon completion of the Data Source Configuration wizard, Visual Studio will add a BoundField for each of the data fields returned.</span></span> <span data-ttu-id="334e7-260">제거는 `SupplierID` BoundField 변경는 `HeaderText` 의 속성은 `CompanyName`, `ContactName`, `ContactTitle`, 및 `FullContactName` BoundFields 회사, 연락처 이름, 제목 및 전체 연락처 이름에 각각.</span><span class="sxs-lookup"><span data-stu-id="334e7-260">Remove the `SupplierID` BoundField and change the `HeaderText` properties of the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` BoundFields to Company, Contact Name, Title, and Full Contact Name, respectively.</span></span> <span data-ttu-id="334e7-261">스마트 태그에서 편집을 사용 하도록 설정 하려면 확인란 GridView s 기본 제공 편집 기능을 켭니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-261">From the smart tag, check the Enable Editing checkbox to turn on the GridView s built-in editing capabilities.</span></span>

<span data-ttu-id="334e7-262">BoundFields GridView을 추가할 뿐 아니라 데이터 원본 마법사를 완료로 인해 Visual Studio를 설정 ObjectDataSource s `OldValuesParameterFormatString` 원래 속성\_{0}.</span><span class="sxs-lookup"><span data-stu-id="334e7-262">In addition to adding BoundFields to the GridView, completion of the Data Source Wizard also causes Visual Studio to set the ObjectDataSource s `OldValuesParameterFormatString` property to original\_{0}.</span></span> <span data-ttu-id="334e7-263">이 설정을 다시 기본값, {0}로 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-263">Revert this setting back to its default value, {0} .</span></span>

<span data-ttu-id="334e7-264">편집한 후 이러한 GridView 및 ObjectDataSource에 선언적 태그는 다음과 비슷하게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-264">After making these edits to the GridView and ObjectDataSource, their declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](working-with-computed-columns-vb/samples/sample7.aspx)]

<span data-ttu-id="334e7-265">그런 다음 브라우저를 통해이 페이지를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="334e7-265">Next, visit this page through a browser.</span></span> <span data-ttu-id="334e7-266">각 공급 업체는 포함 하는 표에 나열 된 그림 12에서 볼 수 있듯이 `FullContactName` 값은 다른 3 개의 열 연결한 단순히 열 형식으로 지정 `ContactName` (`ContactTitle`, `CompanyName`).</span><span class="sxs-lookup"><span data-stu-id="334e7-266">As Figure 12 shows, each supplier is listed in a grid that includes the `FullContactName` column, whose value is simply the concatenation of the other three columns formatted as `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>


<span data-ttu-id="334e7-267">[![각 공급 업체는 표에 나열 된](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-267">[![Each Supplier is Listed in the Grid](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span></span>

<span data-ttu-id="334e7-268">**그림 12**: 각 공급 업체는 표에 나열 된 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image36.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-268">**Figure 12**: Each Supplier is Listed in the Grid ([Click to view full-size image](working-with-computed-columns-vb/_static/image36.png))</span></span>


<span data-ttu-id="334e7-269">특정 공급 업체에서 포스트백이 발생 하 고 해당 행에서 렌더링 된에 대 한 편집 단추를 클릭 하면 (그림 13 참조) 인터페이스의 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-269">Clicking the Edit button for a particular supplier causes a postback and has that row rendered in its editing interface (see Figure 13).</span></span> <span data-ttu-id="334e7-270">처음 3 개의 열 편집 인터페이스 기본에서 렌더링-TextBox 컨트롤 `Text` 속성 데이터 필드의 값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-270">The first three columns render in their default editing interface - a TextBox control whose `Text` property is set to the value of the data field.</span></span> <span data-ttu-id="334e7-271">그러나 `FullContactName` , 열을 텍스트로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-271">The `FullContactName` column, however, remains as text.</span></span> <span data-ttu-id="334e7-272">BoundFields 데이터 소스 구성 마법사 완료 시 GridView에 추가 된 경우는 `FullContactName` BoundField s `ReadOnly` 속성이로 설정 된 `True` 때문에 해당 `FullContactName` 열에는 `SuppliersDataTable` 에 해당 `ReadOnly` 속성이로 설정 `True`합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-272">When the BoundFields were added to the GridView at the completion of the Data Source Configuration wizard, the `FullContactName` BoundField s `ReadOnly` property was set to `True` because the corresponding `FullContactName` column in the `SuppliersDataTable` has its `ReadOnly` property set to `True`.</span></span> <span data-ttu-id="334e7-273">4 단계에서에서 설명한 것 처럼는 `FullContactName` s `ReadOnly` 속성이로 설정 된 `True` TableAdapter 열이 계산된 열을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-273">As noted in Step 4, the `FullContactName` s `ReadOnly` property was set to `True` because the TableAdapter detected that the column was a computed column.</span></span>


<span data-ttu-id="334e7-274">[![FullContactName 열이 편집할 수 없습니다.](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="334e7-274">[![The FullContactName Column is Not Editable](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span></span>

<span data-ttu-id="334e7-275">**그림 13**:는 `FullContactName` 열이 편집할 수 없습니다 ([전체 크기 이미지를 보려면 클릭](working-with-computed-columns-vb/_static/image39.png))</span><span class="sxs-lookup"><span data-stu-id="334e7-275">**Figure 13**: The `FullContactName` Column is Not Editable ([Click to view full-size image](working-with-computed-columns-vb/_static/image39.png))</span></span>


<span data-ttu-id="334e7-276">계속 하는 편집 가능한 열 중 하나 이상의 값으로 업데이트를 업데이트를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-276">Go ahead and update the value of one or more of the editable columns and click Update.</span></span> <span data-ttu-id="334e7-277">참고 방법을 `FullContactName`의 값의 변경 내용을 반영 하도록 자동으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-277">Note how the `FullContactName` s value is automatically updated to reflect the change.</span></span>

> [!NOTE]
> <span data-ttu-id="334e7-278">GridView 현재 사용 BoundFields 편집 가능한 필드에 대 한 기본 인터페이스 편집으로 인해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-278">The GridView currently uses BoundFields for the editable fields, resulting in the default editing interface.</span></span> <span data-ttu-id="334e7-279">이후는 `CompanyName` 필드는 필수는 RequiredFieldValidator 포함 된를 TemplateField로 변환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-279">Since the `CompanyName` field is required, it should be converted into a TemplateField that includes a RequiredFieldValidator.</span></span> <span data-ttu-id="334e7-280">I이 그대로 실행으로 관심된 판독기에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-280">I leave this as an exercise for the interested reader.</span></span> <span data-ttu-id="334e7-281">참조는 [편집 및 삽입 인터페이스에 유효성 검사 컨트롤 추가](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) 자습서에 대 한 단계별 지침은 BoundField를 TemplateField를 변환 및 유효성 검사 컨트롤을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-281">Consult the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) tutorial for step-by-step instructions on converting a BoundField to a TemplateField and adding validation controls.</span></span>


## <a name="summary"></a><span data-ttu-id="334e7-282">요약</span><span class="sxs-lookup"><span data-stu-id="334e7-282">Summary</span></span>

<span data-ttu-id="334e7-283">Microsoft SQL Server 테이블에 대 한 스키마를 정의 하면 계산된 열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-283">When defining the schema for a table, Microsoft SQL Server allows the inclusion of computed columns.</span></span> <span data-ttu-id="334e7-284">이들은 일반적으로 동일한 레코드의 다른 열에서 값을 참조 하는 식에서 값이 계산 되는 열입니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-284">These are columns whose values are calculated from an expression that usually references the values from other columns in the same record.</span></span> <span data-ttu-id="334e7-285">값 이후 계산된 열은 식에 기반에 대 한 읽기 전용 이며 값을 할당할 수 없습니다는 `INSERT` 또는 `UPDATE` 문.</span><span class="sxs-lookup"><span data-stu-id="334e7-285">Since the values for computed columns are based on an expression, they are read-only and cannot be assigned a value in an `INSERT` or `UPDATE` statement.</span></span> <span data-ttu-id="334e7-286">자동으로 해당를 생성 하려고 하는 TableAdapter의 주 쿼리에서 계산된 열을 사용 하는 경우 문제에 소개 `INSERT`, `UPDATE`, 및 `DELETE` 문.</span><span class="sxs-lookup"><span data-stu-id="334e7-286">This introduces challenges when using a computed column in the main query of a TableAdapter that tries to automatically generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span>

<span data-ttu-id="334e7-287">이 자습서에서는 계산된 열에 의해 제기 되는 문제 해결에 대 한 기술에 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-287">In this tutorial we discussed techniques for circumventing the challenges posed by computed columns.</span></span> <span data-ttu-id="334e7-288">특히, 임시 SQL 문을 사용 하 여 Tableadapter에 내재 된 오류를 해결 하기 위해 우리의 TableAdapter에서 저장된 프로시저 사용.</span><span class="sxs-lookup"><span data-stu-id="334e7-288">In particular, we used stored procedures in our TableAdapter to overcome the brittleness inherent in TableAdapters that use ad-hoc SQL statements.</span></span> <span data-ttu-id="334e7-289">저장 프로시저를 TableAdapter 마법사 새로 만들기, 것이 주 쿼리에서 현재 상태는 데이터 수정 저장 프로시저 생성 되지 않도록 하기 때문에 계산된 열을 처음 생략 된 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-289">When having the TableAdapter wizard create new stored procedures, it is important that we have the main query initially omit any computed columns because their presence prevents the data modification stored procedures from being generated.</span></span> <span data-ttu-id="334e7-290">TableAdapter 처음에 구성 된 후 해당 `SelectCommand` 저장된 프로시저는 모든 계산된 열을 포함 하도록 retooled 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-290">After the TableAdapter has been initially configured, its `SelectCommand` stored procedure can be retooled to include any computed columns.</span></span>

<span data-ttu-id="334e7-291">만족도 매우 프로그래밍!</span><span class="sxs-lookup"><span data-stu-id="334e7-291">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="334e7-292">작성자 정보</span><span class="sxs-lookup"><span data-stu-id="334e7-292">About the Author</span></span>

<span data-ttu-id="334e7-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), 7 ASP/ASP.NET 서적과의 창립자의 작성자 [4GuysFromRolla.com](http://www.4guysfromrolla.com), 1998 이후 Microsoft 웹 기술과 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="334e7-294">Scott 독립 컨설턴트, 강사, 기술 및 작성기 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-294">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="334e7-295">그의 최신 서적은 [ *Sam 업무량이 직접 ASP.NET 2.0 24 시간 동안에서*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-295">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="334e7-296">에 연결할 수 그 [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) 에서 찾을 수 있는 그의 블로그를 통해 또는 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-296">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="334e7-297">특별히 감사</span><span class="sxs-lookup"><span data-stu-id="334e7-297">Special Thanks To</span></span>

<span data-ttu-id="334e7-298">이 자습서 시리즈 많은 유용한 검토자가 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-298">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="334e7-299">이 자습서에 대 한 선행 검토자 Hilton Geisenow 및 Teresa 머피의 했습니다.</span><span class="sxs-lookup"><span data-stu-id="334e7-299">Lead reviewers for this tutorial were Hilton Geisenow and Teresa Murphy.</span></span> <span data-ttu-id="334e7-300">향후 내 MSDN 문서를 검토에 관심이 있으십니까?</span><span class="sxs-lookup"><span data-stu-id="334e7-300">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="334e7-301">이 경우 drop me에 한 줄씩 [ mitchell@4GuysFromRolla.com합니다.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="334e7-301">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="334e7-302">[이전](adding-additional-datatable-columns-vb.md)
[다음](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span><span class="sxs-lookup"><span data-stu-id="334e7-302">[Previous](adding-additional-datatable-columns-vb.md)
[Next](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span></span>
