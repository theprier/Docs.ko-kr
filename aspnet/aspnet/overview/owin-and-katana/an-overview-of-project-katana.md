---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: 프로젝트 Katana 개요 | Microsoft Docs
author: howarddierking
description: ASP.NET 프레임 워크는 10 년 넘게 오랫동안 및 수많은 웹 사이트 및 서비스의 개발 플랫폼이 사용 하도록 설정 합니다. 웹 응용 프로그램으로 하는 중...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/30/2013
ms.topic: article
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
ms.technology: ''
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 212594b503bfc17d3faa6df03e01402d2862522f
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/03/2018
ms.locfileid: "37390190"
---
<a name="an-overview-of-project-katana"></a><span data-ttu-id="ca3d6-104">프로젝트 Katana 개요</span><span class="sxs-lookup"><span data-stu-id="ca3d6-104">An Overview of Project Katana</span></span>
====================
<span data-ttu-id="ca3d6-105">[Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="ca3d6-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="ca3d6-106">ASP.NET 프레임 워크는 10 년 넘게 오랫동안 및 수많은 웹 사이트 및 서비스의 개발 플랫폼이 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="ca3d6-107">웹 응용 프로그램 개발 전략 진화 하는 대로 프레임 워크를 ASP.NET MVC 및 ASP.NET Web API와 같은 기술 사용 하 여 단계에서 진화 할 수 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="ca3d6-108">클라우드 컴퓨팅의 세계로 다음 진화 단계를 사용 하는 웹 응용 프로그램 개발을 하는 대로 프로젝트 [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) ASP.NET 응용 프로그램을 유연 하 고 이식 가능 하며 사용할 수 있도록 구성 요소의 기본 집합을 제공 합니다. 경량 – 더 나은 성능을 제공 하 고 프로젝트, 다른 말로 [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) 클라우드 ASP.NET 응용 프로그램을 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>


## <a name="why-katana--why-now"></a><span data-ttu-id="ca3d6-109">왜 Katana – 이제 이유?</span><span class="sxs-lookup"><span data-stu-id="ca3d6-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="ca3d6-110">개발자 프레임 워크 또는 최종 사용자가 제품을 논의 하는 하나는 여부에 관계 없이, 것을 만들기 위한 기본 동기를 이해 해야 제품 – 및에 포함 제품에 대해 생성 된 사용자를 파악 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="ca3d6-111">ASP.NET 염두에서에 두 고객을 사용 하 여 원래 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="ca3d6-112">**고객의 첫 번째 그룹에는 기존 ASP 개발자 들은 했습니다.**</span><span class="sxs-lookup"><span data-stu-id="ca3d6-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="ca3d6-113">동시에 ASP interweaving 태그 및 서버 쪽 스크립트에서 동적, 데이터 기반 웹 사이트 및 응용 프로그램을 만들기 위한 기본 기술 중 하나 였습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="ca3d6-114">ASP 런타임 캐시, 등 추가에 대 한 액세스는 이러한 세션 및 응용 프로그램 상태 관리 서비스 제공 및 기본 HTTP 프로토콜 및 웹 서버 핵심 측면을 추상화 하는 개체의 집합을 사용 하 여 서버 쪽 스크립트를 제공 합니다. 강력, 클래식 ASP 응용 프로그램의 크기와 복잡성 증가할 때 관리 하는 문제를 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="ca3d6-115">이 구조 스크립팅 중복 되는 코드와 태그의 인터리빙에서 발생 하는 코드를 사용 하 여 결합 된 환경에서 찾을 수 없어서 대부분 이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-115">This was largely due to the lack of structure found in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="ca3d6-116">해당 과제 중 일부를 해결 하는 동안 기본 ASP의 장점을 활용을 위해 ASP.NET 활용도 서버 쪽 프로그래밍 모델을 유지 하면서.NET Framework의 개체 지향 언어에서 제공 하는 코드 조직 에 클래식 ASP 개발자 토대로 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="ca3d6-117">**ASP.NET에 대 한 대상 고객의 두 번째 그룹에는 Windows 비즈니스 응용 프로그램 개발자가 되었습니다.**</span><span class="sxs-lookup"><span data-stu-id="ca3d6-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="ca3d6-118">HTML 태그 및 자세한 HTML 태그를 생성 하는 코드를 작성 하는 데 익숙한 인 클래식 ASP 개발자에 달리 (예: 앞 VB6 개발자) WinForms 개발자 캔버스 및 다양 한 사용자를 포함 하는 디자인 타임 환경에 익숙한 것 인터페이스를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="ca3d6-119">첫 번째 버전의 ASP.NET – 라고도 "Web Forms" 제공 된 사용자 인터페이스 구성 요소에 대 한 서버 쪽 이벤트 모델 및 인프라 기능 (예: ViewState) 집합이 함께 비슷한 디자인 타임 환경을 완전무결 한 개발자 환경을 만들려면 클라이언트와 서버 쪽 프로그래밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="ca3d6-120">Web Forms에서 WinForms 개발자에 게 친숙 한 상태 저장 이벤트 모델을 웹의 상태 비저장 특성을 효과적으로 hid 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="ca3d6-121">기록 모델에서 발생 한 문제</span><span class="sxs-lookup"><span data-stu-id="ca3d6-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="ca3d6-122">**결과 완성도 높은, 풍부한 기능의 런타임 및 개발자 프로그래밍 모델을 했습니다.**</span><span class="sxs-lookup"><span data-stu-id="ca3d6-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="ca3d6-123">그러나 풍부한 기능을 강화 된 몇 가지 주목할 만한 문제를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="ca3d6-124">먼저는 프레임 워크가 **모놀리식**를 논리적으로 서로 다른 단위의 동일한 System.Web.dll 어셈블리 (예를 들어, Web forms 프레임 워크를 사용 하 여 HTTP 핵심 개체)에 밀접 하 게 결합 되는 기능을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="ca3d6-125">ASP.NET 있음을 의미 하는 큰.NET Framework의 일부로 포함 된 둘째,는 **릴리스 간의 시간은 년 순서입니다.**</span><span class="sxs-lookup"><span data-stu-id="ca3d6-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="ca3d6-126">이 인해 모든 변경 내용을 빠르게 발전 하는 웹 개발에서 발생 하는 ASP.NET 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="ca3d6-127">특정 웹 호스팅 옵션에는 몇 가지 방법으로 자체 System.Web.dll를 결합 하는 마지막으로: 인터넷 정보 서비스 (IIS).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="ca3d6-128">진화 단계: ASP.NET MVC 및 ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="ca3d6-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="ca3d6-129">및 웹 개발에서 발생 한 변경 많은!</span><span class="sxs-lookup"><span data-stu-id="ca3d6-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="ca3d6-130">많은 프레임 워크를 사용 하지 않고 구성 요소를 강조 하는 일련의 작은 웹 응용 프로그램을 개발한 되 고 점점 더 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="ca3d6-131">적이 더 빠른 속도로 증가 하 고 있는 출시 빈도 뿐만 아니라 구성 요소 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="ca3d6-132">웹과 속도 유지 프레임 워크를 작고 분리 된 더 크고 더 풍부한 기능의 대신 따라서 가져올 필요는 명백 합니다 **ASP.NET 팀의 제품군으로 ASP.NET을 사용 하도록 설정 하려면 몇 가지 진화 단계를 진행 합니다. 단일 프레임 워크 보다는 플러그형 웹 구성**합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="ca3d6-133">초기 변경이 Rails에 Ruby와 같은 웹 개발 프레임 워크 덕분 잘 알려진 모델-뷰-컨트롤러 (MVC) 디자인 패턴의 널리 사용 되 고 증가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="ca3d6-134">이 스타일의 웹 응용 프로그램 빌드 개발자를 지정한 ASP.NET에 대 한 초기 selling 지점 중 하나는 태그 및 비즈니스 논리 분리를 보존 하면서 자신의 응용 프로그램의 태그를 통해 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="ca3d6-135">이 스타일의 웹 응용 프로그램 개발에 대 한 요청을 충족 하기 위해 Microsoft는 자체 위치로 기회 하 여 미래를 위한 더 나은 **대역 외에서 ASP.NET MVC 개발** (및.NET Framework의 제외).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="ca3d6-136">ASP.NET MVC는 독립적인 다운로드로 출시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="ca3d6-137">이 기능을 통해 엔지니어링 팀에 가능 했던 것 보다 훨씬 더 자주 업데이트를 제공 하는 유연성입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="ca3d6-138">웹 응용 프로그램 개발의 다른 변화 된 통신 하는 클라이언트 쪽 스크립트에서 생성 된 페이지의 동적 섹션을 사용 하 여 정적 초기 태그를 동적으로 서버에서 생성 된 웹 페이지에서 shift **백 엔드 Web Api를 사용 하 여을 통해 AJAX 요청**합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="ca3d6-139">이 아키텍처 shift ASP.NET Web API 프레임 워크를 개발 및 웹 Api의 날 려 보내는 하는 데 도움이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="ca3d6-140">ASP.NET MVC의 경우와 같이 ASP.NET Web API의 릴리스는 ASP.NET 모듈식 프레임 워크로 더 발전 하는 또 다른 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="ca3d6-141">엔지니어링 팀 기회를 활용 하 고 **System.Web.dll 있는 core 프레임 워크 형식 중 하나에 종속성이 없는 이었습니다 되도록 ASP.NET Web API를 작성**.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="ca3d6-142">이 두 가지를 사용 하도록 설정: 하는 것 먼저 ASP.NET Web API를 완전히 독립적인 방식으로 개선할 수 (및 NuGet을 통해 배달 되기 때문에 신속 하 게 반복을 계속 될 수 있습니다).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="ca3d6-143">둘째, System.Web.dll 하는 외부 종속성 및 IIS에 종속성이 없는 따라서 있었습니다, ASP.NET Web API (예를 들어는 콘솔 응용 프로그램, Windows 서비스 등)는 사용자 지정 호스트에서 실행 하는 기능 포함</span><span class="sxs-lookup"><span data-stu-id="ca3d6-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="ca3d6-144">미래: 민첩 프레임 워크</span><span class="sxs-lookup"><span data-stu-id="ca3d6-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="ca3d6-145">다른 프레임 워크 구성 요소를 분리 하 고 다음 NuGet에서 해제 하 여 프레임 워크 수 이제 **요금과 보다 신속 하 게 반복**합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="ca3d6-146">성능과 유연성 Web API의 자체 호스팅 기능을 입증 하려고 했던 개발자에 게 그다지 또한을 **소규모의 간단한 호스트** 해당 서비스에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="ca3d6-147">그다지 매력적으로 증명, 실제로 다른 프레임 워크는이 기능에도 또 다른 목표 및 각 프레임 워크 자체 기본 주소에서 자체 호스트 프로세스에서 실행 및 관리 하는 데 필요한 (시작, 중지 등)에 새로운 과제를 표시이 독립적으로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="ca3d6-148">최신 웹 응용 프로그램에는 일반적으로 정적 파일 처리, 동적 페이지를 생성, Web API 및 보다 최근에 실시간으로 시간/푸시 알림을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="ca3d6-149">이러한 서비스의 각 실행 있고 독립적으로 관리할 필요 없었던 현실적인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="ca3d6-150">개발자는 다양 한 다른 구성 요소 및 프레임 워크에서에서 응용 프로그램을 작성 및 지 원하는 호스트에 해당 응용 프로그램을 실행 하는 단일 호스팅 추상화를가 필요 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="ca3d6-151">Open Web Interface for.NET (OWIN)</span><span class="sxs-lookup"><span data-stu-id="ca3d6-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="ca3d6-152">얻을 수 있는 장점을에서 영감을 받았습니다 [랙](http://rack.github.io/) Ruby 커뮤니티의.NET 커뮤니티의 몇몇 구성원이 웹 서버와 프레임 워크 구성 요소 간의 추상화를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="ca3d6-153">OWIN 추상화에 대 한 두 가지 디자인 목표 간단한 되었는지 및 다른 프레임 워크 형식에 가능한 한 최소한의 종속성 걸린다는 것 이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="ca3d6-154">이러한 두 가지 목표 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-154">These two goals help ensure:</span></span>

- <span data-ttu-id="ca3d6-155">새 구성 요소를 보다 쉽게 개발 및 사용 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="ca3d6-156">응용 프로그램 호스트와 잠재적으로 전체 플랫폼/운영 체제 간에 더 쉽게 이식할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="ca3d6-157">결과 추상화 두 가지 핵심 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="ca3d6-158">첫 번째는 환경 사전을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-158">The first is the environment dictionary.</span></span> <span data-ttu-id="ca3d6-159">이 데이터 구조는 모든 HTTP 요청 및 응답 뿐만 아니라 해당 하는 서버 상태를 처리 하는 데 필요한 상태를 저장 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="ca3d6-160">환경 사전은 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="ca3d6-161">OWIN 호환 웹 서버를 본문 스트림 및 HTTP 요청 및 응답 헤더 컬렉션 같은 데이터를 사용 하 여 환경 사전을 채우는 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="ca3d6-162">응용 프로그램 또는 프레임 워크 구성 요소 채우기 또는 추가 값을 사용 하 여 사전 업데이트 및 응답 본문 스트림에 쓸를 해야 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="ca3d6-163">환경 사전에 대 한 유형을 지정 하는 것 외에도 OWIN 사양 core 사전 키 값 쌍의 목록을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="ca3d6-164">예를 들어, 다음 표에서 HTTP 요청에 필요한 사전 키를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="ca3d6-165">키 이름</span><span class="sxs-lookup"><span data-stu-id="ca3d6-165">Key Name</span></span> | <span data-ttu-id="ca3d6-166">값 설명</span><span class="sxs-lookup"><span data-stu-id="ca3d6-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="ca3d6-167">요청 본문에 있는 경우는 Stream입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="ca3d6-168">요청 본문이 있으면 Stream.Null 자리 표시자로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="ca3d6-169">참조 [요청 본문](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="ca3d6-170">`IDictionary<string, string[]>` 요청 헤더입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="ca3d6-171">참조 [헤더](http://owin.org/html/owin.html#3-3-headers)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="ca3d6-172">A `string` 요청의 HTTP 요청 메서드를 포함 (예를 들어 `"GET"`, `"POST"`).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="ca3d6-173">`string` 요청 경로 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-173">A `string` containing the request path.</span></span> <span data-ttu-id="ca3d6-174">응용 프로그램 대리자;의 "루트"에 상대적인 경로 여야 합니다. 참조 [경로](http://owin.org/html/owin.html#5-3-paths)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="ca3d6-175">A `string` 참조 응용 프로그램 대리자;의 "루트"에 해당 하는 요청 경로의 일부를 포함 하 [경로](http://owin.org/html/owin.html#5-3-paths)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="ca3d6-176">A `string` 프로토콜 이름 및 버전 (예: `"HTTP/1.0"` 또는 `"HTTP/1.1"`).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="ca3d6-177">`string` 앞에 오는 하지 않고 HTTP 요청 URI 쿼리 문자열 구성 요소가 포함 된 "?" (예를 들어 `"foo=bar&baz=quux"`).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="ca3d6-178">값은 빈 문자열일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="ca3d6-179">`string` 요청에 사용 된 URI 구성표를 포함 (예를 들어 `"http"`를 `"https"`); 참조 [URI 체계](http://owin.org/html/owin.html#5-1-uri-scheme)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="ca3d6-180">OWIN의 두 번째 핵심 요소는 응용 프로그램 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="ca3d6-181">OWIN 응용 프로그램의 모든 구성 요소 간의 기본 인터페이스로 사용 되는 함수 시그니처입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="ca3d6-182">응용 프로그램 대리자에 대 한 정의 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="ca3d6-183">다음 응용 프로그램 대리자는 함수 환경 사전을 입력으로 허용 하 고는 작업을 반환 하는 여기서 Func 대리자 형식의 구현 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="ca3d6-184">이 디자인은 개발자를 위한 여러 가지를 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="ca3d6-185">OWIN 구성 요소를 작성 하는 데 필요한 유형 종속성의 매우 작은 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="ca3d6-186">이 개발자에 게 OWIN의 접근성을 향상 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="ca3d6-187">비동기 디자인 하 여 컴퓨팅 리소스에 더 많은 I/O 집약적인 작업에 특히 처리를 사용 하 여 효율적으로 추상화를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="ca3d6-188">응용 프로그램 대리자 실행의 원자 단위 이며 OWIN 구성 요소를 쉽게 연결할 수 있으므로 환경 사전에 대리자에 매개 변수로 작업 하기 때문에 복잡 한 HTTP 처리 파이프라인을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="ca3d6-189">OWIN은 사양 구현 측면에서 볼 때 ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="ca3d6-190">목표 다음 웹 프레임 워크를 하지만 웹 프레임 워크 및 웹 서버 상호 작용 하는 방법에 대 한 사양 대신 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="ca3d6-191">조사 했습니다 하는 경우 [OWIN](http://owin.org/) 또는 [Katana](https://github.com/aspnet/AspNetKatana/wiki), 또한 했을 수는 [Owin NuGet 패키지](http://nuget.org/packages/Owin) 및 Owin.dll 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="ca3d6-192">이 라이브러리는 단일 인터페이스를 포함 [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)를 공식화 하 고 시작 시퀀스에 설명 된 체계화 [섹션 4](http://owin.org/html/owin.html#4-application-startup) OWIN 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="ca3d6-193">OWIN 서버를 구축 하기 위해 필요는 없지만 합니다 [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) 인터페이스는 구체적 참조 지점으로 제공 하며 Katana 프로젝트 구성 요소에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="ca3d6-194">프로젝트 Katana</span><span class="sxs-lookup"><span data-stu-id="ca3d6-194">Project Katana</span></span>

<span data-ttu-id="ca3d6-195">반면 모두를 [OWIN](http://owin.org/html/owin.html) 사양 및 *Owin.dll* 소유 하는 커뮤니티 및 오픈 소스 작업을 실행 하는 커뮤니티를 [Katana](https://github.com/aspnet/AspNetKatana/wiki) 프로젝트에 OWIN의 집합을 나타내는 여전히 오픈 소스, 하는 동안 빌드하고 Microsoft에서 출시 되는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="ca3d6-196">이러한 구성 요소 호스트 및 서버와 같은 인프라 구성 요소 뿐만 아니라 인증 구성 요소 및 프레임 워크에 대 한 바인딩을 같은 기능적 구성 요소 포함 등 [SignalR](../../../signalr/index.md) 고 [ASP.NET 웹 API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="ca3d6-197">프로젝트에 다음과 같은 세 가지 상위 수준의 목표:</span><span class="sxs-lookup"><span data-stu-id="ca3d6-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="ca3d6-198">**이식 가능한** – 구성 요소를 쉽게 대체할 새 구성 요소에 대 한 사용 가능 해지면 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="ca3d6-199">이 모든 유형의 서버 및 호스트 하기 위해 프레임 워크에서 구성 요소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="ca3d6-200">이 목표의 Microsoft 프레임 워크가 타사 서버와 호스트에서 실행할 수 있지만 타사 프레임 워크 Microsoft 서버에는 실행 원활 하 게 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="ca3d6-201">**모듈식/유연한**– 기본적으로 켜져 있는 기능이 포함 되어 있는 많은 프레임 워크와는 달리 작고 집중 된 구성 요소를 결정 하는 데 응용 프로그램 개발자에 게 컨트롤을 통해 제공 Katana 프로젝트 구성 요소 이어야 합니다 응용 프로그램에서 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="ca3d6-202">**경량/성능/확장성** – 프레임 워크의 기존 개념을 작은 집합으로 분할 하 여 구성 요소는 명시적으로 추가 응용 프로그램 개발자가 더 적은 계산 결과 Katana 응용 프로그램을 사용할 수 있음 집중 리소스 및 결과적으로, 다른 유형의 서버 및 프레임 워크를 사용 하 여 보다 더 많은 부하를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="ca3d6-203">응용 프로그램의 요구 사항을 기본 인프라에서 더 많은 기능을 요청 하는 대로 OWIN 파이프라인에 추가할 수는 있지만 응용 프로그램 개발자는 명시적 의사 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="ca3d6-204">또한 하위 수준 구성 요소 대체는 사용 가능 해지면 새로운 고성능 서버 원활 하 게 도입할 수 있습니다 이러한 응용 프로그램을 중단 하지 않고 OWIN 응용 프로그램의 성능을 개선 하기 위해 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="ca3d6-205">Katana 구성 요소를 사용 하 여 시작</span><span class="sxs-lookup"><span data-stu-id="ca3d6-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="ca3d6-206">처음으로 도입의 측면 중 하나는 [Node.js](http://nodejs.org/) 즉시 사람들의 관심을 그린는 프레임 워크가 있는 작성 및 웹 서버를 실행할 수 있습니다 하나는 단순성입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="ca3d6-207">Katana 목표 light의 포함 된 경우 [Node.js](http://nodejs.org/), Katana 다양 한 장점을 제공 하는 한다는 것으로 요약할 수 있습니다 하나 [Node.js](http://nodejs.org/) (및 그와 같은 프레임 워크) 버릴 수 개발자 시작 하지 않고 모든 ASP.NET 웹 응용 프로그램을 개발 하는 방법에 대 한 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="ca3d6-208">참이 문에 대 한 Katana 프로젝트 시작 동일 하 게 간단해 야 기본적에서 [Node.js](http://nodejs.org/)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="ca3d6-209">"Hello World!" 만들기</span><span class="sxs-lookup"><span data-stu-id="ca3d6-209">Creating "Hello World!"</span></span>

<span data-ttu-id="ca3d6-210">JavaScript 및.NET 개발 간의 주요 차이점 중 하나 (유무) 컴파일러의 경우</span><span class="sxs-lookup"><span data-stu-id="ca3d6-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="ca3d6-211">따라서 간단한 Katana 서버에 대 한 시작 지점에는 Visual Studio 프로젝트입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="ca3d6-212">그러나 프로젝트 형식의 가장 최소를 사용 하 여 시작할 수 있습니다: 빈 ASP.NET 웹 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="ca3d6-213">다음으로 설치 합니다 [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) 프로젝트에 NuGet 패키지.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="ca3d6-214">이 패키지는 ASP.NET 요청 파이프라인에서 실행 되는 OWIN 서버를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="ca3d6-215">찾을 수 있습니다 합니다 [NuGet 갤러리](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) Visual Studio 패키지 관리자 대화 상자 또는 패키지 관리자 콘솔을 사용 하 여 다음 명령을 사용 하 여 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="ca3d6-216">설치는 `Microsoft.Owin.Host.SystemWeb` 패키지 종속성으로 몇 가지 추가 패키지를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="ca3d6-217">해당 종속성 중 하나는 `Microsoft.Owin`, 몇 가지 도우미 형식 및 OWIN 응용 프로그램을 개발 하기 위한 메서드를 제공 하는 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="ca3d6-218">"Hello world" 서버를 신속 하 게 쓸 이러한 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="ca3d6-219">Visual Studio를 사용 하 여이 간단한 웹 서버를 실행할 수 있습니다 **F5** 명령 및 디버깅에 대 한 전체 지원을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="ca3d6-220">호스트를 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-220">Switching hosts</span></span>

<span data-ttu-id="ca3d6-221">기본적으로 이전 "hello world" 예제는 IIS의 컨텍스트에서 System.Web를 사용 하는 ASP.NET 요청 파이프라인에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="ca3d6-222">이 수 자체로 엄청난 하므로 값을 추가 유연성 및 관리 기능을 사용 하 여 OWIN 파이프라인을 작성 하 고 IIS의 전체 완성도 활용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="ca3d6-223">그러나 여기서 IIS에서 제공 되는 혜택은 필요 하지 않습니다 하 고 더 작은가 벼 워 졌습니다 호스트에 대 한 요구는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="ca3d6-224">필요한 것, 그런 다음 IIS 및 System.Web와 같이 외부에서 간단한 웹 서버를 실행 하 시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="ca3d6-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="ca3d6-225">이식성 목표를 설명 하기 위해 명령줄 호스트 웹 서버 호스트에서 이동 하려면 프로젝트의 출력 폴더에 새 서버와 호스트 종속성을 추가 하기만 하면 및 다음 호스트를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="ca3d6-226">이 예제에서는 웹 서버 라는 Katana 호스트에서 호스트할 `OwinHost.exe` Katana HttpListener 기반 서버를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="ca3d6-227">마찬가지로 다른 Katana 구성 요소로, 이러한 획득 다음 명령을 사용 하 여 NuGet에서:</span><span class="sxs-lookup"><span data-stu-id="ca3d6-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="ca3d6-228">명령줄에서 수 후 프로젝트 루트 폴더로 이동 하 고 실행 하는 `OwinHost.exe` (함께 설치 된 각 NuGet 패키지의 tools 폴더에서).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="ca3d6-229">기본적으로 `OwinHost.exe` HttpListener 기반 서버에 대 한 확인 하도록 구성 된 이므로 추가 구성이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="ca3d6-230">웹 브라우저에서 탐색 `http://localhost:5000/` 콘솔을 통해 이제 실행 중인 응용 프로그램을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="ca3d6-231">Katana 아키텍처</span><span class="sxs-lookup"><span data-stu-id="ca3d6-231">Katana Architecture</span></span>

 <span data-ttu-id="ca3d6-232">Katana 구성 요소 아키텍처 아래와 같이 4 개의 논리적 계층으로 응용 프로그램을 나누는: *호스트, 서버, 미들웨어* 하 고 *응용 프로그램*합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="ca3d6-233">구성 요소 아키텍처는 이러한 계층의 구현을 쉽게 대체할 수, 대부분의 경우 응용 프로그램의 다시 컴파일하지 않고도 하는 방식으로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="ca3d6-234">호스트</span><span class="sxs-lookup"><span data-stu-id="ca3d6-234">Host</span></span>

 <span data-ttu-id="ca3d6-235">호스트는 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-235">The host is responsible for:</span></span>

- <span data-ttu-id="ca3d6-236">기본 프로세스를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-236">Managing the underlying process.</span></span>
- <span data-ttu-id="ca3d6-237">서버를 선택 하 고는 요청을 통해 OWIN 파이프라인을 생성 하는 워크플로 오케스트레이션 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

  <span data-ttu-id="ca3d6-238">현재는 Katana 기반 응용 프로그램에 대 한 3 주 호스팅 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="ca3d6-239">**Iis/ASP.NET**: 표준 HttpModule 및 HttpHandler 형식을 사용 하 여, OWIN 파이프라인 실행할 수 있습니다 IIS에서 ASP.NET 요청 흐름의 일환으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="ca3d6-240">ASP.NET 호스팅 지원 웹 응용 프로그램 프로젝트로 Microsoft.AspNet.Host.SystemWeb NuGet 패키지를 설치 하 여 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="ca3d6-241">또한 IIS 호스트와 서버 역할을 하므로 OWIN 서버/호스트 구분은 부모의 SystemWeb 호스트를 사용 하는 경우 개발자 수 없습니다. 대체 서버 구현을 대체 하므로이 NuGet 패키지에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="ca3d6-242">**사용자 지정 호스트**: The Katana 구성 요소 제품군 있게 개발자가 자신의 사용자 지정 프로세스에서 호스트 응용 프로그램에는 콘솔 응용 프로그램, Windows 서비스 등 무엇 인지에 있습니다. 이 기능은 Web API에서 제공 되는 기능은 자체 호스트 하는 것과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="ca3d6-243">다음 예제에서는 웹 API 코드의 사용자 지정 호스트를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="ca3d6-244">Katana 응용 프로그램을 위한 자체 호스트 설정이 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="ca3d6-245">Web API 및 Katana self-host 예제 간의 주요 차이점 중 하나는 Web API 구성 코드 Katana self-host 예제에서 누락 된 경우</span><span class="sxs-lookup"><span data-stu-id="ca3d6-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="ca3d6-246">Katana는 이식성 및 작성을 사용 하도록 설정 하기 위해 요청 처리 파이프라인을 구성 하는 코드에서 서버를 시작 하는 코드를 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="ca3d6-247">그런 다음 웹 API를 구성 하는 코드는 또한 WebApplication.Start에서 형식 매개 변수로 지정 된 시작 클래스에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="ca3d6-248">Startup 클래스는 문서의 뒷부분에서 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="ca3d6-249">그러나 코드는 ASP.NET Web API를 자체 호스팅하는 응용 프로그램에서 사용 하 여 현재 코드를 자체 호스트 프로세스 것과 상당히 비슷한 Katana를 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="ca3d6-250">**OwinHost.exe**: Katana 웹 응용 프로그램을 실행 하는 사용자 지정 프로세스를 작성 하려고 하는 일부를 하는 동안 여러 하려는 서버를 시작 하 고 응용 프로그램을 실행할 수 있는 미리 빌드된 실행 파일을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="ca3d6-251">Katana 구성 요소 suite는이 시나리오에서는 다음을 포함 합니다. `OwinHost.exe`합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="ca3d6-252">프로젝트의 루트 디렉터리 내에서 실행 하는 경우이 실행 파일 (HttpListener 서버 기본적으로 사용) 하는 서버 시작 되며를 찾아 사용자의 startup 클래스를 실행 하려면 규칙을 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="ca3d6-253">보다 세분화 된 컨트롤에 대 한 실행 파일 추가 명령줄 매개 변수 개수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="ca3d6-254">서버</span><span class="sxs-lookup"><span data-stu-id="ca3d6-254">Server</span></span>

 <span data-ttu-id="ca3d6-255">호스트는 시작 하 고 있는 응용 프로그램이 실행 되는 프로세스를 서버의 책임을 유지 관리 하는 일을 담당 하는 동안 네트워크 소켓을 열고, 요청에 대 한 수신 파이프라인의 OWIN 구성 요소를 통해 보낼 지정 (때 사용자가 이미 나타나는데,이 파이프라인은 응용 프로그램 개발자의 Startup 클래스에 지정 된)</span><span class="sxs-lookup"><span data-stu-id="ca3d6-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="ca3d6-256">현재 Katana 프로젝트에 두 가지 서버 구현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="ca3d6-257">**Microsoft.Owin.Host.SystemWeb**: 앞서 언급 했 듯이, ASP.NET 파이프라인을 사용 하 여 함께에서 IIS 호스트와 서버 역할도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="ca3d6-258">따라서이 호스팅 옵션을 선택 하는 경우 IIS 프로세스 활성화 같은 호스트 수준 문제를 관리 및 HTTP 요청을 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="ca3d6-259">ASP.NET 웹 응용 프로그램에 대 한 다음 보냅니다 요청은 ASP.NET 파이프라인에.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="ca3d6-260">Katana SystemWeb 호스트는 HTTP 파이프라인을 통과 하며 사용자가 지정한 OWIN 파이프라인을 통해 보낼 요청을 가로채 ASP.NET HttpModule 및 HttpHandler를 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="ca3d6-261">**Microsoft.Owin.Host.HttpListener**: 해당 이름으로이 Katana 서버 클래스 사용 하 여.NET Framework의 HttpListener 소켓을 열고 개발자가 지정한 OWIN 파이프라인으로 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="ca3d6-262">이 옵션은 현재 Katana 자체 호스팅하는 API와 OwinHost.exe에 대 한 기본 서버 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="ca3d6-263">미들웨어/프레임 워크</span><span class="sxs-lookup"><span data-stu-id="ca3d6-263">Middleware/framework</span></span>

 <span data-ttu-id="ca3d6-264">이전에 설명한 것 처럼 서버가 클라이언트에서 요청을 수락 하는 경우 담당 OWIN 구성 요소 개발자의 시작 코드에서 지정 하는 파이프라인을 통해 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="ca3d6-265">이러한 파이프라인 구성 요소를 사용 하 여 미들웨어 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="ca3d6-266">기본적인 수준에서 OWIN 미들웨어 구성 요소는 간단히 호출할 수 있도록 OWIN 응용 프로그램 대리자를 구현 하 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="ca3d6-267">그러나 미들웨어 구성 요소 조합 고 개발을 간소화 하기 위해 Katana는 적은 수의 규칙 및 도우미 형식 미들웨어 구성 요소에 대 한 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="ca3d6-268">이러한 가장 일반적입니다는 `OwinMiddleware` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="ca3d6-269">이 클래스를 사용 하 여 빌드된 사용자 지정 미들웨어 구성 요소는 다음과 비슷하게 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="ca3d6-270">이 클래스에서 파생 됩니다 `OwinMiddleware`, 해당 인수 중 하나로 파이프라인의 다음 미들웨어의 인스턴스를 받고 그런 다음 기본 생성자에 전달 하는 생성자를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="ca3d6-271">또한 미들웨어를 구성 하는 데 사용 되는 추가 인수는 다음 미들웨어 매개 변수 뒤 생성자 매개 변수로 선언 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="ca3d6-272">런타임 시 미들웨어가 실행 되는 재정의 통해 `Invoke` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="ca3d6-273">이 메서드는 형식의 단일 인수 `OwinContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="ca3d6-274">이 컨텍스트 개체에서 제공 되는 `Microsoft.Owin` NuGet 패키지는 앞에서 설명한 하 고 몇 가지 추가 도우미 형식과 함께 요청, 응답 및 환경 사전에 대 한 강력한 형식의 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="ca3d6-275">미들웨어 클래스 쉽게 추가할 수를 OWIN 파이프라인에 응용 프로그램 시작 코드를 다음과 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="ca3d6-276">미들웨어 구성 요소에서 간단한에 이르기까지 Katana 인프라 OWIN 미들웨어 구성 요소를 파이프라인을 간단히 구축 및 구성 요소는 단순히 파이프라인에 참여 하도록 응용 프로그램 대리자를 지원 해야 하기 때문에 ASP.NET Web API와 같은 전체 프레임 워크에로 거 나 [SignalR](../../../signalr/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="ca3d6-277">예를 들어, 이전 OWIN 파이프라인에 ASP.NET Web API를 추가할 필요 다음 시작 코드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="ca3d6-278">Katana 인프라 구성 방법 IAppBuilder 개체에 추가 된 순서에 따라 미들웨어 구성 요소는 파이프라인을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="ca3d6-279">그런 다음 예에서 LoggerMiddleware 이러한 요청은 궁극적으로 처리 하는 방법에 관계 없이 파이프라인을 통해 이동 하는 모든 요청을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="ca3d6-280">이 미들웨어 구성 요소 (예: 인증 구성 요소) 여러 구성 요소 및 프레임 워크 (예: ASP.NET Web API, SignalR 및 정적 파일 서버)를 포함 하는 파이프라인에 대 한 요청을 처리할 수 있는 강력한 시나리오를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="ca3d6-281">응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="ca3d6-281">Applications</span></span>

<span data-ttu-id="ca3d6-282">이전 예제에서 볼 수 있듯이, OWIN 및 Katana 프로젝트 없습니다 생각해 야 응용 프로그램 프로그래밍 모델 및 프레임 워크 서버 및 호스팅 인프라에서 분리 하는 추상화 대신 새 응용 프로그램 프로그래밍 모델을 아니라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="ca3d6-283">예를 들어, Web API 응용 프로그램을 빌드할 때 개발자 프레임 워크 Katana 프로젝트에서 구성 요소를 사용 하 여 OWIN 파이프라인의 응용 프로그램을 실행 하는 여부에 관계 없이 ASP.NET Web API 프레임 워크를 사용 하 여 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="ca3d6-284">OWIN 관련 코드 응용 프로그램 개발자에 게 표시 될 위치 한곳 개발자 OWIN 파이프라인을 작성 하는 여기서 응용 프로그램 시작 코드에 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="ca3d6-285">시작 코드에서 개발자는 일련의 들어오는 요청을 처리 하는 각 미들웨어 구성 요소에 대 한 일반적으로 UseXx 문 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="ca3d6-286">이 환경은 현재 System.Web 전 세계에서 HTTP 모듈을 등록 하는 것과 같은 효과 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="ca3d6-287">일반적으로 더 큰 프레임 워크와 같은 미들웨어 ASP.NET Web API 또는 [SignalR](../../../signalr/index.md) 파이프라인의 끝에 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="ca3d6-288">모든 프레임 워크 및 파이프라인의 뒷부분에서 등록 된 구성 요소에 대 한 요청 처리 됩니다 있도록 캐싱 또는 인증에 대 한 것과 같은 교차 미들웨어 구성 요소는 일반적으로 파이프라인의 시작 부분 쪽으로 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="ca3d6-289">이 분리 미들웨어 구성 요소 및 기본 인프라 구성 요소에서 서로 다른 구성 요소를 전체 시스템이 안정적으로 유지 하면서 다양 한 속도에서 진화를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="ca3d6-290">구성 요소-NuGet 패키지</span><span class="sxs-lookup"><span data-stu-id="ca3d6-290">Components – NuGet Packages</span></span>

<span data-ttu-id="ca3d6-291">Katana 프로젝트 구성 요소는 많은 현재 라이브러리 및 프레임 워크와 마찬가지로 NuGet 패키지 집합으로 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="ca3d6-292">이후 버전 2.0에 대 한 Katana 패키지 종속성 그래프의 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="ca3d6-293">(더 크게 보려면 이미지 클릭).</span><span class="sxs-lookup"><span data-stu-id="ca3d6-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="ca3d6-294">Katana 프로젝트에서 거의 모든 패키지에 따라 달라 집니다, 직접 또는 간접적으로 Owin 패키지 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="ca3d6-295">이 섹션 4 OWIN 사양에 설명 된 응용 프로그램 시작 시퀀스의 구체적인 구현을 제공 하는 IAppBuilder 인터페이스를 포함 하는 패키지는 아마 기억하실 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="ca3d6-296">또한 많은 패키지에 따라 달라 집니다 Microsoft.Owin HTTP 요청 및 응답 작업에 대 한 도우미 형식 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="ca3d6-297">패키지의 나머지 부분에서는 호스팅 인프라 패키지 (서버 또는 호스트) 또는 미들웨어로 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="ca3d6-298">패키지 및 종속성 Katana 프로젝트 외부에 주황색으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="ca3d6-299">Katana 2.0에 대 한 호스팅 인프라의 SystemWeb 및 HttpListener 기반 서버, OwinHost.exe를 사용 하 여 OWIN 응용 프로그램을 실행 하기 위한 OwinHost 패키지 및 OWIN 응용 프로그램에서 자체 호스팅 Microsoft.Owin.Hosting 패키지 모두를 포함 한 사용자 지정 호스트 (예: 콘솔 응용 프로그램, Windows 서비스 등)</span><span class="sxs-lookup"><span data-stu-id="ca3d6-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="ca3d6-300">Katana 2.0 미들웨어 구성 요소는 주로 다른 인증 수단을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="ca3d6-301">시작 및 오류 페이지에 대 한 지원을 사용 하도록 설정 하는 하나의 추가 미들웨어 구성 요소 진단을 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="ca3d6-302">OWIN 호스팅 사실상 추상화로 증가 함에 따라, Microsoft 및 타사에서 개발한 것 모두 미들웨어 구성 요소 에코 시스템도 수에서 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="ca3d6-303">결론</span><span class="sxs-lookup"><span data-stu-id="ca3d6-303">Conclusion</span></span>

 <span data-ttu-id="ca3d6-304">해당부터 Katana 프로젝트의 목표를 만들고 있으므로 개발자가 또 웹 프레임 워크에 알아보려면 강제 적용 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="ca3d6-305">대신, 목표.NET 웹 응용 프로그램 개발자가 가능 했습니다 이전 보다 더 많은 선택 옵션이 제공 하는 추상화를 만들려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="ca3d6-306">논리적 계층을 일반적인 웹 응용 프로그램 스택의 대체할 수 있는 구성 요소 집합으로 나누면 Katana 프로젝트에서 이러한 구성 요소에 적합 한 모든 속도 향상 시킬 스택 전체에서 구성 요소를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="ca3d6-307">간단한 OWIN 추상화 모든 구성 요소를 빌드하여 Katana은 프레임 워크 및 응용 프로그램을 기반으로 구축 된 다양 한 서로 다른 서버와 호스트 간에 이식 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="ca3d6-308">스택의 컨트롤에서 개발자를 넣어 Katana 개발자 경량 하는 방법에 대 한 궁극적인 선택할 수 있도록 보장 하는 방법 기능을 갖춘 자신의 웹 스택 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  
  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="ca3d6-309">Katana에 대 한 자세한 내용은</span><span class="sxs-lookup"><span data-stu-id="ca3d6-309">For more information about Katana</span></span>

- <span data-ttu-id="ca3d6-310">GitHub에서 Katana 프로젝트: [ https://github.com/aspnet/AspNetKatana/ ](https://github.com/aspnet/AspNetKatana/)합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="ca3d6-311">비디오: [Katana 프로젝트-ASP.NET 용 OWIN](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), Howard Dierking 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="ca3d6-312">감사의 글</span><span class="sxs-lookup"><span data-stu-id="ca3d6-312">Acknowledgements</span></span>

- <span data-ttu-id="ca3d6-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT) ) Rick은 프로그래밍 수석 테크니컬 Microsoft Azure 및 MVC에 집중 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca3d6-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="ca3d6-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [ @shanselman ](https://twitter.com/shanselman) )</span><span class="sxs-lookup"><span data-stu-id="ca3d6-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="ca3d6-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [ @jongalloway ](https://twitter.com/jongalloway) )</span><span class="sxs-lookup"><span data-stu-id="ca3d6-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>
